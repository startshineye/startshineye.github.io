<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="w-Spring-Boot-五-springboot-devtools-热部署" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/15/Spring-Boot-五-springboot-devtools-热部署/">Spring Boot(五)-springboot+devtools(热部署)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>1.在前一节中,我们通过改变方法的返回值,不需要重新部署后就可以在前端直接显示,但是我们添加新的方法之后,访问就访问不到,热部署失败<br>2.通过使用springloaded进行热部署,但是有些代码修改了,并不会进行热部署  </p>
<h4 id="spring-boot-devtools"><a href="#spring-boot-devtools" class="headerlink" title="spring-boot-devtools"></a>spring-boot-devtools</h4><p>1.spring-boot-devtools 是一个为开发者服务的一个模块，其中最重要的功能就是自动应用代码更改到最新的App上面去。原理是在发现代码有更改之后，重新启动应用，但是速度比手动停止后再启动还要更快，更快指的不是节省出来的手工操作的时间。<br>2.其深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为  restart ClassLoader<br>3.这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间（5秒以内）</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="1-添加依赖包"><a href="#1-添加依赖包" class="headerlink" title="1.添加依赖包"></a>1.添加依赖包</h5><p>因为是使用spring-boot-devtools,所以我们应该添加此包的时候注释掉spring-loader. </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</div><div class="line">        &lt;optional&gt;true&lt;/optional&gt;</div><div class="line">       &lt;scope&gt;true&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="2-添加spring-boot-maven-plugin"><a href="#2-添加spring-boot-maven-plugin" class="headerlink" title="2.添加spring-boot-maven-plugin"></a>2.添加spring-boot-maven-plugin</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  &lt;build&gt;</div><div class="line">&lt;plugins&gt;</div><div class="line">    &lt;plugin&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">           &lt;configuration&gt;</div><div class="line">         		&lt;!--fork :  如果没有该项配置，肯呢个devtools不会起作用，即应用不会restart --&gt;</div><div class="line">               &lt;fork&gt;true&lt;/fork&gt;</div><div class="line">           &lt;/configuration&gt;</div><div class="line">       &lt;/plugin&gt;</div><div class="line">&lt;/plugins&gt;</div><div class="line">  &lt;/build&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="3-说明"><a href="#3-说明" class="headerlink" title="3.说明"></a>3.说明</h5><p>1.devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机），注意：因为其采用的虚拟机机制，该项重启是很快的。<br>2.devtools可以实现页面热部署（即页面修改后会立即生效，这个可以直接在application.properties文件中配置spring.thymeleaf.cache=false来实现(这里注意不同的模板配置不一样)。  </p>
<h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h5><p>去掉spring-boot:run,然后启动：<br>添加方法：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   @RequestMapping(&quot;/hello2&quot;)</div><div class="line">public String hello2()&#123;</div><div class="line">	return &quot;hello2&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>输入:<a href="http://localhost:8080/hello2" target="_blank" rel="external">http://localhost:8080/hello2</a>  输出:”hello2”</p>
<p>添加类Hello2Controller:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   @RestController</div><div class="line">   public class Hello2Controller &#123;</div><div class="line"></div><div class="line">@RequestMapping(&quot;/hello2c&quot;)</div><div class="line">   public String hello()&#123;</div><div class="line">   	return &quot;Hello2Controller&quot;;</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><p>输入：<a href="http://localhost:8080/hello2c" target="_blank" rel="external">http://localhost:8080/hello2c</a>  输出:”Hello2Controller”</p>
<p>1.修改类–&gt;保存：应用会重启<br>2.修改配置文件–&gt;保存：应用会重启<br>3.修改页面–&gt;保存：应用会重启，页面会刷新（原理是将spring.thymeleaf.cache设为false  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/15/Spring-Boot-五-springboot-devtools-热部署/" class="archive-article-date">
  	<time datetime="2017-07-15T09:27:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Spring-Boot-四-Spring-Boot热部署-springloader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/15/Spring-Boot-四-Spring-Boot热部署-springloader/">Spring Boot(四)-Spring Boot热部署(springloader)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h4><ol>
<li>热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。</li>
<li>在编写代码的时候，你会发现我们只是简单把打印信息改变了，就需要重新部署，如果是这样的编码方式，那么我们估计一天下来就真的是打几个Hello World就下班了。那么如何解决热部署的问题呢？那就是springloaded</li>
</ol>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="1-添加plugin"><a href="#1-添加plugin" class="headerlink" title="1.添加plugin"></a>1.添加plugin</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  &lt;!-- 构造编译节点 --&gt;</div><div class="line">  &lt;build&gt;</div><div class="line">  &lt;!-- 添加springloader plugin --&gt;</div><div class="line">  &lt;plugins&gt;</div><div class="line">    &lt;plugin&gt;</div><div class="line">       		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">       		&lt;artifactId&gt;spring-boot-maven-plugin &lt;/artifactId&gt;</div><div class="line">       		&lt;dependencies&gt;  </div><div class="line">          &lt;dependency&gt;  </div><div class="line">              &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </div><div class="line">              &lt;artifactId&gt;springloaded&lt;/artifactId&gt;  </div><div class="line">              &lt;version&gt;1.2.4.RELEASE&lt;/version&gt;</div><div class="line">          &lt;/dependency&gt;  </div><div class="line">       &lt;/dependencies&gt;  </div><div class="line">       &lt;executions&gt;  </div><div class="line">          &lt;execution&gt;  </div><div class="line">              &lt;goals&gt;  </div><div class="line">                  &lt;goal&gt;repackage&lt;/goal&gt;  </div><div class="line">              &lt;/goals&gt;  </div><div class="line">              &lt;configuration&gt;  </div><div class="line">                  &lt;classifier&gt;exec&lt;/classifier&gt;  </div><div class="line">              &lt;/configuration&gt;  </div><div class="line">          &lt;/execution&gt;  </div><div class="line">     		&lt;/executions&gt;</div><div class="line">&lt;/plugin&gt;</div><div class="line">  &lt;/plugins&gt;</div><div class="line"> &lt;/build&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="2-运行"><a href="#2-运行" class="headerlink" title="2.运行"></a>2.运行</h5><p>有两种启动方式来测试热部署</p>
<h6 id="2-1方式一"><a href="#2-1方式一" class="headerlink" title="2.1方式一"></a>2.1方式一</h6><p>使用spring-boot:run<br>右键项目-&gt;run as-&gt;maven build-&gt;在goals里面添加spring-boot:run<br><img src="https://github.com/startshineye/img/blob/master/2017/7/6.png" alt=""><br>操作:<br><img src="https://github.com/startshineye/img/blob/master/2017/7/7.png" alt=""><br>改动HelloController中hello方法:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(&quot;/hello&quot;)</div><div class="line">public String hello()&#123;</div><div class="line">return &quot;hello world&quot;+(new Date());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p><img src="https://github.com/startshineye/img/blob/master/2017/7/8.png" alt=""></p>
<p>注意：使用spring-boot:run时候我们关掉应用,然后重新在app.main中run as java apllication会出现错误:<br><img src="https://github.com/startshineye/img/blob/master/2017/7/9.png" alt=""><br>说明端口号已经被暂用,但是我们已经关闭了应用后在启动的<br>原因:虽然我们已经关闭了应用,但是进程还没有关闭,启动任务管理器去关闭进程<br><img src="https://github.com/startshineye/img/blob/master/2017/7/10.png" alt=""></p>
<h6 id="2-2方式二"><a href="#2-2方式二" class="headerlink" title="2.2方式二"></a>2.2方式二</h6><p>基于以上原因我们还是运用第二种方式比较好  </p>
<p>1.把spring-loader-1.2.4.RELEASE.jar下载下来，放到项目的lib目录中<img src="https://github.com/startshineye/img/blob/master/2017/7/11.png" alt=""><br>2.然后把IDEA的run参数里VM参数设置为：-javaagent:.\lib\springloaded-1.2.4.RELEASE.jar -noverify<br><a href="https://github.com/startshineye/img/blob/master/2017/7/12.png"></a><br>2.然后启动就可以了，这样在run as的时候，也能进行热部署<br>改变hello返回值之后再次访问浏览器还是正确的</p>
<h5 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h5><p>假如我们新加一个方法hello2()时候再次访问hello2中时候不会输出</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/15/Spring-Boot-四-Spring-Boot热部署-springloader/" class="archive-article-date">
  	<time datetime="2017-07-15T07:30:14.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Spring-Boot-三-Spring-Boot完美使用FastJson解析JSON数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/15/Spring-Boot-三-Spring-Boot完美使用FastJson解析JSON数据/">Spring Boot(三)-Spring Boot完美使用FastJson解析JSON数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>有些人使用比较习惯的json框架是fastjson,所以spring boot默认的json使用起来比较不习惯，所以很自然我就想能不能使用fastjson进行json解析呢？</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-引入fastjson依赖库"><a href="#1-引入fastjson依赖库" class="headerlink" title="1.引入fastjson依赖库"></a>1.引入fastjson依赖库</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;dependency&gt;</div><div class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;1.2.15&lt;/version&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure>
</code></pre><p>这里要说下很重要的话，官方文档说的1.2.10以后，会有两个方法支持HttpMessageconvert，一个是FastJsonHttpMessageConverter，支持4.2以下的版本，一个是FastJsonHttpMessageConverter4支持4.2以上的版本，具体有什么区别暂时没有深入研究。这里也就是说：低版本的就不支持了，所以这里最低要求就是1.2.10+。</p>
<h5 id="2-配置fastjson-支持两种方法"><a href="#2-配置fastjson-支持两种方法" class="headerlink" title="2.配置fastjson(支持两种方法)"></a>2.配置fastjson(支持两种方法)</h5><h6 id="2-1-方法一"><a href="#2-1-方法一" class="headerlink" title="2.1 方法一"></a>2.1 方法一</h6><p>1.启动类继承WebMvcConfigurerAdapter<br>2.覆盖方法configureMessageConverters</p>
<p>Person:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">   public class Person &#123;</div><div class="line">private String name;</div><div class="line">private Integer age;</div><div class="line"></div><div class="line">@JSONField(format=&quot;yyyy-MM-dd&quot;)</div><div class="line">private Date createTime;//添加fastjson相关格式化</div><div class="line"></div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setName(String name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Integer getAge() &#123;</div><div class="line">	return age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setAge(Integer age) &#123;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Date getCreateTime() &#123;</div><div class="line">	return createTime;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setCreateTime(Date createTime) &#123;</div><div class="line">	this.createTime = createTime;</div><div class="line">&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><p>APP:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">   /**</div><div class="line">   * 在这里我们使用@SpringBootApplication指定这是一个 spring boot的应用程序.</div><div class="line">   * @author Administrator</div><div class="line">   *</div><div class="line">   */</div><div class="line">   @SpringBootApplication</div><div class="line">   public class App extends WebMvcConfigurerAdapter&#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)&#123;</div><div class="line">	/**</div><div class="line">	 * 1.定义转换消息的对象 convert</div><div class="line">	 * 2.添加fastjson配置信息,例如:是否要格式化返回的json数据</div><div class="line">	 * 3.在convert中添加配置信息</div><div class="line">	 * 4.将convert添加到converters中</div><div class="line">	 */</div><div class="line">	//1.定义转换消息的对象 convert</div><div class="line">	FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();</div><div class="line">	//2.添加fastjson配置信息,例如:是否要格式化返回的json数据</div><div class="line">    FastJsonConfig fastJsonConfig = new FastJsonConfig();</div><div class="line">    fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);</div><div class="line">    //3.在convert中添加配置信息</div><div class="line">    converter.setFastJsonConfig(fastJsonConfig);</div><div class="line">    //4.将convert添加到converters中</div><div class="line">    converters.add(converter);</div><div class="line">&#125;</div><div class="line">   public static void main( String[] args )</div><div class="line">   &#123;</div><div class="line">   	/**</div><div class="line">	 * 在main方法中启动应用程度</div><div class="line">	 */</div><div class="line">   	SpringApplication.run(App.class, args);</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><p>HelloController:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   /**</div><div class="line">   * 在这里我们使用RestController  （等价于于 @Controller 和 @RequestBody）</div><div class="line">   * @author Administrator</div><div class="line">   *</div><div class="line">   */</div><div class="line">   @RestController</div><div class="line">   public class HelloController &#123;</div><div class="line">/**</div><div class="line"> * 在这里我们使用@RequestMapping 建立请求映射:</div><div class="line"> * http://127.0.0.1:8080/hello</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">@RequestMapping(&quot;/hello&quot;)</div><div class="line">   public String hello()&#123;</div><div class="line">   return &quot;hello world&quot;;</div><div class="line">   &#125;</div><div class="line">/**</div><div class="line"> * 打开工程lib下jar知 ：Spring Boot默认使用的json解析框架是jackson</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">@RequestMapping(&quot;/json&quot;)</div><div class="line">public Person getJson()&#123;</div><div class="line">	Person person = new Person();</div><div class="line">	person.setAge(23);</div><div class="line">	person.setName(&quot;zs&quot;);</div><div class="line">	person.setCreateTime(new Date());</div><div class="line">	return person;</div><div class="line">&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><p>第二种方法时在App.java启动类中，<br>注入Bean : HttpMessageConverters此处略</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>run as在浏览器输入：<a href="http://localhost:8080/json.do" target="_blank" rel="external">http://localhost:8080/json.do</a><br>{ “age”:23, “createTime”:”2017-07-15”, “name”:”zs” }</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/15/Spring-Boot-三-Spring-Boot完美使用FastJson解析JSON数据/" class="archive-article-date">
  	<time datetime="2017-07-15T06:45:35.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Spring-Boot-二-返回json数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/14/Spring-Boot-二-返回json数据/">Spring Boot(二)-返回json数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1.编写实体Person<br>2.编写返回json方法getJson()<br>3.测试  </p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-编写实体Person"><a href="#1-编写实体Person" class="headerlink" title="1.编写实体Person"></a>1.编写实体Person</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">   public class Person &#123;</div><div class="line">private String name;</div><div class="line">private Integer age;</div><div class="line"></div><div class="line">public String getName() &#123;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setName(String name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Integer getAge() &#123;</div><div class="line">	return age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setAge(Integer age) &#123;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="2-编写返回json方法getJson"><a href="#2-编写返回json方法getJson" class="headerlink" title="2.编写返回json方法getJson()"></a>2.编写返回json方法getJson()</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">   /**</div><div class="line">   * 在这里我们使用RestController  （等价于于 @Controller 和 @RequestBody）</div><div class="line">   * @author Administrator</div><div class="line">   *</div><div class="line">   */</div><div class="line">   @RestController</div><div class="line">   public class HelloController &#123;</div><div class="line">/**</div><div class="line"> * 在这里我们使用@RequestMapping 建立请求映射:</div><div class="line"> * http://127.0.0.1:8080/hello</div><div class="line"> * @return</div><div class="line"> * 打开工程lib下jar知 ：Spring Boot默认使用的json解析框架是jackson</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">@RequestMapping(&quot;/json&quot;)</div><div class="line">public Person getJson()&#123;</div><div class="line">	Person person = new Person();</div><div class="line">	person.setAge(23);</div><div class="line">	person.setName(&quot;zs&quot;);</div><div class="line">	return person;</div><div class="line">&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h5 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h5><p>在浏览器输入地址:注意不需要输入项目名称<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/7/5.png" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/14/Spring-Boot-二-返回json数据/" class="archive-article-date">
  	<time datetime="2017-07-14T01:12:12.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringBoot-一-SpringBoot之HelloWorld" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/13/SpringBoot-一-SpringBoot之HelloWorld/">SpringBoot(一)-SpringBoot之HelloWorld</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本节主要讲述一下内容<br>1.Spring Boot介绍<br>2.开发准备<br>3.Spring Boot之HelloWorld</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-Spring-Boot介绍"><a href="#1-Spring-Boot介绍" class="headerlink" title="1.Spring Boot介绍"></a>1.Spring Boot介绍</h5><h6 id="1-1-什么是Spring-boot"><a href="#1-1-什么是Spring-boot" class="headerlink" title="1.1 什么是Spring boot"></a>1.1 什么是Spring boot</h6><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>
<h6 id="1-2-Spring-Boot特性"><a href="#1-2-Spring-Boot特性" class="headerlink" title="1.2 Spring Boot特性"></a>1.2 Spring Boot特性</h6><ol>
<li>创建独立的Spring应用程序</li>
<li>嵌入的Tomcat，无需部署WAR文件</li>
<li>简化Maven配置</li>
<li>自动配置Spring</li>
<li>提供生产就绪型功能，如指标，健康检查和外部配置</li>
<li>开箱即用，没有代码生成，也无需XML配置<h6 id="1-3-Spring-Boot特性理解"><a href="#1-3-Spring-Boot特性理解" class="headerlink" title="1.3 Spring Boot特性理解"></a>1.3 Spring Boot特性理解</h6></li>
<li>为基于Spring的开发提供更快的入门体验</li>
<li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求。</li>
<li>提供了一些大型项目中常见的非功能特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。</li>
<li>Spring Boot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式。</li>
</ol>
<h5 id="2-开发准备"><a href="#2-开发准备" class="headerlink" title="2.开发准备"></a>2.开发准备</h5><ol>
<li>开发环境JDK 1.8</li>
<li>开发工具(MyEclipse)</li>
<li>项目管理工具（ Maven ）</li>
</ol>
<h5 id="3-Spring-Boot之HelloWorld"><a href="#3-Spring-Boot之HelloWorld" class="headerlink" title="3.Spring Boot之HelloWorld"></a>3.Spring Boot之HelloWorld</h5><h6 id="3-1-创建maven工程"><a href="#3-1-创建maven工程" class="headerlink" title="3.1 创建maven工程"></a>3.1 创建maven工程</h6><p>创建Maven Project (spring-boot-hello)<br>File-&gt;New-&gt;maven project-&gt;next-&gt;next-&gt;[groupId:com.yxm ArtifactId:spring-boot-hello]</p>
<h6 id="3-2-Hello-World-之pom-xml"><a href="#3-2-Hello-World-之pom-xml" class="headerlink" title="3.2 Hello World 之pom.xml"></a>3.2 Hello World 之pom.xml</h6><p>1.加入parant节点  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   &lt;!-- </div><div class="line">   spring boot 父节点依赖,引入这个之后相关的引入就不需要添加version配置，因为父节点中有很多版本,spring boot会自动选择最合适的版本进行添加。</div><div class="line">    --&gt;</div><div class="line">    &lt;parent&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;1.4.1.RELEASE&lt;/version&gt;</div><div class="line">&lt;/parent&gt;</div></pre></td></tr></table></figure>
</code></pre><p>2.java.version指定jdk版本  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</div></pre></td></tr></table></figure>
</code></pre><p>3.添加spring-boot-starter-web依赖</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  &lt;dependency&gt;</div><div class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">  &lt;/dependency&gt;</div></pre></td></tr></table></figure>
</code></pre><p>整体pom.xml文件：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">   &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">   &lt;groupId&gt;com.yxm&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-hello&lt;/artifactId&gt;</div><div class="line">   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">   &lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">   &lt;name&gt;spring-boot-hello&lt;/name&gt;</div><div class="line">   &lt;url&gt;http://maven.apache.org&lt;/url&gt;</div><div class="line"></div><div class="line">   &lt;properties&gt;</div><div class="line">   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">    &lt;!-- 指定一下jdk的版本 ，这里我们使用jdk 1.8 ,默认是1.6 --&gt;</div><div class="line">   &lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class="line">   &lt;/properties&gt;</div><div class="line"></div><div class="line">   &lt;!-- </div><div class="line">   spring boot 父节点依赖,引入这个之后相关的引入就不需要添加version配置，因为父节点中有很多版本,spring boot会自动选择最合适的--&gt;</div><div class="line">    &lt;parent&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;1.4.1.RELEASE&lt;/version&gt;</div><div class="line">&lt;/parent&gt;</div><div class="line">   &lt;dependencies&gt;</div><div class="line">     &lt;!-- spring-boot-starter-web: MVC,AOP的依赖包--&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">			&lt;!-- </div><div class="line">				&lt;version&gt;&lt;/version&gt;</div><div class="line">				由于我们在上面指定了 parent(spring boot)</div><div class="line">			 --&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">   &lt;/dependencies&gt;</div><div class="line">   &lt;/project&gt;</div></pre></td></tr></table></figure></p>
<h6 id="3-3-Hello-World-之写代码"><a href="#3-3-Hello-World-之写代码" class="headerlink" title="3.3 Hello World 之写代码"></a>3.3 Hello World 之写代码</h6><p>在以上我们添加完依赖之后还会出现错误,我们此时需要更新一下maven工程<br>1.新建Controller类<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/7/1.png" alt=""><br>2.新建启动类(APP-MAIN方法)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/7/2.png" alt=""><br>3.测试代码<br>在main方法中run as  输出以下情况：可以看出其端口号：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/7/3.png" alt=""></p>
<p>在浏览器中输入：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/7/4.png" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/13/SpringBoot-一-SpringBoot之HelloWorld/" class="archive-article-date">
  	<time datetime="2017-07-13T14:27:49.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Myeclipse下部署maven工程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/26/Myeclipse下部署maven工程/">Myeclipse下部署maven工程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在在线客服开源项目中我们需要把开源的项目部署到本地的myeclipse的maven工程下,此时需要本地搭建maven工程,并将项目部署到ROOT目录下  </p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-本地maven搭建"><a href="#1-本地maven搭建" class="headerlink" title="1.本地maven搭建"></a>1.本地maven搭建</h5><h6 id="1-1Maven安装"><a href="#1-1Maven安装" class="headerlink" title="1.1Maven安装"></a>1.1Maven安装</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/1.png" alt=""></p>
<h6 id="1-2Maven基础配置"><a href="#1-2Maven基础配置" class="headerlink" title="1.2Maven基础配置"></a>1.2Maven基础配置</h6><p>配置中央仓库(远程仓库)的镜像，作用是为了稳定、快速的访问中央仓库（可以使用阿里云提供的Maven仓库）。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;settings&gt; …… &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt;</div><div class="line">&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; …… &lt;/profile&gt; &lt;/profiles&gt; …… &lt;settings&gt;</div></pre></td></tr></table></figure></p>
<h6 id="1-3测试maven"><a href="#1-3测试maven" class="headerlink" title="1.3测试maven"></a>1.3测试maven</h6><p>输入mvn -v</p>
<h5 id="2-myeclipse2014-导入工程"><a href="#2-myeclipse2014-导入工程" class="headerlink" title="2.myeclipse2014 导入工程"></a>2.myeclipse2014 导入工程</h5><h6 id="2-1-myeclipse2014安装"><a href="#2-1-myeclipse2014安装" class="headerlink" title="2.1 myeclipse2014安装"></a>2.1 myeclipse2014安装</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/2.png" alt=""></p>
<h6 id="2-1-myeclipse2014中maven配置"><a href="#2-1-myeclipse2014中maven配置" class="headerlink" title="2.1 myeclipse2014中maven配置"></a>2.1 myeclipse2014中maven配置</h6><p>1.设置maven目录<br>a)window-&gt;preferences-&gt;myeclipse-&gt;maven4myeclipse-&gt;Installations-&gt;Add<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/3.png" alt=""><br>b)找到本地Maven工作目录:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/4.png" alt=""><br>c)勾选刚添加maven，点击ok按钮<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/5.png" alt=""><br>2.设置User setting<br>a)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/6.png" alt=""><br>b)点击Browse<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/7.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/8.png" alt=""><br>c)点击ok<br>如果将来 setting文件有修改，需要点击“更新setting ”。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/9.png" alt=""><br>3.在 eclipse/Myeclipse中配置M2_HOME<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/10.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/11.png" alt=""></p>
<h5 id="3-部署到ROOT目录下"><a href="#3-部署到ROOT目录下" class="headerlink" title="3.部署到ROOT目录下"></a>3.部署到ROOT目录下</h5><p>错误提示：不可修改<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/12.png" alt=""><br>解决方案：修改如下配置文件<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/1/13.png" alt=""><br>更改项目下的.setting文件内容,部署到tomcat中访问即可</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/06/26/Myeclipse下部署maven工程/" class="archive-article-date">
  	<time datetime="2017-06-25T16:24:39.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-06-26</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Maven/">Maven</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JVM-五-GC参数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/19/JVM-五-GC参数/">JVM(五)-GC参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本节主要讲解以下部分：<br>1.堆回顾<br>2.JVM中三种垃圾回收机制:串行收集器,并行收集器,CMS收集器<br>3.Tomcat实际演示  </p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h4 id="1-堆回顾"><a href="#1-堆回顾" class="headerlink" title="1.堆回顾"></a>1.堆回顾</h4><p>1.在前面章节可以知道,堆主要分为2类：新生代(eden)，老年代。绝大多数对象一分配就在新生代中,当然也有一些例外：比如栈上分配(对象是分配到栈上)，大对象有时候是分配到老年代中<br>2.对象在新生代收集之后,如果对象能够幸存,则对象会放到幸存带,即survive区,如图的s0,s1区，也可以叫做from,to<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/41.png" alt=""><br>3.当对象在内存中经历无数次垃圾收集之后,对象年龄到达一定之后会变成老年代  </p>
<h4 id="2-JVM中三种垃圾回收机制"><a href="#2-JVM中三种垃圾回收机制" class="headerlink" title="2.JVM中三种垃圾回收机制"></a>2.JVM中三种垃圾回收机制</h4><h5 id="2-1串行收集器"><a href="#2-1串行收集器" class="headerlink" title="2.1串行收集器"></a>2.1串行收集器</h5><p>1.最古老，最稳定（年代久远,但是历经考验最稳定）<br>2.效率高<br>3.最大缺点:可能会产生较长停顿（因为串行使用一个线程，是用一个串行队列）,所以在多和下是不具有优势的<br>4.-XX:+UseSerialGC<br>新生代,老年代使用串行回收<br>新生代复制算法<br>老年代标记-压缩法<br>5.如图：<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/42.png" alt=""><br>应用程序线程之中,应用程序线程可能是有很多个的,一旦回收开始，应用程序全部暂停,串行回收器中GC线程只有把1个,当GC完成之后,应用程序开始恢复运行</p>
<h5 id="2-2并行收集器"><a href="#2-2并行收集器" class="headerlink" title="2.2并行收集器"></a>2.2并行收集器</h5><h6 id="2-2-1-ParNew"><a href="#2-2-1-ParNew" class="headerlink" title="2.2.1 ParNew"></a>2.2.1 ParNew</h6><p>1.ParNew是一种并行收集器：par-parallel  New-指代新生代<br>从以上可以知道这是一个新生代的并行收集器,老年代串行回收<br>2.-XX:+UseParNewGC<br>新生代并行<br>老年代串行<br>Serial收集器新生代的并行版本<br>复制算法<br>多线程，需要多核支持<br>-XX:ParallelGCThreads 限制线程数量<br>3.如图：<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/43.png" alt=""><br>他是多个线程负责回收。</p>
<h6 id="2-2-2-Parallel收集器"><a href="#2-2-2-Parallel收集器" class="headerlink" title="2.2.2 Parallel收集器"></a>2.2.2 Parallel收集器</h6><h5 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h5>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/06/19/JVM-五-GC参数/" class="archive-article-date">
  	<time datetime="2017-06-19T15:25:49.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-06-19</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JVM-四-GC算法与种类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/12/JVM-四-GC算法与种类/">JVM(四)-GC算法与种类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本节主要分为以下章节:  </p>
<h6 id="1-GC概念"><a href="#1-GC概念" class="headerlink" title="1.GC概念"></a>1.GC概念</h6><h6 id="2-GC算法"><a href="#2-GC算法" class="headerlink" title="2.GC算法"></a>2.GC算法</h6><p>1.引用计数法<br>2.标记清除<br>3.标记压缩<br>4.复制算法  </p>
<h6 id="3-可触及性"><a href="#3-可触及性" class="headerlink" title="3.可触及性"></a>3.可触及性</h6><h6 id="4-Stop-The-World"><a href="#4-Stop-The-World" class="headerlink" title="4.Stop-The-World"></a>4.Stop-The-World</h6><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-GC概念-1"><a href="#1-GC概念-1" class="headerlink" title="1.GC概念"></a>1.GC概念</h5><p>1.GC即Garbage Collection 垃圾收集,这里的垃圾就是系统运行过程中无用的对象,这里的对象是占据一定的内存空间的,如果不被释放掉,长期占据空间的话就会导致内存使用完,即我们所说的内存溢出。因此这些无用的对象必须在一定时间范围内清除掉,从而保证内存可用,在C，C++中由程序员主动的申请和释放资源。没有所谓的垃圾回收,而在java中,由一个专门用于垃圾回收的线程不停在后台扫描,自动将无用的内存进行释放。<br>2.GC的概念不是java本身提出来的,在1960年 List使用了GC<br>3.Java中,GC的对象是堆空间和永久区,所以堆空间和永久区有GC管理</p>
<h6 id="2-GC算法-1"><a href="#2-GC算法-1" class="headerlink" title="2.GC算法"></a>2.GC算法</h6><p>如何回收无用的在堆空间和永久区中的对象,其实是由一套算法来决定  </p>
<h6 id="2-1引用计数法"><a href="#2-1引用计数法" class="headerlink" title="2.1引用计数法"></a>2.1引用计数法</h6><p>1.在老牌垃圾回收算法中使用引用计数法,引用计数法通过引用计数标记一个对象是不是垃圾,是不是应该回收,是很古老的算法,从COM,ActionScript3，python语言中还在用<br>2.引用计数思想:为每个对象都标记一个使用数量,只要有一个人使用对象,就会在引用数量上加1,二个人使用,则会在此引用数量标记为2,三个人使用,就会标记引用数量为3,一旦有人释放这个引用数量,就会在此引用数量上减1,当一个对象的引用数量为0也就是没有人使用它了,则这个对象就可以进行对量空间的释放<br>3.引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。<br>4.引用计数法示例如下图:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/35.png" alt=""><br>(一):根对象会有若干个引用,引用的对象将会也有其他引用,能够引用到的对象就认为是可达的有效对象<br>(二):当一个引用一旦消失之后,这个对象就变成不可达对象,变成不可达对象的引用将会变为0,二此时根节点的引用将会将去1.<br>(三):说明可达对象变成不可达对象之后,将会被回收</p>
<p>引用计数法的问题:<br>1.引用和去引用伴随加法和减法,影响性能<br>2.很难处理循环引用问题<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/36.png" alt=""><br>注:不可达的对象是垃圾对象,应该被回收:<br>(一)：标记为2的对象有2个对象对其进行了引用,因此此引用标记数为2<br>(二):一旦根对象对其引用消失了,这个时候,变成红色,中间对象引用减去1<br>(三)：中间对象引用为1，其是一个不应该被清除的对象,则对于跟对象而言右边三个对象都是不可达的对象,但是引用标记又不为1,则不能被回收,造成不可达的对象是垃圾对象,不能被回收。</p>
<h6 id="2-2-标记清除"><a href="#2-2-标记清除" class="headerlink" title="2.2.标记清除"></a>2.2.标记清除</h6><p>1.标记清除发分为标志阶段,清除阶段<br>2.标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象(不可达对象)。然后，在清除阶段，清除所有未被标记的对象。<br>3.原理如下图:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/37.png" alt=""><br>标记阶段:首先从根节点摸索下去的浅灰色标记为可达对象,这些对象不应该被回收.<br>清除阶段:将未被标记的对象(不可达的垃圾对象)清除掉  </p>
<h6 id="2-3-标记压缩"><a href="#2-3-标记压缩" class="headerlink" title="2.3.标记压缩"></a>2.3.标记压缩</h6><p>1.对标记清除做了优化,和标记清除算法基本是一致的,<br>标记阶段：首先也是从根节点开始对可达对象进行标记<br>清除阶段:不是简单清除未被标记的对象,而是将所有”存活对象”复制到内存的一端.然后清理边界外所有的空间.<br>2.原理图如下：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/38.png" alt=""><br>浅灰色:存活对象, 深灰色:垃圾对象 白色:空闲空间  箭头指向:表示移动<br>标记压缩算法首先是标记出了对象是否存活,标记处对象存活之后,他开始移动存活对象,而不是清除未被标记对象,根据箭头所示复制,然后清除边界<br>3.思考：<br>标记压缩发对标记清除发而言,有什么优势呢？<br>应该是效率高</p>
<h6 id="2-4-复制算法"><a href="#2-4-复制算法" class="headerlink" title="2.4.复制算法"></a>2.4.复制算法</h6><p>1.与标记-清除算法而言,复制算法是一种相对高效的回收方法<br>2.不适合存活对象较多的场合 如:老年代<br>3.原理：将原有的内存空间分配为两块,每次只是用其中一块,在垃圾回收时候,将正在使用的内存中的存活对象复制到未使用的内存块中,之后,清除正在使用的内存块中(也就是原来内存块)的所有对象,交换两个内存的角色,完成垃圾回收.<br>4.原理图如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/39.png" alt=""><br>分配的两块空间完全一样,内存大小是一样的。但是每一次只使用其中一块,如果是1G的内存,那么使用中只能使用512M空间，根据箭头所示方向,存活对象被复制到了另一块空间,然后之前空间不管存活与否全部处理。原本使用的对象被清空,第二块中只包含存活对象,以此类推当第二块快使用完后，又复制到第一块中<br>5.缺陷:空间浪费,只能使用一半的空间<br>整合标记清理思想,尽量提高空间利用率,因此对复制算法进行扩展,原理图如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/40.png" alt=""><br>有四块空间:对象产生空间1,复制算法核心2(复制空间),3(空闲空间)， 老年代空间(担保空间4)<br>系统使用中总是有一块空白空间3是不用的,2空间是有用的,垃圾回收进行时候,大对象直接进入担保空间(老年代空间)大对象比较大【原因一：2(复制空间)空间不一定能存下,复制空间不一定很大,有可能很小,因为复制空间越大,浪费空间越多 原因二：大对象放到复制空间,则小对象没有对方去,则小对象可能排挤到老年代中不太合理】,老年对象进入老年代空间<br>一个对象几次回收之后都没有被回收,每次回收年龄都加一:则对象会达到老年对象（多次未被回收对象,被长期引用对象）,剩余对象将会被复制到空白空间。复制完之后清除原来的空间1,2,3.<br>6.从GC打印日志可以看到，新生代分为3个区：以上1区就是eden区也就是对象产生地方，from to 就是2,3区,<br>7.根据地址界的上下界算出新生代大小是15M但是可以知道,新生代总的大小是13824k，其实就是我们浪费了to中的空间,复制算法就是会浪费一般空间</p>
<h6 id="2-5分代思想"><a href="#2-5分代思想" class="headerlink" title="2.5分代思想"></a>2.5分代思想</h6><p>1.依据对象存活周期进行分类,短命对象归为新生代,长命对象归为老年代<br>2.根据不同特点,选择合适的收集方法<br>少量对象存活（新生代），适合复制算法，存活对象比较多的话进行大量复制效率差，如果少《一下子完成<br>大量对象存活,适合标记清除或者标记压缩  </p>
<h6 id="2-6-GC算法总结整理"><a href="#2-6-GC算法总结整理" class="headerlink" title="2.6 GC算法总结整理"></a>2.6 GC算法总结整理</h6><p>1.引用计数：没有被Java采用<br>2标记-清除，标记-压缩比较适合老年代<br>3.复制算法：新生代</p>
<h6 id="3-可触及性-1"><a href="#3-可触及性-1" class="headerlink" title="3.可触及性"></a>3.可触及性</h6><p>以上所有算法都是基于垃圾对象,垃圾对象被回收,为了解释垃圾对象,我们需要知道可触及性<br>1.可触及的：从根节点可以触及到这个对象，从根节点触发的引用量中有这个对象<br>2.可复活的：一旦所有引用被释放，就是可复活状态，因为在finalize()中可能复活该对象,现阶段不可触及,下阶段有肯能被触及<br>3.不可触及的：在finalize()后，可能会进入不可触及状态，不可触及的对象不可能复活，可以回收<br>4.经验：避免使用finalize()，操作不慎可能导致错误。<br>5.优先级低，何时被调用， 不确定，何时发生GC不确定<br>6.可以使用try-catch-finally来替代它  </p>
<h6 id="3-1-根"><a href="#3-1-根" class="headerlink" title="3.1 根"></a>3.1 根</h6><p>我们一直在讨论根节点出发,到底什么是根呢？<br>1.栈中引用对象可以认为是根对象,线程栈中的局部变量<br>2.方法区中:静态成员或者常量对象<br>3.JNI方法栈中引用对象</p>
<h6 id="4-Stop-The-World-1"><a href="#4-Stop-The-World-1" class="headerlink" title="4.Stop-The-World"></a>4.Stop-The-World</h6><h6 id="4-1-停止大世界-会影响java中所有线程"><a href="#4-1-停止大世界-会影响java中所有线程" class="headerlink" title="4.1 停止大世界,会影响java中所有线程"></a>4.1 停止大世界,会影响java中所有线程</h6><p>1.Java中一种全局暂停的现象<br>2.全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互<br>3.多半由于GC引起：Dump线程，死锁检查，堆Dump  </p>
<h6 id="4-2GC时为什么会有全局停顿？"><a href="#4-2GC时为什么会有全局停顿？" class="headerlink" title="4.2GC时为什么会有全局停顿？"></a>4.2GC时为什么会有全局停顿？</h6><p>1.类比在聚会时打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。<br>2.危害：1.长时间服务停止，没有响应，2.遇到HA系统，可能引起主备切换，严重危害生产环境。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/06/12/JVM-四-GC算法与种类/" class="archive-article-date">
  	<time datetime="2017-06-12T15:06:38.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-06-12</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JVM-三-常见JVM参数配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/JVM-三-常见JVM参数配置/">JVM(三)-常见JVM参数配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>1.一个优秀的Java程序员必须了解GC的工作原理、如何优化GC的性能、如何与GC进行有限的交互，因为有一些应用程序对性能要求较高，例如嵌入式系统、实时系统等，只有全面提升内存的管理效率 ，才能提高整个应用程序的性能。本篇文章首先简单介绍GC的工作原理之后，然后再对GC的几个关键问题进行深入探讨，最后提出一些Java程序设计建议，从GC角度提高Java程序的性能<br>2.gc基本原理</p>
<ol>
<li>Java的内存管理实际上就是对象的管理，其中包括对象的分配和释放。</li>
<li>对于程序员来说，分配对象使用new关键字；释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为\”不可达的\”.GC将负责回收所有\”不可达\”对象的内存空间<br>本文主要内容:  </li>
</ol>
<h5 id="1-Trace跟踪参数"><a href="#1-Trace跟踪参数" class="headerlink" title="1.Trace跟踪参数"></a>1.Trace跟踪参数</h5><h5 id="2-堆的分配参数"><a href="#2-堆的分配参数" class="headerlink" title="2.堆的分配参数"></a>2.堆的分配参数</h5><h5 id="3-栈的分配参数"><a href="#3-栈的分配参数" class="headerlink" title="3.栈的分配参数"></a>3.栈的分配参数</h5><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>既然如此，那么在IDE的控制台打印GC日志是必不可少的了。现在就告诉你怎么打印。<br>如果是用的Eclipse或者Myeclipse,打印GC日志的操作如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/26.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/24.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/25.png" alt=""></p>
<h5 id="1-Trace跟踪参数-1"><a href="#1-Trace跟踪参数-1" class="headerlink" title="1.Trace跟踪参数"></a>1.Trace跟踪参数</h5><h6 id="verbose-gc"><a href="#verbose-gc" class="headerlink" title="-verbose:gc"></a>-verbose:gc</h6><h6 id="XX-printGC"><a href="#XX-printGC" class="headerlink" title="-XX:printGC"></a>-XX:printGC</h6><p>可以打印出GC的简要信息:<br>[GC 4790K-&gt;374K(15872K), 0.0001606 secs]<br>[GC 4790K-&gt;374K(15872K), 0.0001474 secs]<br>[GC 4790K-&gt;374K(15872K), 0.0001563 secs]<br>[GC 4790K-&gt;374K(15872K), 0.0001682 secs]<br>上方日志的意思是说，GC之前，用了4M左右的内存，GC之后，用了374K内存，一共回收了将近4M。内存大小一共是16M左右。</p>
<h6 id="XX-PrintGCDetalis"><a href="#XX-PrintGCDetalis" class="headerlink" title="-XX:PrintGCDetalis"></a>-XX:PrintGCDetalis</h6><p>打印出详细信息<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/27.png" alt=""><br>例如下面这段日志：<br>[GC[DefNew: 4416K-&gt;0K(4928K), 0.0001897 secs] 4790K-&gt;374K(15872K), 0.0002232 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>上方日志的意思是说：这是一个新生代的GC。方括号内部的“4416K-&gt;0K(4928K)”含义是：“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“4790K-&gt;374K(15872K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。<br>再往后看，“0.0001897 secs”表示该内存区域GC所占用的时间，单位是秒。<br>上图中，我们先看一下用红框标注的“[0x27e80000, 0x28d80000, 0x28d80000)”的含义，它表示新生代在内存当中的位置：第一个参数是申请到的起始位置，第二个参数是申请到的终点位置，第三个参数表示最多能申请到的位置。上图中的例子表示新生代申请到了15M的控件，而这个15M是等于：（eden space的12288K）+（from space的1536K）+（to space的1536K）。<br>def new generation–新生代gc<br>eden space–对象出生的地方<br>tenured generation–老年代<br>低边界–指代起始位置<br>最高边界–指代最高能够申请的位置  </p>
<h6 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="-XX:PrintGCTimeStamps"></a>-XX:PrintGCTimeStamps</h6><p>打印GC发生的时间戳</p>
<h6 id="重定向GC的log"><a href="#重定向GC的log" class="headerlink" title="重定向GC的log"></a>重定向GC的log</h6><ol>
<li>一般gc日志的输出都是在控制台的,在控制台的一般是无法保留的,不便于出现日志后分析,所以一般我们通过-Xloggc来 把gc位置存到本地磁盘上 </li>
<li>-Xloggc:D:log/gc.log:指定GC log的位置,以文件输出，帮助开发人员分析问题<br>我们现在D:log/gc.log建立文件,然后在debug as中配置VM参数,运行就会输出gc日志到gc.log下面<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/28.png" alt=""><h6 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h6>追踪类的加载:<br>[Loaded java.lang.Object from shared objects file]<br>[Loaded java.io.Serializable from shared objects file]<br>[Loaded java.lang.Comparable from shared objects file]<br>[Loaded java.lang.CharSequence from shared objects file]<br>[Loaded java.lang.String from shared objects file]<br>[Loaded java.lang.reflect.GenericDeclaration from shared objects file]<br>[Loaded java.lang.reflect.Type from shared objects file]<br>每一行都代表了一个被加载的类：<br>首先加载Object类<h6 id="XX-TraceClassLoading-1"><a href="#XX-TraceClassLoading-1" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h6>打印类的信息<br>按下Ctrl+Break后,打印类的信息:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/29.png" alt=""><br>class name:B-指Byte C-指代char<br>#####2.堆的分配参数<br>######2.1.-Xmx –Xms：指定最大堆和最小堆<br>最大堆:java 虚拟机最多能够使用多少堆空间<br>最小堆:java虚拟机至少使用多少堆空间<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/30.png30" alt=""><br>-Xmx20m -Xms5m  运行代码<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/31.png" alt=""></li>
<li>分配1M给数组<br>这时候最大空间不变,可用空间会减去1M，因为那1M已经分配了,总空间是还是5M,没有进行扩容，java语言中尽可能的维持在最小堆运行<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/32.png" alt=""></li>
<li>分配4M给数组<br>当程序进行GC后没有办法将内存空间维持在最小堆,则会去扩容<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/33.png" alt=""><br>最大内存是10M说明已经扩容了。</li>
<li>代码块之前做一次gc<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/34.png" alt=""><h6 id="2-2-思考"><a href="#2-2-思考" class="headerlink" title="2.2 思考"></a>2.2 思考</h6></li>
<li>-Xmx 和 –Xms 应该保持一个什么关系，可以让系统的性能尽可能的好呢？</li>
<li>如果你要做一个Java的桌面产品，需要绑定JRE，但是JRE又很大，你如何做一下JRE的瘦身呢？<h6 id="2-3-堆其他参数"><a href="#2-3-堆其他参数" class="headerlink" title="2.3.堆其他参数"></a>2.3.堆其他参数</h6></li>
<li>-Xmn:设置新生代大小</li>
<li>-XX:NewRatio:新生代（eden+2*s）和老年代（不包含永久区）的比值,4 表示 新生代:老年代=1:4，即年轻代占堆的1/5</li>
<li>XX:SurvivorRatio:设置两个Survivor区和eden的比,<br>8表示 两个Survivor :eden=2:8，即一个Survivor占年轻代的1/10</li>
<li>实例<h5 id="3-栈的分配参数-1"><a href="#3-栈的分配参数-1" class="headerlink" title="3.栈的分配参数"></a>3.栈的分配参数</h5></li>
<li><p>-XX:+HeapDumpOnOutOfMemoryError：OOM时导出堆到文件</p>
</li>
<li><p>-XX:+HeapDumpPath：导出OOM的路径</p>
</li>
<li><p>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump<br>做堆的转存:在系统宕机内存溢出,我们很难排查出问题,这个时候我们可以做一个转存:-XX:+HeapDumpOnOutOfMemoryError<br>转存的位置为:-XX:+HeapDumpPath<br>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump<br>把内存溢出日志打印到d盘的a.dump文件上</p>
</li>
<li>XX:OnOutOfMemoryError<br>在OOM时，执行一个脚本<br>“-XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstack.bat %p“<br>当程序OOM时，在D:/a.txt中将会生成线程的dump<br>可以在OOM时，发送邮件，甚至是重启程序</li>
<li>根据实际事情调整新生代和幸存代的大小:<br>官方推荐新生代占堆的3/8<br>幸存代占新生代的1/10<br>在OOM时，记得Dump出堆，确保可以排查现场问题<h5 id="4-永久区分配参数"><a href="#4-永久区分配参数" class="headerlink" title="4.永久区分配参数"></a>4.永久区分配参数</h5>-XX:PermSize  -XX:MaxPermSize<br>设置永久区的初始空间和最大空间<br>他们表示，一个系统可以容纳多少个类型  <h5 id="3-栈大小分配"><a href="#3-栈大小分配" class="headerlink" title="3.栈大小分配"></a>3.栈大小分配</h5>-Xss<br>1.栈指的就是线程私有的一块区域,这个区域是每个线程都必须有的,栈里面的主要内容就是栈帧,栈帧里面就是有局部变量表,操作数栈,引用。一般我们分配栈的时候是几百k,栈越大,说明线程数越少,所以我们应该为了线程数越多,我们需要把栈空间分配的比较小,但是栈大小又决定了函数调用的深度,栈越小,可能会出现栈溢出<br>2.通常只有几百K<br>3.决定了函数调用的深度<br>4.每个线程都有独立的栈空间<br>局部变量、参数 分配在栈上  </li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/06/11/JVM-三-常见JVM参数配置/" class="archive-article-date">
  	<time datetime="2017-06-11T06:50:07.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-06-11</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JVM-二-JVM运行机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/10/JVM-二-JVM运行机制/">JVM(二)-JVM运行机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本篇主要介绍以下内容：</p>
<h5 id="1-JVM启动流程"><a href="#1-JVM启动流程" class="headerlink" title="1.JVM启动流程"></a>1.JVM启动流程</h5><h5 id="2-JVM基本结构"><a href="#2-JVM基本结构" class="headerlink" title="2.JVM基本结构"></a>2.JVM基本结构</h5><h5 id="3-内存模型"><a href="#3-内存模型" class="headerlink" title="3.内存模型"></a>3.内存模型</h5><h5 id="4-编译和解释运行的概念"><a href="#4-编译和解释运行的概念" class="headerlink" title="4.编译和解释运行的概念"></a>4.编译和解释运行的概念</h5><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/04.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/21.png" alt=""></p>
<h5 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h5><h6 id="1-图"><a href="#1-图" class="headerlink" title="1.图"></a>1.图</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/22.png" alt=""><br>例子：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/01.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/02.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/03.png" alt=""></p>
<h6 id="2-PC寄存器"><a href="#2-PC寄存器" class="headerlink" title="2.PC寄存器"></a>2.PC寄存器</h6><p>1.每个线程拥有一个PC寄存器<br>2.在线程创建时 创建<br>3.指向下一条指令的地址<br>4.执行本地方法时，PC的值为undefined  </p>
<h6 id="3-方法区"><a href="#3-方法区" class="headerlink" title="3.方法区"></a>3.方法区</h6><p>1.保存装载的类信息<br>2.类型的常量池<br>3.字段，方法信息<br>4.方法字节码<br>5.通常和永久区(Perm)关联在一起  </p>
<h6 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4.Java堆"></a>4.Java堆</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/23.png" alt=""></p>
<h6 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h6><h5 id="1-C-栈上分配"><a href="#1-C-栈上分配" class="headerlink" title="1.C++栈上分配"></a>1.C++栈上分配</h5><p>public void method(){<br>   BcmBasicString str;<br>   …<br>}<br>直接声明引用,在栈内存中,不需要直接在堆中创建对象,所以永远不可能出现内存泄露  </p>
<h5 id="2-Java栈上分配"><a href="#2-Java栈上分配" class="headerlink" title="2.Java栈上分配"></a>2.Java栈上分配</h5><p>我们可以吧C++栈上分配思想借鉴到java栈中</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class OnStackTest &#123;</div><div class="line">public static void alloc()&#123;</div><div class="line">    byte[] b=new byte[2];</div><div class="line">    b[0]=1;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    long b=System.currentTimeMillis();</div><div class="line">    for(int i=0;i&lt;100000000;i++)&#123;</div><div class="line">        alloc();</div><div class="line">    &#125;</div><div class="line">    long e=System.currentTimeMillis();</div><div class="line">    System.out.println(e-b);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h6 id="2-结果"><a href="#2-结果" class="headerlink" title="2.结果"></a>2.结果</h6><p>设置1：<br>-server -Xmx10m -Xms10m<br>-XX:+DoEscapeAnalysis -XX:+PrintGC<br>输出:5<br>设置2：<br>-server -Xmx10m -Xms10m<br>-XX:-DoEscapeAnalysis -XX:+PrintGC<br>输出：<br>……<br>[GC 3550K-&gt;478K(10240K), 0.0000977 secs]<br>[GC 3550K-&gt;478K(10240K), 0.0001361 secs]<br>[GC 3550K-&gt;478K(10240K), 0.0000963 secs]<br>564<br>第二种说明是在堆上分配的,由于内存的不足,所以有大量的GC日志输出,第一种是在栈上分配的  </p>
<h6 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h6><p>1.栈上分配适合小对象(一般几十个bytes)因为栈的空间本来就没有堆那么大，栈一般在几百k到1M就封顶了,在没有逃逸(在Java中每一个对象都有一定的作用域，理论上，一个对象在一块代码中构造，那么也应该在这块代码中被回收，但是实际上，我们经常会让一个对象存活更长的时间，超过定义它的代码块，这就好比一个人逃出了生他养他的地方，我们将这种现象称为逃逸)情况下，可以直接分配在栈上。具有逃逸的情况是可以共享的,但是栈是私有的,一个对象一个栈<br>2.栈上分配好处,在函数调用结束之后,系统会自动把栈移掉,函数调用之后,栈帧移除,栈上所有内容将消除,所有可以自动移除,减轻GC压力<br>3.大对象或者是逃逸对象 无法在栈上分配</p>
<h5 id="栈-堆-方法区交互"><a href="#栈-堆-方法区交互" class="headerlink" title="栈,堆,方法区交互"></a>栈,堆,方法区交互</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/15.png" alt=""><br>Sample类信息:包括类的描述等<br>三者关系是:由栈指向堆,堆指向方法区(因为方法执行时候需要用到对象,对象的描述信息又在方法区中)</p>
<h5 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h5><p>1.每一个线程有一个工作内存和主存独立<br>2.工作内存存放主存中变量的值得拷贝<br>每一个线程有一个工作内存和主存独立,主存是大家共享的内存区间,可以理解成堆空间,所以得线程都共享,这里面可以存储数据,但是为了考虑效率的问题每一个线程都有自己的工作区间,也就是工作内存,工作内存和主存之间需要有一个同步关系,所有的变量在主存中有一份,在工作内存中有一份变量的拷贝。工作内存和主存的同步主要是通过assign,user,read,load,store,write<br>3.<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/16.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/17.png" alt=""><br>4.线程,本地内存,主内存关系<br>线程总是在本地内存中存储变量,本地内存是“共享变量”的副本,而“共享变量是”是在主内存的<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/18.png" alt=""></p>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>1.之前说到,线程中修改一个变量之后，想让另外一个线程立即可见需要用到volatile标示符<br>以下代码是一个线程监听stop，而另一个线程修改stop，修改之后推出while执行下面,如果不用volatile关键字,线程是永远不会停止的，原因： 我们的线程t只在本地存储间去查看值,没有做到及时更新</p>
<p>2.volatile一般比重量级的锁性能要好,但是不能代替锁,因为其不是线程安全的,如果有多个线程对共享数据进行修改时,其实是线程不安全的<br>3.选择使用volatile的条件是：语义是否满足应用</p>
<h5 id="内存相关的一些概念"><a href="#内存相关的一些概念" class="headerlink" title="内存相关的一些概念"></a>内存相关的一些概念</h5><h6 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h6><ol>
<li>一个线程修改了一个变量,其他线程能够立即世道(注意：不是能够知道)</li>
<li>保证可见性方法<br>1.volatile关键字<br>2.synchronized(unlock之前,写变量值回主存)<br>3.final(一旦初始化完成,其他线程就可见)  <h6 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2.有序性"></a>2.有序性</h6>1.在一个线程之中,所有的指令和操作都是有序执行的<br>2.在线程之外(多线程的条件下,在另外一个线程去观察这个线程的行为)有可能就是无序的（无序的原因：指令重排,主内存同步延时）</li>
</ol>
<h6 id="3-指令重排"><a href="#3-指令重排" class="headerlink" title="3.指令重排"></a>3.指令重排</h6><p>1.编译系统尽可能的让系统性能更加好,为了让其更加好,可能让指令顺序做一些调整<br>2.比如:a=1;b=2，是可重排的,因为不管谁先运行,结果不受影响,但是对于a=1,a=2是不可以，存在结果的不同<br>3.指令重排条件:条件是指令谁先执行对结果都不会有影响<br>4.指令重排弊端-破坏线程间的有序性<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/19.png" alt=""><br>编译器对线程A中很多可能flag=true比a=1先执行,因为无冲突,以上可以知道,假如A.B线程执行读写方法时候,如果:a=1;flag=true;会出现不一样线程调用结果<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/06/20.png" alt=""><br>6.指令重拍原则:<br>程序顺序原则：一个线程内保证语义的串行性<br>volatile规则：volatile变量的写，先发生于读<br>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前<br>传递性：A先于B，B先于C 那么A必然先于C<br>线程的start方法先于它的每一个动作<br>线程的所有操作先于线程的终结（Thread.join()）<br>线程的中断（interrupt()）先于被中断线程的代码<br>对象的构造函数执行结束先于finalize()方法  </p>
<h4 id="编译和解释执行概念"><a href="#编译和解释执行概念" class="headerlink" title="编译和解释执行概念"></a>编译和解释执行概念</h4><p>1.解释执行<br>解释执行以解释方式运行字节码<br>解释执行的意思是：读一句执行一句<br>2.编译运行（JIT）<br>将字节码编译成机器码<br>直接执行机器码<br>运行时编译<br>编译后性能有数量级的提升  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/06/10/JVM-二-JVM运行机制/" class="archive-article-date">
  	<time datetime="2017-06-10T14:27:03.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-06-10</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/CTI/" style="font-size: 11.82px;">CTI</a> <a href="/tags/Cookie/" style="font-size: 10.91px;">Cookie</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IE问题/" style="font-size: 10px;">IE问题</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 13.64px;">JVM</a> <a href="/tags/JavaSE/" style="font-size: 16.36px;">JavaSE</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Myeclipse/" style="font-size: 15.45px;">Myeclipse</a> <a href="/tags/Netty/" style="font-size: 15.45px;">Netty</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 18.18px;">Oracle</a> <a href="/tags/Servlet/" style="font-size: 12.73px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 10.91px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 12.73px;">Spring Boot</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 11.82px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Weblogic/" style="font-size: 13.64px;">Weblogic</a> <a href="/tags/Websocket/" style="font-size: 10.91px;">Websocket</a> <a href="/tags/easyui/" style="font-size: 10px;">easyui</a> <a href="/tags/hibernate/" style="font-size: 10.91px;">hibernate</a> <a href="/tags/im/" style="font-size: 15.45px;">im</a> <a href="/tags/jQuery/" style="font-size: 12.73px;">jQuery</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/java-String/" style="font-size: 10px;">java String</a> <a href="/tags/javaSE/" style="font-size: 10px;">javaSE</a> <a href="/tags/javaWeb/" style="font-size: 10px;">javaWeb</a> <a href="/tags/javascript/" style="font-size: 10.91px;">javascript</a> <a href="/tags/java并发编程/" style="font-size: 12.73px;">java并发编程</a> <a href="/tags/java集合/" style="font-size: 10.91px;">java集合</a> <a href="/tags/junit测试/" style="font-size: 10px;">junit测试</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/log4j/" style="font-size: 12.73px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/sockJs/" style="font-size: 10px;">sockJs</a> <a href="/tags/socket网络编程/" style="font-size: 10.91px;">socket网络编程</a> <a href="/tags/struts1/" style="font-size: 11.82px;">struts1</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weblogic/" style="font-size: 11.82px;">weblogic</a> <a href="/tags/websocket/" style="font-size: 11.82px;">websocket</a> <a href="/tags/代理/" style="font-size: 12.73px;">代理</a> <a href="/tags/前端/" style="font-size: 10.91px;">前端</a> <a href="/tags/动手写一个MVC/" style="font-size: 13.64px;">动手写一个MVC</a> <a href="/tags/反射/" style="font-size: 17.27px;">反射</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/微博/" style="font-size: 10px;">微博</a> <a href="/tags/文件读取/" style="font-size: 10px;">文件读取</a> <a href="/tags/泛型/" style="font-size: 14.55px;">泛型</a> <a href="/tags/注解/" style="font-size: 11.82px;">注解</a> <a href="/tags/类加载器/" style="font-size: 14.55px;">类加载器</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/自己写一个apache服务器/" style="font-size: 19.09px;">自己写一个apache服务器</a> <a href="/tags/转载/" style="font-size: 13.64px;">转载</a> <a href="/tags/集合/" style="font-size: 13.64px;">集合</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>