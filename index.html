<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-SpringCloudAlibaba-5-nacos配置中心快速使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/29/SpringCloudAlibaba-5-nacos配置中心快速使用/">SpringCloudAlibaba-5-nacos配置中心快速使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们之前介绍了nacos作为注册中心，实现服务的注册与发现，这里主要介绍nacos作为配置中心  </p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>nacos作为配置中心<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/29.png" alt="">  </p>
<h4 id="1-实践"><a href="#1-实践" class="headerlink" title="1.实践"></a>1.实践</h4><p>nacos服务注册和配置中心是两个不同的依赖模块,可以单独各自引入依赖</p>
<h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h5><p>我们需要修改appliaction.yml文件为bootstrap.yml文件，不然会报空指针异常错误。bootstartp.yml文件是会在application.yml文件加载前加载。保证初始化的bean能够提前获取到一些属性。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/30.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  application:</div><div class="line">    name: nacos-config-client</div><div class="line">  cloud:</div><div class="line">    nacos:</div><div class="line">      config:</div><div class="line">        server-addr: 127.0.0.1:8848</div><div class="line">server:</div><div class="line">  port: 8055</div><div class="line">```  </div><div class="line"></div><div class="line">##### 3.在nacos配置列表中创建properties文件  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/31.png)  </div><div class="line"></div><div class="line"></div><div class="line">##### 4.创建controller测试   </div><div class="line">我们已经创建了配置中心，我们看通过配置是否可以获取到值  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/32.png)  </div><div class="line"></div><div class="line">我们发现我们能够获取到以上的值 </div><div class="line"></div><div class="line">##### 5.修改controller注解,然后修改配置列表看是否实时生效  </div><div class="line">现在我们修改下配置中心里面的配置:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/33.png)  </div><div class="line"></div><div class="line">我们再次通过页面访问以上接口:  </div><div class="line">http://127.0.0.1:8055/test/config  </div><div class="line">结果:  </div><div class="line">yxm  </div><div class="line"></div><div class="line">我们修改值时候并没有实时刷新，所以我们在controller加上注解:@RefreshScope;然后重启服务。  </div><div class="line">即可实现以上实时刷新功能。  </div><div class="line"></div><div class="line">我们修改properties文件时候,idea的页面下回刷新出以下信息:</div></pre></td></tr></table></figure>
<p>Refresh keys changed: [test]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 6.yml文件配置加载  </div><div class="line">nacos默认加载:properties文件，是通过一个属性:file-extension  </div><div class="line">现在我们改成:yml文件  </div><div class="line"></div><div class="line">bootstrap.yml文件：</div></pre></td></tr></table></figure></p>
<p>spring:<br>  application:<br>    name: nacos-config-client<br>  cloud:<br>    nacos:<br>      config:<br>        server-addr: 127.0.0.1:8848<br>        file-extension: yml<br>server:<br>  port: 8055<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/34.png)  </div><div class="line"></div><div class="line">创建:nacos-config-client.yml配置文件  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/35.png)  </div><div class="line"></div><div class="line">访问后得到:  </div><div class="line">yml-test    </div><div class="line"></div><div class="line">##### 7.Data ID</div><div class="line">Data ID组成:spring.application.name+file-extension  </div><div class="line"></div><div class="line">我们从nacos的文档里面可以知道data id是由:应用名称+profiles+file-extension</div></pre></td></tr></table></figure></p>
<p>spring:<br>  application:<br>    name: nacos-config-client<br>  cloud:<br>    nacos:<br>      config:<br>        server-addr: 127.0.0.1:8848<br>        file-extension: yml<br>  profiles:<br>    active: dev<br>server:<br>  port: 8055<br>```  </p>
<p>我们可以知道我们创建的配置文件在应用启动后默认加载:应用名称+profiles+file-extension 文件<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/36.png" alt="">  </p>
<p>然后我们创建:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/37.png" alt="">  </p>
<p>我们测试:<br><a href="http://127.0.0.1:8055/test/config" target="_blank" rel="external">http://127.0.0.1:8055/test/config</a><br>结果返回:<br>dev-yxm  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2020/01/29/SpringCloudAlibaba-5-nacos配置中心快速使用/" class="archive-article-date">
  	<time datetime="2020-01-29T09:43:46.000Z" itemprop="datePublished"><i class="icon-clock"></i>2020-01-29</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloudAlibaba/">SpringCloudAlibaba</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloudAlibaba-4-nacos服务注册与发现整合spring-cloud-gateway调用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: SpringCloudAlibaba-4-nacos服务注册与发现整合spring-cloud-gateway调用<br>date: 2020-01-27 13:12:39<br>tags:</p>
<h2 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title=" SpringCloudAlibaba"></a> SpringCloudAlibaba</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们前几节主要介绍了nacos注册中心实现服务之间的互相调用,我们这一节通过讲解nacos作为注册中心实现服务路由转发功能。  </p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="1-Gateway"><a href="#1-Gateway" class="headerlink" title="1.Gateway"></a>1.Gateway</h3><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/27.png" alt="">  </p>
<h3 id="2-本节简介"><a href="#2-本节简介" class="headerlink" title="2.本节简介"></a>2.本节简介</h3><p>使用SpringCloud GateWay实现如下功能:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/28.png" alt="">  </p>
<p>1.浏览器通过gateway(8054)端口访问到:provider(8051)服务<br>2.需要通过网关请求到provider服务,需要使用：LoadBalancerClient Filter  </p>
<p>实现如下:  </p>
<ol>
<li>1.创建项目:nacos-discovery-gateway-server  </li>
<li>2.修改pom.xml:去除spring-boot-starter-web和spring-boot-starter-test,引入：  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">```  </div><div class="line"></div><div class="line">3. 3.父工程里面添加: &lt;module&gt;nacos-discovery-gateway-server&lt;/module&gt;  </div><div class="line">4. 4.配置gateway路由策略</div></pre></td></tr></table></figure>
<p>spring:<br>  application:<br>    name: nacos-discovery-gateway-server<br>  cloud:<br>    nacos:<br>      discovery:<br>        server-addr: 127.0.0.1:8848<br>    gateway:<br>      routes:</p>
<pre><code>- id: nacos-discovery-provider
  uri: lb://nacos-discovery-provider
  predicates:
    - Path=/hello
</code></pre><p>server:<br>  port: 8054<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. 5.测试:  </div><div class="line">http://127.0.0.1:8054/hello?name=123   </div><div class="line">返回:Hello 123 port:8051  </div><div class="line">以上说明通过8054的网关访问到了8051的provider服务  </div><div class="line"></div><div class="line"></div><div class="line">6. 6.默认情况下:  </div><div class="line">我们访问:http://127.0.0.1:8054/provider/hello就可以访问到:http://127.0.0.1:8054/hello,所以我们访问某个微服务时候不能每次都配置一个路由前缀，需要我们统一管理:</div><div class="line"></div><div class="line">方法一:我们通过配置context-path作为微服务路由前缀；比如配置nacos-discovery-provider服务的context</div></pre></td></tr></table></figure></p>
<p>//设置nacos-discovery-gatewayr的application.yml<br>spring:<br>  application:<br>    name: nacos-discovery-gateway-server<br>  cloud:<br>    nacos:<br>      discovery:<br>        server-addr: 127.0.0.1:8848<br>    gateway:<br>      routes:</p>
<pre><code>- id: nacos-discovery-provider
  uri: lb://nacos-discovery-provider
  predicates:
    - Path=/provider
</code></pre><p>//设置nacos-discovery-provider的context-path<br>server:<br>  port: 8051<br>  servlet:<br>    context-path: provider<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">方法二:  </div><div class="line">我们跳过前缀的第一个uri</div></pre></td></tr></table></figure></p>
<p>spring:<br>  application:<br>    name: nacos-discovery-gateway-server<br>  cloud:<br>    nacos:<br>      discovery:<br>        server-addr: 127.0.0.1:8848<br>        metadata:<br>          name: lengleng<br>    gateway:<br>      routes:</p>
<pre><code>- id: nacos-discovery-provider
  uri: lb://nacos-discovery-provider
  predicates:
    - Path=/provider/**
  filters:
    - StripPrefix=1
</code></pre><p>```</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2020/01/27/SpringCloudAlibaba-4-nacos服务注册与发现整合spring-cloud-gateway调用/" class="archive-article-date">
  	<time datetime="2020-01-27T05:12:39.783Z" itemprop="datePublished"><i class="icon-clock"></i>2020-01-27</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloudAlibaba-3-nacos服务注册与发现整合feign-webflux调用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: ‘SpringCloudAlibaba-3-nacos服务注册与发现整合feign:webflux调用’<br>date: 2020-01-26 22:36:11<br>tags:</p>
<h2 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title=" SpringCloudAlibaba"></a> SpringCloudAlibaba</h2><h3 id="1-Feign"><a href="#1-Feign" class="headerlink" title="1.Feign"></a>1.Feign</h3><p>Feign是从Netflix中分离出来的轻量级项目，能够在类接口上添加注解，成为一个RES API客户端。  </p>
<h3 id="2-OpenFegin"><a href="#2-OpenFegin" class="headerlink" title="2.OpenFegin"></a>2.OpenFegin</h3><p>Spring Cloud在netflix feign的基础上扩展了支持Spring MVC注解,并通过自动配置为Spring Boot应用程序提供快速集成。  </p>
<h3 id="3-使用Fegin"><a href="#3-使用Fegin" class="headerlink" title="3.使用Fegin"></a>3.使用Fegin</h3><p>1.复制nacos-discovery-consumer项目，修改maven坐标及其在父工程里面添加module即可。<br>2.在nacos-discovery-consumer-fegin引入fegin依赖  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>3.开启feign  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@EnableFeignClients</div><div class="line">@EnableDiscoveryClient</div><div class="line">@SpringBootApplication</div><div class="line">public class NacosDiscoveryConsumerFeignApplication &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SpringApplication.run(NacosDiscoveryConsumerFeignApplication.class, args);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    @LoadBalanced</div><div class="line">    public RestTemplate restTemplate()&#123;</div><div class="line">        return new RestTemplate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.nacos-discovery-consumer-fegin调用nacos-discovery-provider  </p>
<p>a.创建feign的cient端口,并且其是nacos-discovery-provider的调用接口  </p>
<p>接口:HelloFeignService  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//FeignClient注解里面填写的是provider服务名称</div><div class="line">@FeignClient(&quot;nacos-discovery-provider&quot;)</div><div class="line">public interface HelloFeignService &#123;</div><div class="line">    @GetMapping(&quot;/hello&quot;)</div><div class="line">    String hello(@RequestParam(&quot;name&quot;) String name);</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">类:TestController</div></pre></td></tr></table></figure>
<p>@RestController<br>public class TestController {<br>    @Autowired<br>    private HelloFeignService helloFeignService;<br>    @GetMapping(“/test”)<br>    public String test(String name){<br>        return helloFeignService.hello(name);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">测试:  </div><div class="line">http://127.0.0.1:8052/test?name=111  </div><div class="line">返回:  </div><div class="line">Hello 111 port:8051  </div><div class="line">  </div><div class="line"></div><div class="line">### 4.webflux  </div><div class="line">webflux是和Spring-webmvc进行的对比，如下:    </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/26.png)  </div><div class="line"></div><div class="line">步骤：  </div><div class="line">1. 1.引入webflux的依赖  </div><div class="line">我们创建nacos-discovery-consumer-webflux;  </div><div class="line">修改里面的pom.xml文件:</div></pre></td></tr></table></figure></p>
<p><dependency><br>   <groupid>org.springframework.boot</groupid><br>   <artifactid>spring-boot-starter-web</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">为:</div></pre></td></tr></table></figure></p>
<p><dependency><br>    <groupid>org.springframework.boot</groupid><br>    <artifactid>spring-boot-starter-webflux</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">2. 2.创建WebClient.Builder(类似于mvc中的restTemplate)</div></pre></td></tr></table></figure></p>
<p>@EnableDiscoveryClient<br>@SpringBootApplication<br>public class NacosDiscoveryConsumerApplication {<br>    public static void main(String[] args) {<br>        SpringApplication.run(NacosDiscoveryConsumerApplication.class, args);<br>    }<br>    @Bean<br>    @LoadBalanced<br>    public WebClient.Builder webClientBuilder(){<br>          return WebClient.builder();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 3.Controller中调用</div></pre></td></tr></table></figure></p>
<p>@RestController<br>public class TestController {<br>    @Autowired<br>    private WebClient.Builder webClientBuilder;<br>    @GetMapping(“/test”)<br>    public Mono<string> test(String name){<br>       return  webClientBuilder.build()<br>                .get()<br>                .uri(“<a href="http://nacos-discovery-provider/hello?name=" target="_blank" rel="external">http://nacos-discovery-provider/hello?name=</a>“ + name)<br>                .retrieve()<br>                .bodyToMono(String.class);<br>    }<br>}<br>```</string></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2020/01/26/SpringCloudAlibaba-3-nacos服务注册与发现整合feign-webflux调用/" class="archive-article-date">
  	<time datetime="2020-01-26T14:36:11.524Z" itemprop="datePublished"><i class="icon-clock"></i>2020-01-26</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloudAlibaba-2-nacos负载均衡、服务上下线、权重元信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: SpringCloudAlibaba-2-nacos负载均衡、服务上下线、权重元信息<br>date: 2020-01-26 17:55:33<br>tags:</p>
<h2 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title=" SpringCloudAlibaba"></a> SpringCloudAlibaba</h2><h3 id="1-nacos服务上下线"><a href="#1-nacos服务上下线" class="headerlink" title="1.nacos服务上下线"></a>1.nacos服务上下线</h3><p>我们通过nacos管理首页点击:下线<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/19.png" alt="">  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/20.png" alt="">  </p>
<h3 id="2-nacos负载均衡"><a href="#2-nacos负载均衡" class="headerlink" title="2.nacos负载均衡"></a>2.nacos负载均衡</h3><p>nacos默认已经集成了ribbon作为负载均衡<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/21.png" alt="">  </p>
<p>实现负载均衡,修改2点:<br>1.consumer调用provider时候,我们直接改为服务名调用   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">public class TestController &#123;</div><div class="line">    @Autowired</div><div class="line">    private RestTemplate restTemplate;</div><div class="line">    @Autowired</div><div class="line">    private LoadBalancerClient loadBalancerClient;</div><div class="line">    @GetMapping(&quot;/test&quot;)</div><div class="line">    public String test(String name)&#123;</div><div class="line">        return restTemplate.getForObject(&quot;http://nacos-discovery-provider/hello?name=&quot;+name, String.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">2.RestTemplate添加注解(RestTemplate支持LoadBalanced):</div></pre></td></tr></table></figure>
<p>@EnableDiscoveryClient<br>@SpringBootApplication<br>public class NacosDiscoveryConsumerApplication {<br>    public static void main(String[] args) {<br>        SpringApplication.run(NacosDiscoveryConsumerApplication.class, args);<br>    }<br>    @Bean<br>    @LoadBalanced<br>    public RestTemplate restTemplate(){<br>        return new RestTemplate();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">3.再启动一个provider(8052)   </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/22.png)  </div><div class="line">然后分别启动:8051、8052  </div><div class="line">测试:</div></pre></td></tr></table></figure></p>
<p>curl ‘<a href="http://127.0.0.1:8050/test?name=qaws" target="_blank" rel="external">http://127.0.0.1:8050/test?name=qaws</a>‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/23.png)  </div><div class="line"></div><div class="line">  </div><div class="line"> </div><div class="line">### 3.权重设置  </div><div class="line">我们在nacos的控制台可以设置nacos负载provider的权重,类似于nginx的流量分配，权重越大，访问到此服务的可能性越大。  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/24.png)  </div><div class="line"></div><div class="line">### 4.元数据  </div><div class="line">通过nacos的管理台,我们点击进去provider详情可以看到元数据  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/25.png)  </div><div class="line"></div><div class="line">很多时候我们会把一份代码一个微服务部署多个节点，多个节点的内容代码是一致的,通过一些元数据获取服务信息来区分这个微服务，可以通过这些描述信息做一些流量迁移。比如同一个微服务中A节点流量大一点,B节点流量少一点，通过这个元数据做区别  </div><div class="line"></div><div class="line">我们如何在代码里面获取元数据呢？</div><div class="line"></div><div class="line">通过RibbonServer</div></pre></td></tr></table></figure></p>
<p>@GetMapping(“/test”)<br>public String test(String name){<br>    RibbonLoadBalancerClient.RibbonServer ribbonServer = (RibbonLoadBalancerClient.RibbonServer) loadBalancerClient.choose(“nacos-discovery-provider”);<br>    NacosServer nacosServer = (NacosServer) ribbonServer.getServer();<br>    Map<string, string=""> metadata = nacosServer.getMetadata();<br>    System.out.println(“—&gt;”+metadata);<br>    return restTemplate.getForObject(“<a href="http://nacos-discovery-provider/hello?name=&quot;+name" target="_blank" rel="external">http://nacos-discovery-provider/hello?name=&quot;+name</a>, String.class);<br>}<br>```</string,></p>
<p>输出:<br>—&gt;{name=provider1}  </p>
<p>参考:<br><a href="https://my.oschina.net/giegie" target="_blank" rel="external">https://my.oschina.net/giegie</a>    </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2020/01/26/SpringCloudAlibaba-2-nacos负载均衡、服务上下线、权重元信息/" class="archive-article-date">
  	<time datetime="2020-01-26T09:55:34.011Z" itemprop="datePublished"><i class="icon-clock"></i>2020-01-26</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloudAlibaba-1-nacos服务注册与发现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/25/SpringCloudAlibaba-1-nacos服务注册与发现/">SpringCloudAlibaba-1-nacos服务注册与发现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><ol>
<li>服务注册与发现:适配Spring Cloud服务注册与发现标准，默认集成了Ribbon的支持  </li>
<li>服务限流降级：默认支持servlet、Feign、RestTemplate、Dubbo和RocketMQ限流降级接入，可以在运行时通过控制台实时修改限流配置规则，还支持查看限流降级Metrics监控。  </li>
<li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。  </li>
<li>消息驱动能力：基于Spring Cloud Stream 为微服务应用构建消息驱动能力。  </li>
<li>分布式事务：使用@GlobalTransactional注解，高效并且对业务零侵入地解决分布式事务问题。  </li>
<li>阿里云对象存储：阿里云提供海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。  </li>
<li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时(基于Cron表达式) 任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker(schedulerx-client)上执行。  </li>
<li>阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。  </li>
</ol>
<h3 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h3><p>nacos=eureka+Spring Cloud Config  </p>
<h4 id="1-下载运行nacos"><a href="#1-下载运行nacos" class="headerlink" title="1.下载运行nacos"></a>1.下载运行nacos</h4><p>下载地址:<br><a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br>也可参考:<a href="https://nacos.io/en-us/docs/quick-start.html" target="_blank" rel="external">https://nacos.io/en-us/docs/quick-start.html</a>  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/8.png" alt="">  </p>
<h4 id="2-服务注册与发现实例"><a href="#2-服务注册与发现实例" class="headerlink" title="2.服务注册与发现实例"></a>2.服务注册与发现实例</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/9.png" alt=""><br>运行3个实例:8050、8051注册到nacos上面  </p>
<h5 id="2-1创建父工程"><a href="#2-1创建父工程" class="headerlink" title="2.1创建父工程"></a>2.1创建父工程</h5><p>1.创建工程<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/10.png" alt="">  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/11.png" alt="">  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/12.png" alt="">  </p>
<p>2.修改pom.xml<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/13.png" alt="">  </p>
<h5 id="2-2-创建consumer工程"><a href="#2-2-创建consumer工程" class="headerlink" title="2.2 创建consumer工程"></a>2.2 创建consumer工程</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/14.png" alt=""> </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/15.png" alt=""> </p>
<p>添加相关依赖<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2020/01/16.png" alt="">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;!--依赖版本定义--&gt;</div><div class="line">   &lt;dependencyManagement&gt;</div><div class="line">       &lt;dependencies&gt;</div><div class="line">           &lt;dependency&gt;</div><div class="line">               &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">               &lt;version&gt;Greenwich.RELEASE&lt;/version&gt;</div><div class="line">               &lt;type&gt;pom&lt;/type&gt;</div><div class="line">               &lt;scope&gt;import&lt;/scope&gt;</div><div class="line">           &lt;/dependency&gt;</div><div class="line">           &lt;dependency&gt;</div><div class="line">               &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">               &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</div><div class="line">               &lt;version&gt;0.2.1.RELEASE&lt;/version&gt;</div><div class="line">               &lt;type&gt;pom&lt;/type&gt;</div><div class="line">               &lt;scope&gt;import&lt;/scope&gt;</div><div class="line">           &lt;/dependency&gt;</div><div class="line">       &lt;/dependencies&gt;</div><div class="line">   &lt;/dependencyManagement&gt;</div></pre></td></tr></table></figure>
<p>再次添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line">添加Application服务发现客户端</div></pre></td></tr></table></figure>
<p>@EnableDiscoveryClient<br>@SpringBootApplication<br>public class NacosDiscoveryConsumerApplication {<br>    public static void main(String[] args) {<br>        SpringApplication.run(NacosDiscoveryConsumerApplication.class, args);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">application.yml</div></pre></td></tr></table></figure></p>
<p>spring:<br>  application:<br>    name: nacos-discovery-consumer<br>  cloud:<br>    nacos:<br>      discovery:<br>        server-addr: 127.0.0.1:8848<br>server:<br>  port: 8050<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">先启动nacos    </div><div class="line">https://nacos.io/en-us/docs/quick-start.html  </div><div class="line"></div><div class="line">然后输入:http://127.0.0.1:8848/nacos/  </div><div class="line">查看服务列表:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/17.png)  </div><div class="line"> </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"> </div><div class="line">##### 2.3 创建provider工程  </div><div class="line"></div><div class="line">类似的我们创建nacos-discovery-provider工程,并添加对应配置  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2020/01/18.png)  </div><div class="line"></div><div class="line"></div><div class="line">##### 2.4  让consumer去调用provider  </div><div class="line">1. 1.provider创建HelloController</div></pre></td></tr></table></figure></p>
<p>@RestController<br>public class HelloController {<br>    @GetMapping(“/hello”)<br>    public String hello(String name){<br>        return “Hello “+name;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 2.provider创建HelloController</div></pre></td></tr></table></figure></p>
<p>@RestController<br>public class TestController {<br>    @Autowired<br>    private RestTemplate restTemplate;<br>    @Autowired<br>    private LoadBalancerClient loadBalancerClient;<br>    @GetMapping(“/test”)<br>    public String test(String name){<br>        ServiceInstance serviceInstance = loadBalancerClient.choose(“nacos-discovery-provider”);<br>        URI uri = serviceInstance.getUri();<br>        return restTemplate.getForObject(uri+”/hello?name=”+name, String.class);<br>    }<br>}<br>//NacosDiscoveryConsumerApplication注入:RestTemplate<br>@EnableDiscoveryClient<br>@SpringBootApplication<br>public class NacosDiscoveryConsumerApplication {<br>    public static void main(String[] args) {<br>        SpringApplication.run(NacosDiscoveryConsumerApplication.class, args);<br>    }<br>    @Bean<br>    public RestTemplate restTemplate(){<br>        return new RestTemplate();<br>    }<br>}<br>```   </p>
<p>3.测试<br><a href="http://127.0.0.1:8050/test?name=qaws" target="_blank" rel="external">http://127.0.0.1:8050/test?name=qaws</a><br>结果返回:<br>Hello qaws  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2020/01/25/SpringCloudAlibaba-1-nacos服务注册与发现/" class="archive-article-date">
  	<time datetime="2020-01-25T15:38:42.000Z" itemprop="datePublished"><i class="icon-clock"></i>2020-01-25</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloudAlibaba/">SpringCloudAlibaba</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-11-服务追踪11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/25/SpringCloud-11-服务追踪11/">SpringCloud-11-服务追踪11</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2020/01/25/SpringCloud-11-服务追踪11/" class="archive-article-date">
  	<time datetime="2020-01-25T15:27:49.000Z" itemprop="datePublished"><i class="icon-clock"></i>2020-01-25</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-linux-防火墙命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/06/linux-防火墙命令/">linux-防火墙命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Linux关闭防火墙命令<br>问题:老是关闭防火墙太麻烦，所以选择彻底关闭防火墙，发现每次都记不住命令!</p>
<p>下面是red hat/CentOs7关闭防火墙的命令!</p>
<p>1:查看防火状态</p>
<p>systemctl status firewalld</p>
<p>service  iptables status</p>
<p>2:暂时关闭防火墙</p>
<p>systemctl stop firewalld</p>
<p>service  iptables stop</p>
<p>3:永久关闭防火墙</p>
<p>systemctl disable firewalld</p>
<p>chkconfig iptables off</p>
<p>4:重启防火墙</p>
<p>systemctl enable firewalld</p>
<p>service iptables restart  </p>
<p>5:永久关闭后重启</p>
<p>//暂时还没有试过</p>
<p>chkconfig iptables on</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2020/01/06/linux-防火墙命令/" class="archive-article-date">
  	<time datetime="2020-01-06T02:26:59.000Z" itemprop="datePublished"><i class="icon-clock"></i>2020-01-06</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ipcc-4-批次event排查" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/19/ipcc-4-批次event排查/">ipcc-4-批次event排查</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候我们批次会出现不拨打问题</p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>如果按照以下方式信息都查不出来，直接  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;1999&quot; callnotify_callnotify01_157749*</div></pre></td></tr></table></figure>
<p>一些基本的批次排查指令如下:  </p>
<ol>
<li>1.查找任务呼叫情况  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;callout&quot;  callnotify_callnotify01_157673* |grep 1523</div></pre></td></tr></table></figure>
<ol>
<li>2.查看任务停止  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;end t&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>3.查看任务启动  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;beginthreadex notifyid&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>4.查任务是否暂停,批次是否在呼叫时间  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;getTaskCallPause&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>5.查看任务心跳 非暂停任务 5s会有一次心跳  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;hartbit taskid&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>6.查看任务占用通道取名单有值的时候 3s执行一次  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;getnotifychn taskid&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>7.计算当前呼出名单数，名单缓冲有值的时候执行   有呼叫通道时候或者超过5s没通道的时候输出  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;getTaskCallNew begin taskid&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>8.取不到主叫 无法呼出  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;caller is empty&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>9.通道数量不够  无法呼出  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;no idel channel&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>10.呼叫失败  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;callout fail&quot;  callnotify_callnotify01_15759* |grep 2093</div></pre></td></tr></table></figure>
<ol>
<li>11.查找僵尸线程  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &quot;thread exit notifyid&quot; callnotify_callnotify01_1577* |grep &quot;wait count\[4\]</div></pre></td></tr></table></figure>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/12/19/ipcc-4-批次event排查/" class="archive-article-date">
  	<time datetime="2019-12-19T06:45:13.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-12-19</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ipcc/">ipcc</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-docker-1-docker基础入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: docker-1-docker基础入门<br>date: 2019-12-15 08:53:59<br>tags:</p>
<h2 id="docker"><a href="#docker" class="headerlink" title=" docker"></a> docker</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们基础入门,从以下几方面讲解:<br>1.什么是docker<br>2.理解docker<br>3.走进docker<br>4.Hello World运行docker<br>5.Nginx服务<br>6.docker化Java web  </p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>docker官网:<a href="https://www.docker.com/" target="_blank" rel="external">https://www.docker.com/</a></p>
<h4 id="1-什么是docker"><a href="#1-什么是docker" class="headerlink" title="1.什么是docker"></a>1.什么是docker</h4><h5 id="1-1-Docker历史"><a href="#1-1-Docker历史" class="headerlink" title="1.1 Docker历史"></a>1.1 Docker历史</h5><ol>
<li>1.2010年几个年轻人在旧金山成立了做paas平台公司dotCloud,后面由于微软,亚马逊竞争  </li>
<li>2.2013年公司发展受限,又不想之前东西付之东流,docker开源  </li>
<li>3.2014.6 Docker1.0  </li>
<li>4.2014.7 C轮$4000万  </li>
<li>5.2015.4 D轮9500万  </li>
<li>6.至今Docker1.13  </li>
</ol>
<h5 id="1-2-什么是docker"><a href="#1-2-什么是docker" class="headerlink" title="1.2 什么是docker"></a>1.2 什么是docker</h5><ol>
<li>1.docker是一个装应用的容器,就像杯子可以装水,笔筒可以放笔,你可以把Hello world放在docker里,你可以把网站放到docker里,你可以把你任何想到的程序放到docker里面。  </li>
<li>2.Docker is the world’s leading software containerization platform </li>
<li>3.Docker公司开发，开源，托管在github上  </li>
<li>4.跨平台、支持Windows、Macos、Linux  </li>
</ol>
<h4 id="2-理解docker"><a href="#2-理解docker" class="headerlink" title="2.理解docker"></a>2.理解docker</h4><h5 id="2-1-docker思想"><a href="#2-1-docker思想" class="headerlink" title="2.1 docker思想"></a>2.1 docker思想</h5><p>docker的logo是一条鲸鱼驮着很多集装箱；<br>docker思想体现在:  </p>
<ol>
<li>1.集装箱(没有集装箱之前运输货物是非常零散,没有规矩,运输过程中某一个东西可能就掉落了,有了集装箱之后,我们的东西装到集装箱里面去了,箱子是密封的，并很大,保证货物安全原样送到目的地,这些货物就是类似于我们的各种程序)      </li>
<li><p>2.标准化-&gt;标准化主要体现在以下3个方面:<br>a.传输方式:docker运输程序有一个超级码头,任何一个地方需要货物时候,都是由鲸鱼将获取送到超级码头,然后由鲸鱼将货物从超级码头送到目的地。例子:假如你要把你台式机上面的应用部署到你的笔记本上,一般选择u盘或者qq传输过去,但是docker标准化了这个过程,你要做的只需要在台式机上执行一个docker命令把程序输送到超级码头去；然后在你的笔记本上执行一个docker命令-&gt;由鲸鱼把程序从超级码头送到笔记本上去。<br>b.存储方式:比如你把程序从台式机拷贝到你笔记本,你还得创建目录,并且记住这个目录,有了docker之后存储方式标准化了你不需要关心程序在哪个目录下,你只需要执行或者停止一个命令就可以了。docker标准化让快速扩展、弹性伸缩变得简单。<br>c.API接口标准化:docker提供了一系列api接口,包括了docker对我们应用的控制:查看,删除,停止等等。  </p>
</li>
<li><p>3.隔离:轻量级创建销毁docker,你创建虚拟机可能需要几分钟,但是创建docker只需要1秒。最底层的技术其实是linux的内核限制机制,叫做LXC(轻量级的容器虚拟化技术,最大效率地隔离了进程和资源)  </p>
</li>
</ol>
<h5 id="2-2-docker解决了什么问题"><a href="#2-2-docker解决了什么问题" class="headerlink" title="2.2 docker解决了什么问题"></a>2.2 docker解决了什么问题</h5><p>docker解决了运行环境不一致导致的问题。  </p>
<ol>
<li><p>1.我们本地运行没有问题,线上测试有问题<br>很多时候我们开发程序员说我们开发没有问题,但是运维说他那边部署没有问题、测试说就有问题，如果一个应用正常运行需要什么?,比如一个java web应用运行需要什么？<br>一般需要:1.最底层的操作系统 2.JDK 3.Tomcat 4.依赖于程序代码和配置文件<br>以上任何一个条件多个环境下不一致可能就会导致系统问题；下面docker来了,他把操作系统、JDK、Tomcat、程序放在一个个的集装箱里面再打包放到鲸鱼上,鲸鱼将其运输到服务器上。你机器上怎么运行，他在服务器上也是怎样运行的</p>
</li>
<li><p>2.系统好卡,哪个人又写死循环了?!<br>linux本身就是一个多用户的操作系统，登录的每个人都有可能修改配置,那怎么办呢?用docker,docker的隔离性很好的解决了这个问题。如果把大家的应用程序都放到docker里面运行,就算别人的程序是死循环都不会导致别人的程序？原因是docker启动的时候就限定好了每个程序使用的最大的cpu,内存,硬盘  </p>
</li>
<li><p>3.双11来了,服务器撑不住啦!<br>大部分系统每天的业务量并不是平均的,特别是一些电商系统每年总会有那么几天业务量比平时多几倍甚至几十倍。如果按照平时量准备服务器,那么双十一来了肯定撑不住,如果按照双十一规模准备服务器,那么平时就是极大浪费。所以只能在节日前临时扩展机器,过完节给其他服务下线,这给运维带来非常大工作量,节日时候需要在各个服务器上部署各种各样服务,装好只有还不一定能运行,还得调试,这是多么烦躁的事情。使用docker使事情变得好多了,我们只需要点击一下,就可以变成几十台、几百台、几千几万台；   </p>
</li>
</ol>
<h4 id="3-走进docker"><a href="#3-走进docker" class="headerlink" title="3.走进docker"></a>3.走进docker</h4><h5 id="3-1-docker核心技术"><a href="#3-1-docker核心技术" class="headerlink" title="3.1 docker核心技术"></a>3.1 docker核心技术</h5><p>docker里面有3个核心词汇,叫做:仓库(超级码头)、镜像(集装箱)、容器(运行程序的地方)  </p>
<p>用docker运行一个程序的过程就是:从仓库，把镜像拉到本地、然后用一条命令把镜像运行起来变成容器  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/80.png" alt="">    </p>
<p>上面图有:build、ship、run<br>a.build(构建)-&gt;构建镜像<br>b.ship(运输)-&gt;运输镜像<br>c.run(运行)-&gt;运行镜像就是个容器  </p>
<h5 id="3-2-docker镜像"><a href="#3-2-docker镜像" class="headerlink" title="3.2 docker镜像"></a>3.2 docker镜像</h5><p>鲸鱼驮着的集装箱就是一个镜像,镜像本质其实就是文件(应用程序文件、运行环境文件)既然是文件docker是将其保存到本地了,既然保存了,那么是以什么样的格式来保存呢?说到镜像存储格式,就需要提到linux的存储技术叫做联合文件系统:unionfs  是一个分层的文件系统,可以将不同的文件挂载到同一个虚拟文件下</p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/81.png" alt="">  </p>
<p>以上可以看到test1和test2下面都有各自的文件,unionfs系统就像test可以看到上面所有文件，类似于把test1看成第一层，test2看做第二层。docker镜像就是利用这种分层实现镜像存储。     </p>
<p>docker镜像存储格式如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/82.png" alt=""><br>a.最底层是操作系统的引导<br>b.第二层是linux的操作系统<br>c.第三层,第四层是我们的应用程序，我们可以控制<br>d.第五层是容器相关东西,先不管  </p>
<p>docker镜像的每一层文件系统都是只读的,然后把每一层加载完成之后,文件都会被看成同一个目录,相当于只有一个文件系统,叫做镜像。  </p>
<h5 id="3-3-docker容器"><a href="#3-3-docker容器" class="headerlink" title="3.3 docker容器"></a>3.3 docker容器</h5><ol>
<li>1.容器的本质就是一个进程,便于理解我们可以把容器看成一个虚拟机。  </li>
<li>2.每个虚拟机都有自己的文件系统<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/82.png" alt=""><br>可以把上面看成是容器的文件系统,和虚拟机的区别是这里的文件系统是一层一层的,并且最下面的四层都是只读的,最上面的一层是可写的,为什么需要可写的呢?大家程序运行起来,势必需要一些日志,一些文件,对系统文件修改。所以创建一个可读可写系统。  </li>
</ol>
<p>如何修改镜像里面可读的文件，因为镜像每一层只读,所以会把镜像可读的文件拷贝到可写的文件一层,然后再对他进行修改,修改之后我们的应用要读一个文件时候,就会从最上层开始查找,如果没有才会找下一层。所以容器是可以修改的,镜像是不可以修改的，这样保证同一个镜像生成不同容器独立运行,并且之间无直接干扰。 </p>
<h5 id="3-4-docker仓库"><a href="#3-4-docker仓库" class="headerlink" title="3.4 docker仓库"></a>3.4 docker仓库</h5><ol>
<li>1.镜像已经构建完了,镜像构建目的是要在其他机器、其他环境运行我们的程序,如果在本机上运行就不需要构建镜像了。构建完之后如果运输到其他环境中去,这里就运用到了docker仓库。我们先把我们的镜像传递到仓库里面去,再由目的地把docker仓库拉过去。这样就完成了这样的传输过程。</li>
<li>2.谁提供了docker仓库呢?需要有一个中央服务器提供一个地址,让我们去访问,docker自己就提供了这个服务,提供服务的地址就叫:hub.docker.com,但是有一个问题是最开始这个网站是被墙掉的,国内根本访问不了,现在虽然可以访问了,但是加载镜像速度还是很慢,为了解决这个问题,国内很多也在做这个仓库,国内比较著名的是国内一个c.163.com的仓库  </li>
</ol>
<ol>
<li>3.以上是共有的镜像中心,假如我们自己的镜像比较私密,不想被其他人看到呢?docker也是支持我们自己搭建一个镜像中心  </li>
</ol>
<h3 id="4-docker安装"><a href="#4-docker安装" class="headerlink" title="4.docker安装"></a>4.docker安装</h3><h4 id="4-1-window安装docker"><a href="#4-1-window安装docker" class="headerlink" title="4.1 window安装docker"></a>4.1 window安装docker</h4><p>Windows  </p>
<p>docker下载地址：<br>win10: www.docker.com/products/docker#/windows<br>win10之外：<a href="http://www.docker.com/products/docker-toolbox" target="_blank" rel="external">http://www.docker.com/products/docker-toolbox</a><br>国内下载地址：<a href="http://get.daocloud.io" target="_blank" rel="external">http://get.daocloud.io</a></p>
<p>boot2docker.iso下载地址：<br><a href="http://pan.baidu.com/s/1qYyc0ag" target="_blank" rel="external">http://pan.baidu.com/s/1qYyc0ag</a>  </p>
<ol>
<li>1.下载后默认安装  </li>
</ol>
<p>安装完之后,在桌面上会有3个快捷方式,其中Docker Quickstart Terminal是我们启动docker的按钮。  </p>
<ol>
<li>2.缺包之后,我们从百度云盘去下载:boot2docker.iso下载地址:<a href="http://pan.baidu.com/s/1qYyc0ag" target="_blank" rel="external">http://pan.baidu.com/s/1qYyc0ag</a><br>第一次运行可能比较慢<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/84.png" alt=""><br>上面说从github上下载文件失败,因为github是外国网站,所以慢,需要我们自己下载:<br>我们现在下载好iso文件后,我们把他存放到:C:\Users\yxm.docker\machine\cache里面的docker文件:  </li>
</ol>
<h4 id="4-2-linux安装docker"><a href="#4-2-linux安装docker" class="headerlink" title="4.2 linux安装docker"></a>4.2 linux安装docker</h4><p>Linux<br>1.Redhat&amp;CentOS:<br>系统要求:64-bit OS and version 3.10<br>安装连接:<a href="http://www.imooc.com/article/16448" target="_blank" rel="external">http://www.imooc.com/article/16448</a>  </p>
<p>linux下安装完之后,如果执行docker version出现:Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?<br>说明docker服务没有起来。我们需要执行如下指令:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start docker.service</div></pre></td></tr></table></figure>
<p>2.Ubuntu:<br>系统要求:64-bit OS and version 3.10  </p>
<h3 id="5-docker实践"><a href="#5-docker实践" class="headerlink" title="5.docker实践"></a>5.docker实践</h3><h4 id="5-1-第一个docker镜像"><a href="#5-1-第一个docker镜像" class="headerlink" title="5.1 第一个docker镜像"></a>5.1 第一个docker镜像</h4><h5 id="5-1-1-二个命令"><a href="#5-1-1-二个命令" class="headerlink" title="5.1.1 二个命令"></a>5.1.1 二个命令</h5><p>第一个初体验就是运行hello world,运行这个的时候,我们需要运行两条命令。  </p>
<ol>
<li><p>1.docker pull [OPTIONS] NAME[:TAG]<br>a.从docker远程仓库拉取一个镜像到我们本地<br>b.NAME表示:拉取镜像的名称  :TAG是可选的,如果不加的话默认会是:latest表示我们镜像的最新版本,如果指定一个tag的话；中间的options是拉取时候的一些参数  </p>
</li>
<li><p>2.docker images [OPTIONS][REPOSITORY[:tag]]<br>查看我们本机都有哪些镜像?也可以验证我们pull是否成功了?  </p>
</li>
</ol>
<h5 id="5-1-2-具体操作"><a href="#5-1-2-具体操作" class="headerlink" title="5.1.2 具体操作"></a>5.1.2 具体操作</h5><ol>
<li><p>1.查看本机所有镜像列表<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/85.png" alt=""><br>我们发现本地没有任何镜像,只打印了每列的列头  </p>
</li>
<li><p>2.拉取hello-world镜像<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/86.png" alt=""><br>a.Using default tag: latest—表示默认拉取最新分支<br>b.Digest: sha256:4fe721ccc2e8dc7362278a29dc660d833570ec2682f4e4194f4ee23e415e1064—摘要<br>c.Status: Downloaded newer image for docker.io/hello-world:latest—状态  </p>
</li>
</ol>
<p>再使用docker images查看时候,出现如下:<br>a.REPOSITORY:镜像名称<br>b.TAG:分支<br>c.IMAGEID:id标识<br>d.CREATED:最后修改时间<br>e:SIZE:镜像大小  </p>
<ol>
<li>3.2点说明:<br>a.我们这里的镜像名称为：hello-world是docker镜像官网限制的<br>b.我们pull取镜像的时候,没有填写镜像的地址,他是如何找到的呢?他会默认从docker自己仓库下载:hub.docker.com  </li>
</ol>
<h4 id="5-2-第一个docker容器"><a href="#5-2-第一个docker容器" class="headerlink" title="5.2 第一个docker容器"></a>5.2 第一个docker容器</h4><p>我们已经把docker镜像下载下来了,下面我们需要运行docker容器  </p>
<ol>
<li>1.docker运行指令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run [OPTIONS] IMAGE[:TAG][COMMAND][ARG...]</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/87.png" alt="">  </p>
<p>以上是docker运行后的输出,指明了docker运行时候经历的4步。  </p>
<p>为了形象理解,我们使用一张图表示:  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/88.png" alt=""><br>a.上图分为3个部分:Client、DOCKER_HOST、Register<br>b.client:在我们本机;就是我们终端,执行指令的地方<br>c.DOCKER_HOST也是在我们本机的Docker daemon<br>d.Register:Docker的远程仓库  </p>
<p>以上执行分析:<br>1.docker pull:把我们的命令发到docker daemon,docker daemon去找Images镜像,daemon去检查我们本地是否存在对应版本,如果存在直接返回到,如果镜像不存在就去远程仓库去拉取到本地<br>2.docker run:把我们的命令发到docker daemon，daemon检查镜像在本机是否已经存在,如果不存在,就去远端拉取。存放到本地images,然后产生一个docker容器。  </p>
<h3 id="6-docker运行nginx"><a href="#6-docker运行nginx" class="headerlink" title="6.docker运行nginx"></a>6.docker运行nginx</h3><p>nginx是一个web服务器,nginx镜像的特点:<br>1):持久运行的容器<br>2):前台挂起&amp;后台运行(前台运行我们使用Ctrl+c即可关闭,我们用后端运行)<br>3):进入容器内部  </p>
<h4 id="6-1-docker运行nginx"><a href="#6-1-docker运行nginx" class="headerlink" title="6.1 docker运行nginx"></a>6.1 docker运行nginx</h4><p>去网易镜像中心查看:<a href="https://c.163.com/hub#/home" target="_blank" rel="external">https://c.163.com/hub#/home</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/89.png" alt="">  </p>
<ol>
<li><p>1.拉取镜像:hub.c.163.com/library/nginx:latest<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/90.png" alt="">  </p>
</li>
<li><p>2.运行镜像:<br>前台运行镜像:docker run hub.c.163.com/library/nginx<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/91.png" alt="">    </p>
</li>
</ol>
<p>我们发现没有什么反应:我们打开另一个终端,查看下docker运行的进程<br>docker ps<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/92.png" alt="">  </p>
<p>从上面可以看出我们的docker已经运行了，说明上面是前台运行  </p>
<p>通过:docker run –help:查看docker run有哪些参数<br>后台启动:docker run -d<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/93.png" alt="">  </p>
<p>id:656dea8798aefb5699df96f623835d6df34b2c839de1876efe9842052bfb5757</p>
<ol>
<li>3.查看容器内部结构<br>容器已经运行起来了,我们如何查看容器内部的结构呢?我们有时候需要看下运行的容器是否正常,内部日志等。  </li>
</ol>
<p>docker exec –help<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/94.png" alt="">  </p>
<p>我们一般用到的是-i和-t参数,一般是可以合并的。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/95.png" alt="">  </p>
<p>进入自带的镜像目录:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/96.png" alt="">  </p>
<h4 id="6-2-docker的网络"><a href="#6-2-docker的网络" class="headerlink" title="6.2 docker的网络"></a>6.2 docker的网络</h4><p>上面我们已经用docker运行了一个nginx，但是我们还没有在浏览器访问nginx,这一章节我们看下docker的网络,然后从浏览器上访问下nginx  </p>
<h5 id="6-2-1-docker网络类型"><a href="#6-2-1-docker网络类型" class="headerlink" title="6.2.1 docker网络类型"></a>6.2.1 docker网络类型</h5><ol>
<li><p>1.网络也是隔离性一部分,linux使用namespace来实现隔离的,pid namespace就是用来隔离进程的,mount namespace就是用来隔离文件系统的,network namespace就是用来隔离网络的,每一个network namespace都提供了独立的网络环境(包括:网卡、路由等)  </p>
</li>
<li><p>2.docker容器默认情况下会分配默认的独立的network namespace也就是网络类型中的:Bridge模式 还有一种Host模式(如果启动时候使用Host模式,那么这个容器将不会获得独立的network namespace而是和主机共同使用一个,这个时候容器将不会虚拟出自己网卡,ip等,而是会使用宿主机上的ip和port，也就是在docker里面使用网络和在主机上使用网络没有区别的 还有一种网络类型是没有网络：none;这种情况docker将不会和外界任何东西进行通讯)  </p>
</li>
<li><p>3.Bridge模式时候涉及到,既然是独立的network namespace,这就需要一种技术:这就需要容器内部的端口可以在主机上访问到，这种技术就是端口映射,docker可以实现容器内部端口和容器所在的主机上端口进行映射,也就是访问主机里面这个端口就是访问容器里面的端口;   </p>
</li>
<li>4.docker网络模式图:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/97.png" alt=""><br>a.host模式(最左边):eth0是我们主机网卡,host模式时候,容器会直接连接到主机的网卡上,跟主机使用同一块网卡,所以说容器内看到的网络和主机看到的网络是一样的。<br>b.Bridge模式(中间)：首先会创建一个docker0的网桥,这个网桥跟主机eth0相连接,使用同一块网卡,所以说启动容器的时候,容器内部会虚拟出一个容器内部的虚拟网卡跟网桥相连通过这种方式docker与主机进行通信，这种情况容器里面会有自己独有的ip、port;端口映射的过程:在主机上有一个端口80,通过访问80端口会到主机的eth0网卡,通过这个网卡,会访问到</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/12/15/docker-1-docker基础入门/" class="archive-article-date">
  	<time datetime="2019-12-15T00:53:59.778Z" itemprop="datePublished"><i class="icon-clock"></i>2019-12-15</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-10-服务追踪" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/14/SpringCloud-10-服务追踪/">SpringCloud-10-服务追踪</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>服务追踪,我们使用SpringCloudSleuth和Zipkin做服务追踪  </p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候,我们订单服务创建订单时候耗时很严重<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/76.png" alt=""><br>以上订单花费了2.2秒,耗时很严重。到底问题出现在哪里呢?可能是下单时候调用product服务获取商品信息时候耗时比较严重。也可能是扣库存地方耗时比较严重,那我们如何确认是哪个接口耗时比较严重呢?一般我们是通过计时:在调用之前计时,在调用之后计时,这样就得出结论来了。假设已经定位出问题是调用商品服务返回商品信息耗时严重,此时我们就会通知此接口开发者解决,但是获取商品信息接口又是调用了其他服务,<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/77.png" alt=""><br>就像上面的服务:A调用B,B调用C,这是一整套链路,当服务调用越来越多,链路越来越长时候,通过日志计时打点效率非常低而且排查起来不方便，这就牵涉到服务追踪。我们要做的其实就是链路监控。     </p>
<h3 id="10-1-服务追踪"><a href="#10-1-服务追踪" class="headerlink" title="10.1 服务追踪"></a>10.1 服务追踪</h3><p>针对于链路监控,SpringCloud提供了非常方便的组件:Spring Cloud Sleuth,Sleuth是侦查,链路监控这一章节,要写的东西并不多,主要是要会看。  </p>
<h4 id="10-1-1-使用SpringCloudSleuth"><a href="#10-1-1-使用SpringCloudSleuth" class="headerlink" title="10.1.1 使用SpringCloudSleuth"></a>10.1.1 使用SpringCloudSleuth</h4><ol>
<li>1.引入依赖  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<ol>
<li>2.使用postman请求:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/78.png" alt=""><br>从上图我们知道:<br>a.第一列:order-&gt;代表order服务<br>b.第二列:代表traceId(链路id);一条链路里面最多包含一个id,也就是说traceId是一条链路的唯一标识。<br>c.第三列:spanId,是一个基本单元；一条链路里面可以包含多个spanid,spanid可以理解成最基本的工作单元。<br>d.第四列:true表示要把这些信息输出到其他服务搜集和展示,false就是不搜集。  </li>
</ol>
<p>我们现在在本地配置文件中将日志级别改为debug模式  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">logging:</div><div class="line">  level:</div><div class="line">   org.springframework.cloud.openfeign: debug</div></pre></td></tr></table></figure>
<p>此时展示出更多的日志:  </p>
<pre><code>2019-12-15 08:15:41.058 DEBUG [order,dc93086b3bb2856a,eec9e8de8adb4274,false] 16616 --- [strix-product-2] o.s.c.openfeign.support.SpringEncoder    : Writing [[DecreaseStockInput{productId=&apos;157875227953464068&apos;, productQuantity=2}]] using [org.springframework.http.converter.json.MappingJackson2HttpMessageConverter@d43328]
Hibernate: select ordermaste0_.order_id as order_id1_1_0_, ordermaste0_.buyer_address as buyer_ad2_1_0_, ordermaste0_.buyer_name as buyer_na3_1_0_, ordermaste0_.buyer_openid as buyer_op4_1_0_, ordermaste0_.buyer_phone as buyer_ph5_1_0_, ordermaste0_.create_time as create_t6_1_0_, ordermaste0_.order_amount as order_am7_1_0_, ordermaste0_.order_status as order_st8_1_0_, ordermaste0_.pay_status as pay_stat9_1_0_, ordermaste0_.update_time as update_10_1_0_ from order_master ordermaste0_ where ordermaste0_.order_id=?
</code></pre><p>一条链路请求里面只有1个reaceId,order服务是调用product服务的,那么product服务是否也是拥有此traceId,我们在product服务也加上服务追踪的sleuth  </p>
<p>我们用postman再次请求1次:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/79.png" alt="">  </p>
<p>现在指标已经出来了,但是我们不可能一直在控制台上看,我们需要友好的,有计划的展示出来。这里我们用到Zipkin框架展示。  </p>
<h4 id="10-1-1-使用Zipkin"><a href="#10-1-1-使用Zipkin" class="headerlink" title="10.1.1 使用Zipkin"></a>10.1.1 使用Zipkin</h4><p>访问官网:<a href="https://zipkin.io/" target="_blank" rel="external">https://zipkin.io/</a>     </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/12/14/SpringCloud-10-服务追踪/" class="archive-article-date">
  	<time datetime="2019-12-14T02:32:09.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-12-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/ElasticStack/" style="font-size: 10px;">ElasticStack</a> <a href="/tags/SpringCloud/" style="font-size: 20px;">SpringCloud</a> <a href="/tags/SpringCloudAlibaba/" style="font-size: 13.33px;">SpringCloudAlibaba</a> <a href="/tags/acdgate/" style="font-size: 10px;">acdgate</a> <a href="/tags/ipcc/" style="font-size: 16.67px;">ipcc</a> <a href="/tags/problem/" style="font-size: 10px;">problem</a> <a href="/tags/work/" style="font-size: 13.33px;">work</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>