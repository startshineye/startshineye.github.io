<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-ElasticStack-2-入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/24/ElasticStack-2-入门/">ElasticStack-2-入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-内容简介"><a href="#1-内容简介" class="headerlink" title="1.内容简介:"></a>1.内容简介:</h3><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/68.png" alt=""> </p>
<h3 id="2-Elastic-Search和Kibana入门"><a href="#2-Elastic-Search和Kibana入门" class="headerlink" title="2.Elastic Search和Kibana入门"></a>2.Elastic Search和Kibana入门</h3><h4 id="2-1-Elasticsearch安装与运行"><a href="#2-1-Elasticsearch安装与运行" class="headerlink" title="2.1 Elasticsearch安装与运行"></a>2.1 Elasticsearch安装与运行</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/69.png" alt=""> </p>
<p>浏览器输入:<a href="https://www.elastic.co---&gt;进入products--&gt;进入elasticsearch--&gt;Download" target="_blank" rel="external">https://www.elastic.co---&gt;进入products--&gt;进入elasticsearch--&gt;Download</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/70.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/71.png" alt=""><br>我这里以window下为例,下载后解压运行：bin\elasticsearch.bat</p>
<p>我们访问:<a href="http://127.0.0.1:9200就可以确认es是否已经启动。" target="_blank" rel="external">http://127.0.0.1:9200就可以确认es是否已经启动。</a>  </p>
<h4 id="2-2-Elasticsearch配置详解"><a href="#2-2-Elasticsearch配置详解" class="headerlink" title="2.2 Elasticsearch配置详解"></a>2.2 Elasticsearch配置详解</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/72.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/73.png" alt=""></p>
<ol>
<li><p>1.elasticsearch.yml配置文件说明:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/74.png" alt=""> </p>
</li>
<li><p>2.Development与 Production模式说明<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/75.png" alt="">  </p>
</li>
</ol>
<h4 id="2-3-Elasticsearch本地快速搭建集群"><a href="#2-3-Elasticsearch本地快速搭建集群" class="headerlink" title="2.3 Elasticsearch本地快速搭建集群"></a>2.3 Elasticsearch本地快速搭建集群</h4><p>window下启动错误解决:<br><a href="https://blog.csdn.net/fanrenxiang/article/details/81358332" target="_blank" rel="external">https://blog.csdn.net/fanrenxiang/article/details/81358332</a>  </p>
<p>集群搭建按照下面图所示:启动3个服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/76.png" alt=""> </p>
<ol>
<li><p>1.启动默认的服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/77.png" alt=""> </p>
</li>
<li><p>2.启动第二个实例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/78.png" alt=""><br>查看集群:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/79.png" alt="">  </p>
</li>
<li><p>3.启动第3个实例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/80.png" alt=""> </p>
</li>
</ol>
<h4 id="2-4-Kibana安装与演示"><a href="#2-4-Kibana安装与演示" class="headerlink" title="2.4 Kibana安装与演示"></a>2.4 Kibana安装与演示</h4><p>Kibana是使用node.js开发的产品。<br>同样在<a href="https://www.elastic.co/cn/里面的产品--&gt;Kibana--&gt;下载--&gt;Download" target="_blank" rel="external">https://www.elastic.co/cn/里面的产品--&gt;Kibana--&gt;下载--&gt;Download</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/83.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/84.png" alt=""><br>注意:需要进入kibana.yml文件，然后修改里面的Elasticsearch的地址指向:<br>1.Open config/kibana.yml in an editor<br>2.Set elasticsearch.hosts to point at your Elasticsearch instance</p>
<p>然后访问：<a href="http://localhost:5601" target="_blank" rel="external">http://localhost:5601</a></p>
<h4 id="2-5-Kibana配置详解"><a href="#2-5-Kibana配置详解" class="headerlink" title="2.5 Kibana配置详解"></a>2.5 Kibana配置详解</h4><p>Kibana的配置详解<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/85.png" alt=""><br>Kibana常用功能说明<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/86.png" alt="">  </p>
<h4 id="2-6-Elasticsearch术语介绍与CRUD实际操作"><a href="#2-6-Elasticsearch术语介绍与CRUD实际操作" class="headerlink" title="2.6 Elasticsearch术语介绍与CRUD实际操作"></a>2.6 Elasticsearch术语介绍与CRUD实际操作</h4><h5 id="2-6-1-Elasticsearch常用术语"><a href="#2-6-1-Elasticsearch常用术语" class="headerlink" title="2.6.1 Elasticsearch常用术语"></a>2.6.1 Elasticsearch常用术语</h5><ol>
<li>1.Document文档数据、既然是数据、可以理解成数据表里面的一条数据。</li>
<li>2.Index 索引 可以理解成:数据库。所有document都是存在于Index数据中的。    </li>
<li>3.Type索引中的数据类型。可以理解成数据库中的一个表</li>
<li>4.Field字段、文档的属性。类似于mysql中的字段。</li>
<li>5.Query DSL查询语句。</li>
</ol>
<h5 id="2-6-2-Elasticsearch的CRUD"><a href="#2-6-2-Elasticsearch的CRUD" class="headerlink" title="2.6.2 Elasticsearch的CRUD"></a>2.6.2 Elasticsearch的CRUD</h5><p>CRUD其实就是数据的增删改查,这里面的数据就是文档，所以CRUD只是对文档的操作。  </p>
<ol>
<li>1.Create 创建文档  </li>
<li>2.Read 读取文档  </li>
<li>3.Update 更新文档  </li>
<li>4.Delete 删除文档  </li>
</ol>
<p>我们在Index(accounts)下创建一个type(person)文档id为1  文档内容就是下面的左图json格式。右边是一个创建文档后返回的内容。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/87.png" alt=""> </p>
<p>我们需要实际操作的话,只需要在Kibanna的Dev Tools下的console中输入一下内容。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/88.png" alt=""><br>上面文档就算插入成功了，文档插入成功之后、我们需要获取这个文档也就是读取文档：read<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/89.png" alt=""> </p>
<p>更新<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/90.png" alt=""> </p>
<p>删除<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/91.png" alt="">  </p>
<h4 id="2-7-Elasticsearch查询简介"><a href="#2-7-Elasticsearch查询简介" class="headerlink" title="2.7 Elasticsearch查询简介"></a>2.7 Elasticsearch查询简介</h4><ol>
<li><p>1.查询的基本语法<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/92.png" alt="">  </p>
</li>
<li><p>2.查询实例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/93.png" alt="">  </p>
</li>
<li><p>3.在官方文档可以查看到详细的语法<br>进入官网–&gt;lean(了解)–&gt;doc(文档) –&gt;Elasticsearch Reference–&gt;Query DSL</p>
</li>
</ol>
<h3 id="3-Beats、Filebea入门"><a href="#3-Beats、Filebea入门" class="headerlink" title="3.Beats、Filebea入门"></a>3.Beats、Filebea入门</h3><h4 id="3-1-Beats简介"><a href="#3-1-Beats简介" class="headerlink" title="3.1 Beats简介"></a>3.1 Beats简介</h4><p>Beats定义:Lightweight Data Shipper(官方定义为:轻量级的数据传送者)。官方目前有下面几个beats。</p>
<ol>
<li>1.Filebeat—主要针对日志文件  </li>
<li>2.Metricbeat—主要收集：像操作系统、CPU、内存、磁盘、还有像常用软件:nginx、Mysql的度量指标。Metricbeat能很快收集这些度量指标、然后很快的放入es中进行可视化分析、展示、告警。</li>
<li>3.Packetbeat—网络数据(比如服务器传输情况)   </li>
<li>4.Winlogbeat Window 数据—Window的日志数据。</li>
<li>5.Heartbeat—健康检查<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/94.png" alt=""><br>如上图我们知道：Beat处于数据的起始端、他们可以将数据直接存储到Elasticsearch中、也可以传输到logstash,然后logstash通过分析或者转换把数据传送到Elasticsearch中、最后通过Kibana对数据进行展示。</li>
</ol>
<h4 id="3-2Filebeat简介"><a href="#3-2Filebeat简介" class="headerlink" title="3.2Filebeat简介"></a>3.2Filebeat简介</h4><p>Filebeat主要是对日志文件进行处理的，如下为处理流程:<br>Filebeat输入日志文件、拿到日志文件后进行简单处理(Filter)、然后输出OutPut</p>
<p>我们用以下图查看Filebeat的构成:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/95.png" alt="">  </p>
<ol>
<li>1.左边是Filebeat,右边是Filebeat的输出对象。我们可以看到输出对象有:Elasticsearch、Logstash、Kafka、Redis</li>
<li>2.从左边可以看到Filebeat包含两个部分：Prospect(观察者)和Harvester(收割者)<br>Prospect针对/var/log/*.log文件可以探测其文件是否有变化、如果有变化  Harvester就需要收集新的日志。将日志从每一个日志文件中取出来、然后发送到output对象。</li>
<li>3.一个Filebeat可以有多个Prospect(观察者)和Harvester(收割者)、上面的Prospect(观察者)和Harvester(收割者)针对的日志文件是不同”的。</li>
<li>4.Prospect(观察者)针对于不同的配置文件(system.log和wifi.log)会启动多个Harvester。也就是一个Harvester针对于一个配置文件。</li>
</ol>
<h4 id="3-3-Filebeat配置简介"><a href="#3-3-Filebeat配置简介" class="headerlink" title="3.3 Filebeat配置简介"></a>3.3 Filebeat配置简介</h4><h5 id="3-3-1-Filebeat-Input配置简介"><a href="#3-3-1-Filebeat-Input配置简介" class="headerlink" title="3.3.1 Filebeat Input配置简介"></a>3.3.1 Filebeat Input配置简介</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/96.png" alt=""> </p>
<ol>
<li>2.使用yml语法、跟之前elasticsearch一致。  </li>
<li>2.Filebeat其中一个组成是Prospect、在其配置文件中有一个Prospect配置。  </li>
<li>3.之前说了Prospect是不止一个的、可以配置多个。所以是个数组。yml的数组格式使用”-“隔离的。上图是配置了两个Prospect</li>
<li>4每一个Prospect有自己的输入类型、这里是log、说明是配置文件。paths也是一个数组、用于指定日志的路径的。</li>
<li>5.目前input_type有两个类型:一个是log、另一个是stdin(标准输入)</li>
</ol>
<h5 id="3-3-2-Filebeat-Output配置简介"><a href="#3-3-2-Filebeat-Output配置简介" class="headerlink" title="3.3.2 Filebeat Output配置简介"></a>3.3.2 Filebeat Output配置简介</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/97.png" alt=""></p>
<ol>
<li>1.Filebeat Output支持以下类型对象:Console(标准输出)、Elasticsearch、Logstash、Kafka、Redis、File(指把一个日志文件输出到另一个日志文件中)。</li>
</ol>
<h5 id="3-3-3-Filebeat-Filter配置简介"><a href="#3-3-3-Filebeat-Filter配置简介" class="headerlink" title="3.3.3 Filebeat Filter配置简介"></a>3.3.3 Filebeat Filter配置简介</h5><p>对读入的内容进行一定的处理、当然他的处理能力相对较弱。例如:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/98.png" alt=""><br>例子:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/99.png" alt=""></p>
<h4 id="3-4Filebeat高级使用简介"><a href="#3-4Filebeat高级使用简介" class="headerlink" title="3.4Filebeat高级使用简介"></a>3.4Filebeat高级使用简介</h4><ol>
<li><p>1.从上面我们知道Filebea缺乏数据转换的能力。针对于这个问题，Elasticsearch增加了一个Node类型、Elasticsearch Ingest Node<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/100.png" alt=""></p>
</li>
<li><p>2.Filebeat Module简介:Filebeat本身想把数据快速存放到Elasticsearch中大致要做一些处理，首先要写合适的Filebeat配置文件。然后去配置Ingest Node中的pipeline、然后对存储的数据进行kibana的合理的可视化配置。Filebeat看到了这些数据做起来是比较复杂的。所以官方推出了一些模块、把常用的日志格式做了统一化的处理达到开箱急用的配置。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/101.png" alt=""></p>
</li>
</ol>
<h4 id="3-5-Filebeat演示"><a href="#3-5-Filebeat演示" class="headerlink" title="3.5 Filebeat演示"></a>3.5 Filebeat演示</h4><p>实际演示Filebeat收集nginx log<br>1.我们通过stdin收集日志。<br>2.通过console输出结果。  </p>
<p>实践  </p>
<ol>
<li>1.下载Filebeat(Filebeat是基于go开发、需要下载不同的安装包)  </li>
<li><p>2.查看我们需要收集的nginx日志<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/102.png" alt="">  </p>
</li>
<li><p>3.配置我们的filebeat<br>a.input_type: stdin (我们从标准输入流获取数据)<br>b.output.console: pretty: true  </p>
</li>
<li><p>4.接下来用filebeat:收集nginx的两条数据<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/103.png" alt="">  </p>
</li>
<li><p>5.最后获取到的信息是:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/104.png" alt="">  </p>
</li>
</ol>
<h4 id="3-6-Packetbeat简介"><a href="#3-6-Packetbeat简介" class="headerlink" title="3.6 Packetbeat简介"></a>3.6 Packetbeat简介</h4><h5 id="3-6-1-简介"><a href="#3-6-1-简介" class="headerlink" title="3.6.1 简介"></a>3.6.1 简介</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/105.png" alt=""><br>拥有了Packetbeat类似于就拥有了轻量级的wireshake<br>1.实时抓取网络包<br>2.自动解析应用层协议  </p>
<h5 id="3-6-2-demo抓取es的网络数据包"><a href="#3-6-2-demo抓取es的网络数据包" class="headerlink" title="3.6.2 demo抓取es的网络数据包"></a>3.6.2 demo抓取es的网络数据包</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/106.png" alt="">  </p>
<p>1 1.指定网卡:lo0  </p>
<ol>
<li>2.protocols:指定协议  </li>
<li>3.ports:指定端口  </li>
<li>4.send_request:true 指定request请求的body,默认为false   </li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/107.png" alt="">  </p>
<h4 id="3-7-Packetbeat演示"><a href="#3-7-Packetbeat演示" class="headerlink" title="3.7 Packetbeat演示"></a>3.7 Packetbeat演示</h4><ol>
<li>1.下载包  </li>
<li>2.我们抓取es的包、首先我们把es跑起来  </li>
<li>3.检查配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/108.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/109.png" alt="">  </li>
<li><p>4.运行paketbeat：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/110.png" alt="">  </p>
</li>
<li><p>5.查看paketbeat输出<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/111.png" alt="">  </p>
</li>
</ol>
<h3 id="4、Logstash入门"><a href="#4、Logstash入门" class="headerlink" title="4、Logstash入门"></a>4、Logstash入门</h3><h4 id="4-1-Logstash简介"><a href="#4-1-Logstash简介" class="headerlink" title="4.1 Logstash简介"></a>4.1 Logstash简介</h4><ol>
<li>1.Logstash定义为一个:Data Shipper、他比Beats的定义少了一个light-weight<br>也就是说Logstash不是轻量级的、会比Beats占用更多的资源。所以会占用一定的资源、当然功能 也会越强大。</li>
<li><p>2.Logstash其实就是具备ETL的功能、对数据进行以下操作:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/112.png" alt="">  </p>
</li>
<li><p>3.处理流程(其实就是3步:input、Filter、Output)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/113.png" alt="">  </p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/24/ElasticStack-2-入门/" class="archive-article-date">
  	<time datetime="2019-06-24T15:47:55.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ElasticStack/">ElasticStack</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ElasticStack-1-前言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/24/ElasticStack-1-前言/">ElasticStack-1-前言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-为什么使用ElasticStack"><a href="#1-为什么使用ElasticStack" class="headerlink" title="1.为什么使用ElasticStack"></a>1.为什么使用ElasticStack</h4><p>我们知道的一般大数据分析工具有如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/57.png" alt=""><br>我们为什么还需要使用ElasticStack呢?<br>原因:  </p>
<ol>
<li>1.使用门槛低、开发周期短、上线快<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/58.png" alt="">  </li>
<li>2.性能好、查询快、实时展示结果<br>对T+1说不，以前我们查询数据结果，都是时隔一段时间或者一天再分析，现在我们需要”现在、立刻马上要数据”  </li>
<li><p>3.扩容方便、快速支撑增长迅猛的数据<br>刚开始也许只是GB数据、随着业务量变大、TB、PB级别的数据也不是问题。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/59.png" alt=""> </p>
<h4 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h4><h5 id="2-1-ElasticStack组成"><a href="#2-1-ElasticStack组成" class="headerlink" title="2.1 ElasticStack组成"></a>2.1 ElasticStack组成</h5><p>传统的ELK其实就是:Elasticsearch、Logstash、Kibana，自从加入了Beats后,进行升级，变成了Elastic Stack。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/60.png" alt="">   </p>
<h5 id="2-2-各个模块功能"><a href="#2-2-各个模块功能" class="headerlink" title="2.2 各个模块功能"></a>2.2 各个模块功能</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/61.png" alt="">  </p>
</li>
<li><p>1.Elasticsearch主要是做数据处理的  </p>
</li>
<li>2.Beats和    Logstash是做数据收集与处理，相当于早期的ETL<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/62.png" alt=""></li>
<li>3.Kibna数据搜索与可视化分析<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/63.png" alt=""></li>
</ol>
<h5 id="2-3-ElasticStack功能"><a href="#2-3-ElasticStack功能" class="headerlink" title="2.3 ElasticStack功能"></a>2.3 ElasticStack功能</h5><p>一定要内外兼修、不仅仅会使用API还得了解原理。  </p>
<ol>
<li>1.ElasticStack是一个完备的数据分析工具集合<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/64.png" alt=""></li>
<li>2.学习安排:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/65.png" alt="">  </li>
<li><p>3.Elasticsearch篇章讲解举例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/66.png" alt="">  </p>
</li>
<li><p>4.实践项目<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/67.png" alt=""> </p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/24/ElasticStack-1-前言/" class="archive-article-date">
  	<time datetime="2019-06-24T14:40:53.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ElasticStack/">ElasticStack</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-7-服务网管" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/15/SpringCloud-7-服务网管/">SpringCloud-7-服务网管</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-服务网关和Zuul"><a href="#1-服务网关和Zuul" class="headerlink" title="1.服务网关和Zuul"></a>1.服务网关和Zuul</h3><h4 id="1-1-为什么需要服务网关"><a href="#1-1-为什么需要服务网关" class="headerlink" title="1.1 为什么需要服务网关"></a>1.1 为什么需要服务网关</h4><p>加入没有网关服务,当前系统起了多个服务,比如：订单、广告、商品、支付、用户。等等…<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/38.png" target="_blank" rel="external"></a> </p>
<p>那么客户端怎么调用呢?和每个服务一步步打交道、显然不现实。需要一个接收request请求的统一入口。充当这个角色的是服务网关。一旦有了服务网关,所有请求都通过他,所以我们需要了解他发挥什么作用,具备什么要素?<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/39.png" target="_blank" rel="external"></a></p>
<h4 id="1-2-服务网关的作用"><a href="#1-2-服务网关的作用" class="headerlink" title="1.2 服务网关的作用"></a>1.2 服务网关的作用</h4><h5 id="1-稳定性、高可用"><a href="#1-稳定性、高可用" class="headerlink" title="1.稳定性、高可用"></a>1.稳定性、高可用</h5><p>保证24小时可用,网络瘫痪、系统全挂、不能提供外面的服务。 </p>
<h5 id="2-性能、并发性"><a href="#2-性能、并发性" class="headerlink" title="2.性能、并发性"></a>2.性能、并发性</h5><p>所有的请求都经过网关、所以网关的压力是巨大的、所以网关的性能也必须高。</p>
<h5 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3.安全性"></a>3.安全性</h5><p>要确保使用服务的安全、防止外部随意访问、比如金融行业、会进行通讯数据的加密措施。</p>
<h5 id="4-扩展性"><a href="#4-扩展性" class="headerlink" title="4.扩展性"></a>4.扩展性</h5><p>各种请求都经过网关服务、所以网关上大有文章可做、可进行扩展。<br>理论上、网关是处理各种非业务功能的绝佳场所。诸如:协议转发、防刷、流量管控、日志监控等。</p>
<h4 id="1-3-常用的网关方案"><a href="#1-3-常用的网关方案" class="headerlink" title="1.3 常用的网关方案"></a>1.3 常用的网关方案</h4><p>网关并非是微服务出来后的新鲜事物。业界成熟的网关服务有:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/40.png" target="_blank" rel="external"></a><br>一代的Zuul在性能上确实没有优势、不能喝nginx比较。当然，二代Zuul有较大的提升。</p>
<p>原始的点餐项目是如下:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/41.png" target="_blank" rel="external"></a></p>
<ol>
<li>1.nginx在前,tomcat在后、nginx做了负载均衡和反向代理。现在我们可以让nginx发挥他负载均衡和反向代理的优势后面的tomcat可以换成Zuul  </li>
<li>2.项目改造过程中、合理利用原来的资源、发挥新加入事物的优势、因地制宜解决问题。<h4 id="1-4-Zuul的特点"><a href="#1-4-Zuul的特点" class="headerlink" title="1.4 Zuul的特点"></a>1.4 Zuul的特点</h4>Zuul相对nginx来说有所不足、但是作为SpringCloud完整微服务生态体系的前置网关服务是一个很不错的选择。有一种说法路由加过滤器等于Zuul<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/42.png" target="_blank" rel="external"></a>  </li>
</ol>
<p><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/43.png" target="_blank" rel="external"></a><br>Zuul的组织架构图如下所示:<br>可以看到,过滤器之间是没有直接通信的,他们是通过Request Context进行数据通信的。<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/44.png" target="_blank" rel="external"></a>  </p>
<p>Zuul的一次Http的生命周期:</p>
<ol>
<li>1.Origin Server就是我们的业务服务。  </li>
<li>2.请求先过来之后会到pre filters这种类型的过滤器,比如我们的参数校验就可以在这里面来做。  </li>
<li>3.routing filters作用就是将http请求转发到Origin Server中去：如果重写http请求可以在这里面做。</li>
<li>4.post filters 这个时候你已经拿到了返回的结果,这个时候如果你想对结果进行处理和加工,可以在这里面来做</li>
<li>5.error Filters如果在前两个filter发生异常时候,就可以在error filter中进行全局异常处理。<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/45.png" target="_blank" rel="external"></a> </li>
</ol>
<h3 id="2-Zuul的使用"><a href="#2-Zuul的使用" class="headerlink" title="2.Zuul的使用"></a>2.Zuul的使用</h3><ol>
<li>1.新建项目api-gateway<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/46.png" target="_blank" rel="external"></a><br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/47.png" target="_blank" rel="external"></a> </li>
<li>2.选择依赖<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/48.png" target="_blank" rel="external"></a>   </li>
<li>3.删除不需要的文件<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/49.png" target="_blank" rel="external"></a>   </li>
<li>4.修改版本一致<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/50.png" target="_blank" rel="external"></a></li>
<li>5.修改配置文件(从统一配置文件中获取配置信息)<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/51.png" target="_blank" rel="external"></a></li>
</ol>
<h4 id="2-1-路由转发"><a href="#2-1-路由转发" class="headerlink" title="2.1 路由转发"></a>2.1 路由转发</h4><p>我们现在实现Zuul的路由转发功能,我们在api-gateway项目的启动类上添加:@EnableZuulProxy。我们现在要实现product服务下请求里面的/product/list</p>
<ol>
<li><p>1.启动我们的product服务(8081端口),然后访问:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/52.png" target="_blank" rel="external"></a>  </p>
</li>
<li><p>2.通过Zuul服务(8084端口)路由转发请求:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/53.png" target="_blank" rel="external"></a><br>只要注册到Eureka上的服务都可以通过:ip:port/服务名/url  </p>
</li>
</ol>
<ol>
<li><p>3.自定义Zuul路由转发地址<br>以上我们是通过默认的路由转发、默认的地址是:ip:port/服务名/url。但是有时候我们不想把服务名暴露出来 而是想用自己定义的路由地址。此时就需要配置Zuul了。<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/55.png" target="_blank" rel="external"></a><br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/54.png" target="_blank" rel="external"></a>  </p>
</li>
<li><p>4.查询Zuul的所有routes,我们可以通过Zuul对应的服务api-gateway启动地址:  </p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/15/SpringCloud-7-服务网管/" class="archive-article-date">
  	<time datetime="2019-06-15T03:01:28.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-6-消息和异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: SpringCloud-6-消息和异步<br>date: 2019-05-26 18:44:01<br>tags:</p>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title=" SpringCloud"></a> SpringCloud</h2><h3 id="1-异步和消息"><a href="#1-异步和消息" class="headerlink" title="1.异步和消息"></a>1.异步和消息</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><ol>
<li>1.之前我们使用的方式是同步方式。</li>
<li>2.异步优点:a.客户端请求不会阻塞进程、服务端的相应可以是非及时的。  </li>
<li>3.http常见是支持同步、但是http也是支持异步的。</li>
</ol>
<h4 id="2-异步的常见形态"><a href="#2-异步的常见形态" class="headerlink" title="2.异步的常见形态"></a>2.异步的常见形态</h4><ol>
<li>1.通知</li>
<li>2.请求/异步响应:客户端发送请求到服务端,服务端异步响应,客户端不会阻塞,服务端默认不会立马响应。    </li>
<li><p>3.消息</p>
<h4 id="3-MQ应用场景"><a href="#3-MQ应用场景" class="headerlink" title="3.MQ应用场景"></a>3.MQ应用场景</h4><p>MQ是分布式应用系统最常用的组件。典型应用场景有如下:</p>
</li>
<li><p>1.异步处理:用户注册之后,通过短信服务、积分服务去做他们相应的操作,这样就能提高用户体验。  </p>
</li>
<li>2.流量消峰:一般用于秒杀场景,秒杀过程中一般由于流量较大,会导致应用会挂掉、要解决这个问题。把请求放在消息队列中,如果超过消息队列的长度将抛弃此请求,返回错误信息。 </li>
<li>3.日志处理：这个典型的组件就是kafka，kafka最初的设计就是用于日志处理,大数据里面用的特别多。通过日志采集、定时写入kafka队列，然后kafka队列定时接收 储存 和转发。</li>
<li>应用解耦：比如用户下单后,订单服务需要通知商品服务、之前是订单服务通过调用商品服务的接口,这样订单服务和商品服务是耦合的。使用mq,用户下单后，订单服务完成持续化处理、将消息写入消息队列、返回用户订单下单成功、商品服务来订阅这个消息采用拉或者推形式获取下单信息、商品服务获取到下单信息后进行商品的扣库存等操作。这样达到应解耦。  </li>
</ol>
<h3 id="2-RabbitMQ的基本使用"><a href="#2-RabbitMQ的基本使用" class="headerlink" title="2.RabbitMQ的基本使用"></a>2.RabbitMQ的基本使用</h3><p>我们Order服务使用RabbitMQ实现订单和商品服务解耦。  </p>
<ol>
<li>1.添加热rabbitmq依赖<br>在order服务中server子模块添加以下依赖:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;!--引入RabbitMQ依赖--&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;  </div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line">2. 2.添加配置到github远程仓库  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/94.png)  </div><div class="line"></div><div class="line">3. 3.创建MQ消息接收方  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/95.png)  </div><div class="line"></div><div class="line">4. 4.创建mq发送方进行测试</div><div class="line">我们在测试test文件目录下创建测试类: </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/97.png)   </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/96.png) </div><div class="line"></div><div class="line">测试出现了上面问题,原因是因为没有myQueue队列  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/98.png) </div><div class="line">此时正常启动。  </div><div class="line"></div><div class="line">这个时候一切正常。  </div><div class="line"></div><div class="line">5. 5.以上是我们自己在RabbitMQ中创建的队列。我们是否可以自动创建队列,然后再调用队列接口。</div></pre></td></tr></table></figure>
<p> @RabbitListener(queuesToDeclare = @Queue(“myQueue1”)) //自动创建队列myQueue1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. 6.自动创建并且和队列绑定</div></pre></td></tr></table></figure></p>
<p>  @RabbitListener(bindings =@QueueBinding(value =@Queue(“myQueue”),exchange =@Exchange(“myExchange”)))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2.2 什么情况下需要用到exchange  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/1.png)</div><div class="line">我们现在是一个小小点餐系统,但是如果后面,我们什么都卖,又卖水果,又卖数码,同时对这两种商品下单,商品变多了,人也多了，订单服务是单独的人来维护,数码供应商、水果供应商都是由单独的人来维护。订单服务要根据不同的商品类型发出不同的MQ消息。相对应的、数码供应商只关注数码订单、水果及其他订单不关注。此时就牵涉到消息的分组。 演示如下:  </div><div class="line">1.我们接收方模拟两个接收服务(a.数码服务 b.水果服务)  </div><div class="line">exchange因为都是订单,我们我们叫做myOrder  </div><div class="line">想要分组归类,我们用key  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/2.png)</div><div class="line">2.我们发送方 (类似订单服务)如下: </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/3.png)  </div><div class="line"></div><div class="line"></div><div class="line">### 3.SpringCloudStream的使用 </div><div class="line">可以参数博客:https://www.cnblogs.com/zhixiang-org-cn/p/10093367.html </div><div class="line">#### 3.1.基本介绍  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/4.png)  </div><div class="line">1. 1.应用模型:应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream 中Binder 交互，通过我们配置来绑定，而 Spring Cloud Stream 的 Binder 负责与中间件交互。所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。  </div><div class="line">2. 2.抽象绑定器(The Binder Abstraction):Spring Cloud Stream实现Kafkat和RabbitMQ的Binder实现，也包括了一个TestSupportBinder，用于测试。你也可以写根据API去写自己的Binder.Spring Cloud Stream 同样使用了Spring boot的自动配置，并且抽象的Binder使Spring Cloud Stream的应用获得更好的灵活性，比如：我们可以在application.yml或application.properties中指定参数进行配置使用Kafka或者RabbitMQ，而无需修改我们的代码。  </div><div class="line"></div><div class="line">3. 3.Binder(SpringCloudStream)是应用程序(Application)和消息中间件(Middleware)之间的粘合剂，使用 SpringCloudStream最大的好处莫过于对消息中间件的进一步封装。可以做到代码层面对消息中间件的无感知,设置于动态的切换中间件,但是也有局限:目前SpringCloudStream仅支持2种Binder：一种是RabbitMQ、另一种是Kafka  </div><div class="line"></div><div class="line">#### 3.2.使用SpringCloudStream  </div><div class="line">为了详细了解SpringCloudStream的话,可以详细了解下:https://www.cnblogs.com/leeSmall/p/8900518.html这篇博文。  </div><div class="line">##### 1.引入依赖  </div><div class="line">在order-server.xml中添加如下依赖:</div></pre></td></tr></table></figure></p>
<p><dependency><br>   <groupid>org.springframework.cloud</groupid><br>   <artifactid>spring-cloud-starter-stream-rabbit</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">##### 2.添加mq的配置  </div><div class="line">之前我们已经配置过了,这里可以省略  </div><div class="line"></div><div class="line"></div><div class="line">##### 3.使用stream发送和接收消息  </div><div class="line">1. 1.定义接口:提供输入输出接口</div></pre></td></tr></table></figure></p>
<p>public interface StreamClient {</p>
<pre><code>@Input(&quot;myMessage&quot;)
SubscribableChannel input();

@Input(&quot;myMessage&quot;)
MessageChannel output();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 2.添加stream接收端</div></pre></td></tr></table></figure></p>
<p>@Component<br>@EnableBinding(StreamClient.class)<br>@Slf4j<br>public class StreamReceiver {<br>   @StreamListener(“myMessage”)<br>    public void process(Object message){<br>      log.info(“StreamReceiver:{}”,message);<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 3.添加stream发送端</div></pre></td></tr></table></figure></p>
<p>@RestController<br>public class SendMessageController {<br>    @Autowired<br>    private StreamClient streamClient;</p>
<pre><code>@GetMapping(&quot;/sendMessage&quot;)
public void process(){
    String message = &quot;now &quot; + new Date();
    streamClient.output().send(MessageBuilder.withPayload(message).build());
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">4. 4.测试  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/5.png)   </div><div class="line">有时候我们后端启用2个order服务,然后重启后 客户端发送消息,发现2个都接收到了,那么我们如何多集群情况下,只有一个实例接收消息呢?</div><div class="line">stream里面有个分组,我们配置一下就可以了 那就是使用分组。   </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/10.png)</div><div class="line"></div><div class="line"></div><div class="line">##### 3.使用stream传递对象  </div><div class="line">之前我们在用例中stream传递的是String、实际工作中stream更重要的是传递对象。</div><div class="line">生产者:发送OrderDetail对象  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/11.png)  </div><div class="line"></div><div class="line">消息接受者:  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/12.png)  </div><div class="line"></div><div class="line">下面我们看一下:mq里面接收的是什么格式数据呢?  </div><div class="line">我们在上面看不到消息了,原因是消息已经被消费完了,所以我们需要把接收端,消费消息的停掉。让mq端有消息的累计。</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/13.png)   </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/14.png)   </div><div class="line"></div><div class="line">上面我们可以看到消息是:OrderDTO对象,如果我们需要在MQ中获取的消息是json格式:则在stream的配置中添加：content-type: application/json  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/16.png)    </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/15.png)    </div><div class="line"></div><div class="line">有时候我们的消费者：StreamReceiver消费完消息之后,我们需要给发送者一个通知,传统的做法是在业务逻辑里面后面做处理。  </div><div class="line">现在我们加上注解即可:  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/17.png)  </div><div class="line"></div><div class="line">总结:使用Stream可以降低对消息中间件的复杂度,让开发者更多的关注业务开发。  </div><div class="line"></div><div class="line"></div><div class="line">### 4.商品和订单服务中使用MQ  </div><div class="line">#### 4.1 引言  </div><div class="line">我们结合点餐业务来使用mq</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/18.png)  </div><div class="line">1. 1.之前我们按照上面图提示到:一旦有库存的变化(商品)、都会发布一个消息、订单拿到这个消息之后,会把库存的消息记录到自己的服务里面(这里我们把他记录到redis里面)</div><div class="line">2. 2.导致库存的变化有很多种:a.第一次商品上线的时候,会填写库存,这个时候库存就变化了。b.还有就是货物快卖完的时候需要补货。相当于加库存。我们以扣库存为例,使用消息队列进行通信。</div><div class="line"></div><div class="line">#### 4.2 product服务接入到配置中心  </div><div class="line">1. 1.添加配置中心的依赖  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/19.png)  </div><div class="line">2. 2.修改appliaction.yml文件为:bootstrap.yml文件,并修改其中的配置  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/21.png) </div><div class="line"></div><div class="line">3. 3.在github上建立对应的product-dev.yml文件,并将共有的信息拷贝到里面去  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/20.png) </div><div class="line">4. 4.在config服务中看是否可以访问到此配置文件。  </div><div class="line">5. 5.启动时候正常启动:说明我们已经把product服务接入到配置中心了。  </div><div class="line"></div><div class="line">#### 4.3 product服务在扣库存时候发送队列消息    </div><div class="line">1. 1.添加springBoot里面的amqp依赖  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/22.png) </div><div class="line"></div><div class="line">2. 2.在统一配置中心中添加mq的连接信息  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/23.png)  </div><div class="line"> </div><div class="line">#### 4.4 product服务在扣库存地方操作消息队列  </div><div class="line">我们在扣库存的service中添加扣库存(decreaseStock)后消息通知:  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/24.png)  </div><div class="line"></div><div class="line">然后我们使用postman测试:  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/25.png)  </div><div class="line">数据库里面的库存从33变成32,数据库扣除成功了</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/26.png)  </div><div class="line">但是我们登录mq的管理后端却发现没有对应的amqpTemplate的productInfo队列，</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/27.png)</div><div class="line">为什么没有这个队列呢?原因是因为我们压根就没有创建队列，只有在接收方添加注解:@RabbitListener注解才会自动创建，我们 上面只有发送方,所以我们先手动创建下:然后点几次发送,后面发现我们在消息队列中有了相应的消息:</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/28.png)</div><div class="line"></div><div class="line"></div><div class="line">以上就完成了消息的发送,现在消息已经从商品服务发送到消息队列里面了,接下来我们要在订单服务接收消息。</div><div class="line">在Order服务的message包下面添加接收消息:</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/29.png)  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/30.png)  </div><div class="line"></div><div class="line">我们先删除之前的productInfo队列,然后重启服务会发现会自动创建队列  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/31.png) </div><div class="line"></div><div class="line">#### 4.5 Order服务获取到扣库存信息存储到redis  </div><div class="line">我们order服务获取到了product服务发送的信息,现在需要把这些信息存储到redis中  </div><div class="line">redis可以使用docker安装、也可以使用自己免安装的版本  </div><div class="line"></div><div class="line">1. 1.项目中引入依赖(order-server中pom.xml)</div></pre></td></tr></table></figure></p>
<p><dependency><br>            <groupid>org.springframework.cloud</groupid><br>            <artifactid>spring-boot-starter-data-redis</artifactid><br>        </dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 2.配置redis里面的参数,在统一配置中心添加</div></pre></td></tr></table></figure></p>
<p>spring:<br>  redis:<br>    host: localhost<br>    port: 6379<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 3.书写存储到redis(使用StringRedisTemplate)  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/32.png) </div><div class="line"></div><div class="line">4. 4.postman测试</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/33.png) </div><div class="line"></div><div class="line">#### 4.6 残留的问题  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/34.png)  </div><div class="line">1. 1.从上面我们知道:扣库存是遍历了商品,然后操作数据库,再然后就是发送mq消息,假如decreaseStockInputList长度大于1,我们第一件商品扣库存之后、发送消息到mq,但是第二件商品报了异常,由于有事务,数据库会回滚,但是mq里面的消息不会回滚,所有有脏数据。</div><div class="line">2. 2.我们修改下,我们在数据库扣完库存之后再发mq消息  </div><div class="line">Product服务修改:</div></pre></td></tr></table></figure></p>
<p>@Override<br>    public void decreaseStock(List<decreasestockinput> decreaseStockInputList) {<br>        //1.获取到扣库存列表<br>        List<productinfo> productInfoList = decreaseStockProcess(decreaseStockInputList);<br>        //2.转换成ProductInfoOutput列表<br>        List<productinfooutput> productInfoOutputList = productInfoList.stream().map(e -&gt; {<br>            ProductInfoOutput output = new ProductInfoOutput();<br>            BeanUtils.copyProperties(e, output);<br>            return output;<br>        }).collect(Collectors.toList());<br>        //3.发送mq消息<br>        amqpTemplate.convertAndSend(“productInfo”, JsonUtil.toJson(productInfoOutputList));<br>    }</productinfooutput></productinfo></decreasestockinput></p>
<pre><code>@Transactional(rollbackFor = Exception.class)
public List&lt;ProductInfo&gt;  decreaseStockProcess(List&lt;DecreaseStockInput&gt; decreaseStockInputList) {
    /**
     * 遍历:查看是否存在
     */
    List&lt;ProductInfo&gt; productInfoList = new ArrayList&lt;&gt;();
    for (DecreaseStockInput cartDTO:decreaseStockInputList){
        Optional&lt;ProductInfo&gt; productInfoOptional = repository.findById(cartDTO.getProductId());
        //商品不存在
        if(!productInfoOptional.isPresent()){
            throw new ProductException(ResultEnum.PRODUCT_NOT_EXIST);
        }
        //商品存在-库存错误
        ProductInfo productInfo = productInfoOptional.get();
        int result = productInfo.getProductStock() - cartDTO.getProductQuantity();
        if(result&lt;0){
            throw new ProductException(ResultEnum.PRODUCT_STOCK_ERROE);
        }
        //保存
        productInfo.setProductStock(result);
        repository.save(productInfo);
        productInfoList.add(productInfo);
    }
    return productInfoList;
}
</code></pre><p>```</p>
<p>Order服务修改:<br>JsonUtil添加如下方法:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/35.png" target="_blank" rel="external"></a>  </p>
<h3 id="5-异步和库存分析"><a href="#5-异步和库存分析" class="headerlink" title="5.异步和库存分析"></a>5.异步和库存分析</h3><p>项目改造成异步后,数据一致性等问题是经常遇到的,很多时候在单体服务中,依靠本地事务,我们很容易保证数据的一致性。但是一旦切换到分布式异步情况下就很可能出现数据不一致的情况。比如这里的发消息,数据库回滚数据是自动的。消息多发了要怎么办？这个就需要重新仔细考虑,稍不留神机会出错。下面我们以下面通路进一步看下更多考虑的点。<br>参考一下链接:<a href="https://cloud.tencent.com/developer/article/1344252" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1344252</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/26/SpringCloud-6-消息和异步/" class="archive-article-date">
  	<time datetime="2019-05-26T10:44:01.572Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-26</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-5-统一配置中心" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: SpringCloud-5-统一配置中心<br>date: 2019-05-21 22:42:12<br>tags:</p>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title=" SpringCloud"></a> SpringCloud</h2><h3 id="1-统一配置中心概述"><a href="#1-统一配置中心概述" class="headerlink" title="1.统一配置中心概述"></a>1.统一配置中心概述</h3><h4 id="1-1-为什么需要统一配置中心"><a href="#1-1-为什么需要统一配置中心" class="headerlink" title="1.1 为什么需要统一配置中心"></a>1.1 为什么需要统一配置中心</h4><p>之前我们写的order微服务和product微服务其实是不足的,有以下几个原因:  </p>
<ol>
<li>1.不方便维护:(每个人负责单独的模块,有一个人把配置修改后,push到远程,然后另一个人pull后修改代码,测试相同功能,此时配置文件已经改的面目全非了。)</li>
<li>2.配置内容安全与权限:一个公司线上的配置不会对开发者进行开发公开的,特别熟数据库账号密码,按理说只有运维才知道。我们需要把数据库信息隔离,不放到数据库密码里面去。  </li>
<li>3.更新配置项目需重启:每次更新项目都要重启,线上有可能修改一些配置,比如更改项目发送短信接口次数，我们怎样做到不重启。</li>
</ol>
<h4 id="1-2-统一配置中心"><a href="#1-2-统一配置中心" class="headerlink" title="1.2 统一配置中心"></a>1.2 统一配置中心</h4><p>我们到时候会专门做一个项目:config-server单独的微服务,他也有server端和client端。server端,这些配置我们为了方便管理都把他放到git上,这样子版本控制起来比较方便,他会从远端git把配置给拉取下来,以下图的箭头表示配置信息流的流动方向,最开始我们把他放到远端git,远端git的话,有gitlab,github，config-server把配置拉取下来之后,会把其配置放置到本地git上,注意config&lt;-&gt;本地git之前是双向流动的,他既会把远端git放到本地git去,也可以假如远端git不能使用了,被墙了,那么他会把本地的git拿出来，后面给product和order服务使用(两个服务都会集成config-server的客户端)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/38.png" alt="">  </p>
<h3 id="2-统一配置中心server端-config-server"><a href="#2-统一配置中心server端-config-server" class="headerlink" title="2.统一配置中心server端(config-server)"></a>2.统一配置中心server端(config-server)</h3><p>新建一个项目:</p>
<ol>
<li>1.Spring Initializr<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/39.png" alt=""></li>
<li>2.填写Project Metadata<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/40.png" alt="">  </li>
<li>3.添加依赖(本身是个微服务,需要注册到Eureka上去,所以添加Cloud Discovery中的Eureka Discovery和本身是一个配置类:作为config的server端 添加Cloud Config依赖)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/41.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/42.png" alt=""> </li>
<li>4.创建完毕之后,删除不必要的文件<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/43.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/44.png" alt=""> </li>
<li>5.更改pom使各个微服务版本号统一<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/45.png" alt="">  </li>
<li>6.在启动类中添加注解:将其注册到Eureka中去<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/46.png" alt=""> </li>
<li>7.修改其配置文件application.yml文件<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/47.png" alt="">  </li>
<li>8.启用Eureka服务,再启用config服务,一下出现config服务,说明启用成功。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/48.png" alt="">  </li>
<li>9.要成功config-server端,需要添加对应注解<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/49.png" alt=""><br>此时启动报错</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Caused by: java.lang.IllegalStateException: You need to configure a uri for the git repository</div></pre></td></tr></table></figure>
<p>我们在远程github仓库创建配置文件:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/50.png" alt=""><br>在远程仓库的config-repo下添加order服务的配置信息:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/51.png" alt=""></p>
<p>输入一下信息回车:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/52.png" alt=""><br>配置信息的username和password没有配置因为config-repo是公开仓库<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/53.png" alt=""></p>
<p>然后重启项目完之后,校验我们的配置文件是否被config-server从github仓库中拉取下来了。然后我们在浏览器输入：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/54.png" alt=""><br>为什么需要多写一个a呢?:<a href="http://localhost:8083/order-a.yml，http://localhost:8083/order-b.yml也是可以访问的,但是http://localhost:8083/order.yml不可以访问。" target="_blank" rel="external">http://localhost:8083/order-a.yml，http://localhost:8083/order-b.yml也是可以访问的,但是http://localhost:8083/order.yml不可以访问。</a><br>我们查看config-server启动时候的日志如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/55.png" alt=""><br>上面是支持properties,yml,json格式见转换的，如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/56.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/57.png" alt=""><br>具体的访问配置文件格式说明:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/58.png" alt="">  </p>
<p>查看config-server把远程的文件:order.yml拉取到了本地的哪个文件:如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/59.png" alt=""><br>当然我们自己也可以自定义这个配置文件路径:浏览器访问:<a href="http://localhost:8083/order-a.yml然后再配置的文件下" target="_blank" rel="external">http://localhost:8083/order-a.yml然后再配置的文件下</a>:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/60.png" alt=""><br>如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/61.png" alt="">  </p>
<h3 id="2-统一配置中心client端"><a href="#2-统一配置中心client端" class="headerlink" title="2.统一配置中心client端"></a>2.统一配置中心client端</h3><p>我们以order服务为例集成config-client,按理来说我们把order的全部配置已经放到git上了,不应该放在order的appliaction.yml文件中了,那我们要如何使用了?老套路来了。<br>1.引入依赖  2.启动类上不需要加注解  3.添加配置 </p>
<h4 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">```  </div><div class="line"></div><div class="line">#### 2.2 启动类上不需要加注解</div><div class="line">不加注解  </div><div class="line"></div><div class="line"></div><div class="line">#### 2.3 添加配置</div><div class="line">我们需要找到github上的通过config-server拉取到本地的一个配置，那么就需要服务名(配置文件中应用名)加开启环境(dev)找到此配置。  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/65.png)  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/66.png)  </div><div class="line"></div><div class="line">启动应用:报错:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/67.png)  </div><div class="line"></div><div class="line">思路:我们的期望启动流程是:1.通过配置文件的service-id:CONFIG找到，config-server,然后config-server把这些配置拉取到本地 2.order服务拿到配置之后才能进行数据库的初始化</div><div class="line"></div><div class="line">现在我们把所有信息都写在applaction.yml文件里面,SpringBoot项目不知道哪个在前,哪个在后面,他直接找数据库相关的,那么就启动失败了。  </div><div class="line"></div><div class="line">我们希望config-client的配置先加载,先启动。SpringBoot提供了bootstrap.yml(启动引导的文件)，我们把application..yml改成bootstrap.yml</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/68.png)  </div><div class="line"></div><div class="line">测试是否加载了order-dev.yml里面的配置信息:  </div><div class="line">我们看能不能拿去到env: dev信息  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/69.png)</div><div class="line">浏览器访问:http://localhost:8082/env/dev</div><div class="line">结果如下:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/70.png)  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 2.4 统一配置中心的高可用  </div><div class="line">关于统一配置中心的高可用,我们可以以后在服务器上部署多个,多个服务注册在EurekaServer时候,我们通过Order服务连接CONFIG自动可以实现负载均衡，下面我们以开启多个启动端口为例  </div><div class="line"></div><div class="line">1. 1.config-server配置多个启动类  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/71.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/72.png)  </div><div class="line">然后启用ConfigApplication、ConfigApplication(1)、ConfigApplication(2)三个应用。在EurekaServer端可以看到3个服务已经启动:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/73.png)  </div><div class="line"></div><div class="line">2. 2.我们多次启动Order服务,可以看到其连接的地址多次变动。  </div><div class="line">第一次启动出现:</div></pre></td></tr></table></figure>
<p>2019-05-25 16:38:58.471  INFO 11424 — [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : <a href="http://JSKJ-PC:9002/" target="_blank" rel="external">http://JSKJ-PC:9002/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">第二次启动出现：</div></pre></td></tr></table></figure></p>
<p>2019-05-25 16:40:01.977  INFO 10640 — [           main] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : <a href="http://JSKJ-PC:8083/" target="_blank" rel="external">http://JSKJ-PC:8083/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以看出他是获取的不同配置。  </div><div class="line"></div><div class="line">#### 2.5 统一配置中心和EurekaServer的注意点  </div><div class="line">Eureka注册中心默认的端口是8761,如果我们将8761改成8762，我们再来看一下情况。  </div><div class="line">1. 1.修改eureka注册中心的端口为:8762,重启   </div><div class="line">2. 2.修改config服务注册中心地址端口为:8762,重启  </div><div class="line">3. 3.修改config服务对应的远程配置文件的信息:打开http://localhost:8083/order-dev.yml发现配置中心的远程配置已经修改并加载到本地  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/74.png)  </div><div class="line"></div><div class="line">4. 4.启动Order服务,加载Order服务的配置  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/75.png)   </div><div class="line">我们发现我们的Oder服务已经连接不上config服务  </div><div class="line">这是什么原因呢?我们理一下流程:Order服务首先要做的其实首先是访问eureka,只有通过访问eureka,才能找到eureka下注册的config服务  </div><div class="line">现在是根本获取不到，获取不到的时候默认就会访问:http://localhost:8888,这是由于eureka地址没有配置对。但是我们不是在order-dev.yml中已经配置了这个地址吗?还是一个顺序的原因,之前8761之所以可以,是因为:8761是默认的一个地址。访问不到微服务就会默认访问8761注册中心,所以是没有问题的。所以当eureka不是默认端口:8761的是时候,我们把eureka的配置信息放到github远程配置上是不合理的。所以我们需要把这个配置拿出来放到Order服务里面的配置文件里面来,Order服务首先加载本地的bootstrap.yml,然后找到注册中心,从注册中心中找到config服务。</div><div class="line">做法:远程去掉eureka注册配置,将其保存到order服务的bootstrap.yml中。</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/76.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/77.png)  </div><div class="line"></div><div class="line">5. 5.在启动Order服务前,我们看一下config下访问的远程配置文件order-dev.yml文件是否已经已经加载到本地  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/74.png) </div><div class="line">发现配置信息并没有加载正确到本地,这个是为什么呢?我们先清空config的控制台,然后再浏览器端访问那个配置：http://localhost:8083/order-dev.yml。发现</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/78.png)  </div><div class="line">说明:会拿到两份配置,并会合并,我们之前的order.yml文件里面配置了eureka注册信息。这个时候是不是应该把order.yml删除了,其实不是的,既然,不管加载哪个配置都需要加载order.yml配置文件,那麽我们就应该把通用的配置信息加载到order.yml文件。这里我们先把order.yml文件里面信息先注释掉。</div><div class="line">然后重新访问就可以了。</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/79.png) </div><div class="line"></div><div class="line"></div><div class="line">#### 2.6 统一配置中心延伸</div><div class="line">我们想用统一配置中心的原因是:更新配置项目需重启,但是我们现在也没有达到。我们修改github上面的配置时候,我们还是没有变化。那么如何做到统一配置的的动态刷新呢?下节我们再学习。</div><div class="line"></div><div class="line"></div><div class="line">### 3.SpringCloud Bus自动刷新配置  </div><div class="line"></div><div class="line">#### 3.1 引言</div><div class="line">Bus就是想上就上的公共汽车。他还有信息通路,总线,这里就是总线的意思。  </div><div class="line">以下是之前统一配置的架构图:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/80.png)  </div><div class="line">我们修改远程git配置,order服务、product服务不会更新修改的配置,原因是我们修改远端git配置后没有及时通知order、product微服务。消息的传递需要载体-消息队列。消息的通知SpringCloud中推荐使用消息队列。要操作消息和操作数据库一样,肯定要使用组件、引入依赖。SpringCloud Bus就是用来操作消息队列的。config-server和order通过消息队列传递信息。config-server使用SpringCloud Bus之后会对外提供一个http接口叫做/bus-refresh,访问这个接口，config-server就会把远程git的配置信息发送到mq里面,那谁来访问这个接口呢?自然是远端git访问这个接口最合适。git服务器基本会提供WebHooks功能,你只要把web服务器配置上就好了。      </div><div class="line"></div><div class="line">#### 3.2 实战  </div><div class="line"></div><div class="line">##### 1.config服务配置  </div><div class="line">1. 1.修改config中pom.xml中SpringBoot版本  </div><div class="line">由于其他版本有bug,我们引入:2.0.0.BUILD-SNAPSHOT</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/81.png)  </div><div class="line">2. 2.引入SpringCloud Bus组件</div></pre></td></tr></table></figure></p>
<p><dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-bus-amqp</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">3. 3.启动config服务</div><div class="line">提前安装好RabbitMQ。</div><div class="line">安装请参考:  </div><div class="line">可以参考:http://www.chinacion.cn/article/1700.html  </div><div class="line">https://www.cnblogs.com/cvol/p/8818823.html  </div><div class="line">启动服务后我们登录RabbitMQ发现了以下队列。  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/82.png) </div><div class="line"></div><div class="line">##### 2.order服务配置 </div><div class="line">1. 1.引入Bus依赖</div></pre></td></tr></table></figure></p>
<p><dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-bus-amqp</artifactid><br></dependency><br>```  </p>
<ol>
<li>2.启动服务<br>启动服务我们发现了其他一个mq执行了<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/83.png" alt="">  </li>
</ol>
<h5 id="3-测试修改github上配置看config服务是否不重启可以获取到"><a href="#3-测试修改github上配置看config服务是否不重启可以获取到" class="headerlink" title="3.测试修改github上配置看config服务是否不重启可以获取到"></a>3.测试修改github上配置看config服务是否不重启可以获取到</h5><p>我们修改github上的order-dev.yml文件的env值为：dev11 然后刷新<a href="http://localhost:8083/order-dev.yml获取到的env为:dev111" target="_blank" rel="external">http://localhost:8083/order-dev.yml获取到的env为:dev111</a> 但是order服务获取到的值:<a href="http://localhost:8082/env/dev中的值还是dev。说明order服务动态获取不到远程修改的配置。" target="_blank" rel="external">http://localhost:8082/env/dev中的值还是dev。说明order服务动态获取不到远程修改的配置。</a></p>
<p>现在config服务和order服务都已经跟消息队列RabbitMQ打通了,还差的是访问config的http接口:/bus-refresh  </p>
<p>我们访问:发现报404错误,我们重启config发现重启日志中确实没有/bus-refresh的接口。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/84.png" alt=""> </p>
<p>解决,我们需要配置一下,让 /bus-refresh接口暴露出来。在config服务的application.yml文件中添加:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/85.png" alt=""><br>重启后我们发现有相关日志打出:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/86.png" alt=""> </p>
<p>我们使用postman请求一下:看对应的队列是否已经收到消息:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/87.png" alt=""> </p>
<p>然后再消息队列中查看下消息是否有:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/88.png" alt="">  </p>
<p>然后再刷新：<a href="http://localhost:8082/env/dev" target="_blank" rel="external">http://localhost:8082/env/dev</a><br>还是dev 为什么没有变成:dev111呢?<br>其实通过查看本地日志 发现order服务已经加载了此配置。  </p>
<p>这个时候我们通过注解@RequestScope实现<br>再次请求：<a href="http://localhost:8082/env/dev" target="_blank" rel="external">http://localhost:8082/env/dev</a>  发现已经变化了。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/89.png" alt="">  </p>
<h3 id="4-集成WebHooks实现动态更新"><a href="#4-集成WebHooks实现动态更新" class="headerlink" title="4.集成WebHooks实现动态更新"></a>4.集成WebHooks实现动态更新</h3><p>我们每次修改了github上的配置信息后,都需要在Order服务中通过http调用此接口才能让Order服务获取到对应的信息。我们现在需要把它做成自动实现。我们可以通过webhooks实现，</p>
<h4 id="4-1-github上绑定webhooks"><a href="#4-1-github上绑定webhooks" class="headerlink" title="4.1 github上绑定webhooks"></a>4.1 github上绑定webhooks</h4><p>在github上绑定对应的请求:<br>注意:github上配置url地址不是:<a href="http://yyv7tg.natappfree.cc/actuator/bus-refresh" target="_blank" rel="external">http://yyv7tg.natappfree.cc/actuator/bus-refresh</a><br>config组件专门提供了一个用于webhooks的路由,叫做monitor<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/90.png" alt=""></p>
<p>我们需要把config-server对应的本地服务映射到公网<br>我们使用ngrok  也可以使用natapp.cn:使用说明:<a href="https://blog.csdn.net/weixin_38959210/article/details/80401208" target="_blank" rel="external">https://blog.csdn.net/weixin_38959210/article/details/80401208</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/91.png" alt=""><br>我们在github上的webhooks更新地址:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/93.png" alt=""></p>
<p>修改远程的配置：env: dev11111<br>访问项目后:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/92.png" alt=""><br>说明成功。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/21/SpringCloud-5-统一配置中心/" class="archive-article-date">
  	<time datetime="2019-05-21T14:42:12.871Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-21</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-work-9-maven仓库包下载不下来" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/18/work-9-maven仓库包下载不下来/">work-9-maven仓库包下载不下来</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有时候,我们通过配置本地maven后发现对应的包下载不下来,可参考如下:<a href="https://www.jianshu.com/p/7861c6f2b517" target="_blank" rel="external">https://www.jianshu.com/p/7861c6f2b517</a>  </p>
<p>java对应的日志操作：<a href="https://blog.csdn.net/u010598111/article/details/80556437" target="_blank" rel="external">https://blog.csdn.net/u010598111/article/details/80556437</a>  </p>
<p><a href="https://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html" target="_blank" rel="external">https://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html</a></p>
<h4 id="2-SpringBoot2-x-整合druid-并将数据库密码加密"><a href="#2-SpringBoot2-x-整合druid-并将数据库密码加密" class="headerlink" title="2.SpringBoot2.x 整合druid,并将数据库密码加密"></a>2.SpringBoot2.x 整合druid,并将数据库密码加密</h4><p><a href="https://www.jianshu.com/p/7cf0ceb72f73" target="_blank" rel="external">https://www.jianshu.com/p/7cf0ceb72f73</a>  </p>
<p><a href="https://www.bywei.cn/post/782.html" target="_blank" rel="external">https://www.bywei.cn/post/782.html</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/18/work-9-maven仓库包下载不下来/" class="archive-article-date">
  	<time datetime="2019-05-18T11:14:37.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-18</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/work/">work</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ipcc-1-ipcc整体架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/ipcc-1-ipcc整体架构/">ipcc-1-ipcc整体架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ipcc总体架构模块"><a href="#ipcc总体架构模块" class="headerlink" title="ipcc总体架构模块"></a>ipcc总体架构模块</h3><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/37.png" alt=""> </p>
<h4 id="1-fsg模块"><a href="#1-fsg模块" class="headerlink" title="1.fsg模块"></a>1.fsg模块</h4><p>FSG模块作为:AG(CTI)和FS进行交互模块,其作用就是一个接口调用服务。<br>对应的配置文件是:/cc/cfg/fsg.cfg<br>对应的日志文件是:/cc/log/fsg<em>**</em>.log和/cc/bin/log/log*.log<br>其日志记录了ipcc内部和外部中继网络交互的日志详情。  </p>
<h5 id="1-1-fsg模块修改日志"><a href="#1-1-fsg模块修改日志" class="headerlink" title="1.1.fsg模块修改日志"></a>1.1.fsg模块修改日志</h5><p>有时候,我们为了排查和外部对接的错误信息时候,可以通过两种方式:<br>1.修改fsg的日志级别为6<br>2.通过tcpdump -w xx.cap抓包<br>以下为修改fsg的日志级别为6的设置  </p>
<h6 id="1-删除原来的fsg相关日志文件"><a href="#1-删除原来的fsg相关日志文件" class="headerlink" title="1.删除原来的fsg相关日志文件"></a>1.删除原来的fsg相关日志文件</h6><ol>
<li>删除/cc/bin/log文件目录下的文件  </li>
<li>删除/cc/log/fsg*.log文件  <h6 id="2-修改日志级别配置文件fsg-cfg"><a href="#2-修改日志级别配置文件fsg-cfg" class="headerlink" title="2.修改日志级别配置文件fsg.cfg"></a>2.修改日志级别配置文件fsg.cfg</h6></li>
<li>修改fsg.cfg里面SET下的日志级别文件为6<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/18.png" alt=""> </li>
</ol>
<h6 id="3-以写入文件的方式启动fsg-sh"><a href="#3-以写入文件的方式启动fsg-sh" class="headerlink" title="3.以写入文件的方式启动fsg.sh"></a>3.以写入文件的方式启动fsg.sh</h6><p>进入/cc/bin下输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fsg.sh restart &gt; /cc/bin/log/xxx.log</div></pre></td></tr></table></figure>
<h4 id="2-日志文件模块"><a href="#2-日志文件模块" class="headerlink" title="2.日志文件模块"></a>2.日志文件模块</h4><h5 id="2-1-查看和机器人交互日志"><a href="#2-1-查看和机器人交互日志" class="headerlink" title="2.1.查看和机器人交互日志"></a>2.1.查看和机器人交互日志</h5><p>和机器人交互日志都是通过ivr流程中http传数据,所以在httpg日志,需要看就提详细信息可以看dyflow日志</p>
<h5 id="2-2-查看任务加载-工作日-时间段-呼叫情况"><a href="#2-2-查看任务加载-工作日-时间段-呼叫情况" class="headerlink" title="2.2.查看任务加载,工作日,时间段,呼叫情况"></a>2.2.查看任务加载,工作日,时间段,呼叫情况</h5><ol>
<li>1.任务即是notify,但是任务在呼叫前任务加载,工作日,时间段都是在dbg_dbg01模块</li>
<li>2.查看任务呼叫情况:callnotify_callnotify01.log  </li>
<li>3.查看任务调用api模块:callnotify_callnotifyapi.log  </li>
<li>4.查看任务呼叫失败情况,没有数据插入到cti_cdr、ocm_result：查看callnotify_callnotifyfailsql.log  </li>
</ol>
<h4 id="3-ipcc对接其他server"><a href="#3-ipcc对接其他server" class="headerlink" title="3.ipcc对接其他server"></a>3.ipcc对接其他server</h4><p>参考:<a href="https://blog.csdn.net/gredn/article/details/40581871" target="_blank" rel="external">https://blog.csdn.net/gredn/article/details/40581871</a></p>
<h5 id="3-1-修改freeswitch配置"><a href="#3-1-修改freeswitch配置" class="headerlink" title="3.1 修改freeswitch配置"></a>3.1 修改freeswitch配置</h5><p>从平台架构我们知道,我们现在需要和外部第三方sipServer对接,首先需要打通各自的网络,然后就是配置相关的网管  </p>
<ol>
<li>1.进入freeswitch目录下freeswitch/conf/sip_profiles/external其中有外部网管模块。 拷贝存在的一个网关配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/62.png" alt="">  </li>
<li>2.修改gw3.xml中对接的外部sipServer地址和端口:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/63.png" alt=""> </li>
<li>3.重启freeswitch<br>进入freeswitch的bin目录停止fs:./freeswitch -stop<br>进入freeswitch的bin目录启动fs:./freeswitch -nc -nonat  </li>
</ol>
<h5 id="3-2-修改号码网管路由"><a href="#3-2-修改号码网管路由" class="headerlink" title="3.2 修改号码网管路由"></a>3.2 修改号码网管路由</h5><ol>
<li>1.修改cti_route表<br>打开数据库表cti_route配置主叫外显号码和网关对应的关系<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/64.png" alt=""> </li>
<li>2.重启fsg<br>进入/cc/bin目录下:执行:./fsg.sh restart  </li>
</ol>
<h5 id="3-3-使用抓包工具抓包"><a href="#3-3-使用抓包工具抓包" class="headerlink" title="3.3 使用抓包工具抓包"></a>3.3 使用抓包工具抓包</h5><p>对接完之后,如果电话不通,那么就需要使用wireshake进行网络抓包,分析包  </p>
<h4 id="4-ipcc对每个号码并发进行控制"><a href="#4-ipcc对每个号码并发进行控制" class="headerlink" title="4.ipcc对每个号码并发进行控制"></a>4.ipcc对每个号码并发进行控制</h4><p>在/cc/cfg/notify.cfg下的callnotify添加:examentline=1表明开启了号码并发设置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/6.png" alt="">  </p>
<h4 id="5-ipcc配置空号检测"><a href="#5-ipcc配置空号检测" class="headerlink" title="5.ipcc配置空号检测"></a>5.ipcc配置空号检测</h4><ol>
<li>1.首先正常安装并启用空号检测da2(安装数据库、程序)  </li>
<li>2.如果空号检测部署在一台服务器上，我们呼叫平台部署在多台服务器上，我们如何配置呢?  </li>
<li>3.查看/usr/local/freeswitch/conf下面文件:da2.json<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/7.png" alt="">  </li>
<li>4.重启freeswitch:进入freeswitch的bin目录:执行:./freeswitch -stop 再执行:./freeswitch -nc -nonat  </li>
<li>5.打开freeswitch客户端:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./fs_cli -P 8031 -p testtest</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/8.png" alt=""> </p>
<ol>
<li>6.在fs控制台客户端输入:da2 show<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/9.png" alt=""><br>出现上面问题说明成功,如果一直不成功检查对应数据库表  </li>
</ol>
<h4 id="6-ipcc中cdr关于服务"><a href="#6-ipcc中cdr关于服务" class="headerlink" title="6.ipcc中cdr关于服务"></a>6.ipcc中cdr关于服务</h4><ol>
<li>1.服务水平只对呼入而言的 呼出不用管  calltype=100 and dir=1  </li>
<li>2.starttime  connecttime和endtime 是整个电话的开始 接起和结束时间</li>
<li>3.workstarttime 是电话进入acd的时间  workconnect是坐席接起电话的时间 workendtime是坐席服务结束的时间 acmtime 在呼入的时候是坐席开始振铃时间（注意  在呼出的时候是用户振铃时间）</li>
<li>4.acmtime是服务水平的统计标志</li>
<li>5.用户呼叫系统的全部电话（呼入我们目前都要进入ivr ）：calltype&lt;300 and dir = 1 </li>
<li>6.坐席呼出用户的电话  calltype=100 || calltype=113||calltype=114  and dir=0</li>
<li>7.自动外呼呼出的电话   notifyid is not null</li>
<li>8.里面 connecttime  workconnecttime字段很重要 判断是否接通的依据</li>
<li>9.建议：现在数据除了cdr表外 通话数据 坐席数据 其实已经通过ice推送给ccms了、ccms能不能做一些文件存储 然后通过一些外部工具进行数据分析、毕竟cdr是生产上的 不能频繁访问、 ZeroC ICE提供一种打补丁方式，名为IcePatch2。基本功能就是通过ICE通讯将服务器上的最近软件部署到各个客户端中，这间接的实现了文件传输功能，</li>
</ol>
<h4 id="7-ipcc中任务呼叫失败原因"><a href="#7-ipcc中任务呼叫失败原因" class="headerlink" title="7.ipcc中任务呼叫失败原因"></a>7.ipcc中任务呼叫失败原因</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/81.png" alt="">  </p>
<h4 id="8-ipcc中任务脚本通知"><a href="#8-ipcc中任务脚本通知" class="headerlink" title="8.ipcc中任务脚本通知"></a>8.ipcc中任务脚本通知</h4><p>通过shell脚本的iniwrite和ice不能并存,如果用ice需要把iniwrite改成iniwrite1或者其他<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/82.png" alt=""> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/14/ipcc-1-ipcc整体架构/" class="archive-article-date">
  	<time datetime="2019-05-14T11:36:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ipcc/">ipcc</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-work-7-搭建配置nginx负载均衡服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/13/work-7-搭建配置nginx负载均衡服务器/">work-7-搭建配置nginx负载均衡服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考地址1:<a href="https://blog.csdn.net/u010395496/article/details/79921903" target="_blank" rel="external">https://blog.csdn.net/u010395496/article/details/79921903</a><br>参考地址2：<a href="https://blog.csdn.net/lao4j/article/details/80190703" target="_blank" rel="external">https://blog.csdn.net/lao4j/article/details/80190703</a><br>参考地址3(keepalived+nginx实现主备):<a href="https://wenku.baidu.com/view/31b8970d856a561253d36f86.html?from=search" target="_blank" rel="external">https://wenku.baidu.com/view/31b8970d856a561253d36f86.html?from=search</a><br>nginx实现负载均衡、热备、动静分离:<a href="https://blog.csdn.net/forever_2/article/details/79194788" target="_blank" rel="external">https://blog.csdn.net/forever_2/article/details/79194788</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/13/work-7-搭建配置nginx负载均衡服务器/" class="archive-article-date">
  	<time datetime="2019-05-13T03:51:58.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/work/">work</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-4-应用通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/18/SpringCloud-4-应用通信/">SpringCloud-4-应用通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-HTTP-vs-RPC"><a href="#1-HTTP-vs-RPC" class="headerlink" title="1.HTTP vs RPC"></a>1.HTTP vs RPC</h4><ol>
<li>应用(微服务)间通讯方式主要有两种:HTTP和RPC</li>
<li>两种方式的主角:RPC–Dubbo  HTTP–SpringCloud  </li>
<li>Dubbo定位始终是一个RPC远程调用框架,而SpringCloud是微服务下的一站式解决方式</li>
<li>SpringCloud微服务下服务调用使用的是:HTTP Restful,HTTP Restful本身轻量、适应性强、可以很容易跨语言跨平台。</li>
<li>SpringCloud中服务间两种restful调用方式:1. RestTemplate 2.Feign  </li>
</ol>
<h4 id="2-RestTemplate的三种使用方式"><a href="#2-RestTemplate的三种使用方式" class="headerlink" title="2.RestTemplate的三种使用方式"></a>2.RestTemplate的三种使用方式</h4><ol>
<li>1.RestTemplate是一个HTTP客户端,类似于HttpClient,功能差不多,但是用法上更加简单。  <h4 id="2-1-RestTemplate例子"><a href="#2-1-RestTemplate例子" class="headerlink" title="2.1 RestTemplate例子"></a>2.1 RestTemplate例子</h4></li>
<li>1.使用 “订单服务-&gt;商品服务”为例</li>
<li>2.订单服务调用商品服务,我们把商品服务当做server端,订单服务当做client端</li>
<li>3.为了不影响之前的代码逻辑,我们新建单独的包为例子。  </li>
<li>4.product端新建ServerController</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author yxm</div><div class="line"> * @date 2019/4/20 0:16:16</div><div class="line"> */</div><div class="line">@RestController</div><div class="line">public class ServerController &#123;</div><div class="line">    </div><div class="line">    @GetMapping(&quot;/msg&quot;)</div><div class="line">   public String msg()&#123;</div><div class="line">       return &quot;this is product server mmsg&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>5.order服务中新建ClientController<br>RestTemplate第一种方式  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author yxm</div><div class="line"> * @date 2019/4/20 0:18:18</div><div class="line"> */</div><div class="line">@RestController</div><div class="line">@Slf4j</div><div class="line">public class ClientController &#123;</div><div class="line"></div><div class="line">    @GetMapping(&quot;/getProductMsg&quot;)</div><div class="line">    public String getProductMsg()&#123;</div><div class="line">        //1.RestTemplate第一种方式 </div><div class="line">        RestTemplate restTemplate = new RestTemplate();</div><div class="line">        String response = restTemplate.getForObject(&quot;http://localhost:8080/msg&quot;, String.class);</div><div class="line">        log.info(&quot;response&#123;&#125;&quot;,response);</div><div class="line">        return response;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于product服务已经启用了8080端口,我们用-D指令在order服务中用-Dserver.port=8081,不建议直接写到配置文件。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/84.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png" alt=""><br>以上是第一种调用方式。缺点:1.url为固定写死的,上线时候部署多台服务器,有时候连部署到哪台服务器都不知道。2.对方可能启动了多个实例,如果写死到一台实现不了负载均衡,其他服务器就不能访问了。</p>
<ol>
<li>6.RestTemplate第二种方式  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@Slf4j</div><div class="line">public class ClientController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private LoadBalancerClient loadBalancerClient;</div><div class="line"></div><div class="line">    @GetMapping(&quot;/getProductMsg&quot;)</div><div class="line">    public String getProductMsg()&#123;</div><div class="line"></div><div class="line">        //2.第二种方式:通过LoadBalancerClient获取服务名,ip和port</div><div class="line">        /**</div><div class="line">         * SpringCloud提供了LoadBalancerClient,将其注入到Spring中</div><div class="line">         */</div><div class="line">        RestTemplate restTemplate = new RestTemplate();</div><div class="line">        ServiceInstance product = loadBalancerClient.choose(&quot;PRODUCT&quot;);</div><div class="line">        String url = String.format(&quot;http://%s:%s&quot;, product.getHost(), product.getPort());</div><div class="line">        String response = restTemplate.getForObject(url, String.class);</div><div class="line">        log.info(&quot;response&#123;&#125;&quot;,response);</div><div class="line">        return response;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">第二种方式每次都需要那么写(创建对象,获取ip,获取port,在调用获取),还是比较麻烦   </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png) </div><div class="line"></div><div class="line">7. 7.第三种方式</div></pre></td></tr></table></figure>
<p>@Component<br>public class RestTemplateConfig {<br>    @Bean<br>    @LoadBalanced<br>    public RestTemplate restTemplate(){<br>        return new RestTemplate();<br>    }<br>}</p>
<p>@RestController<br>@Slf4j<br>public class ClientController {<br>   @Autowired<br>   private RestTemplate restTemplate;</p>
<pre><code>@GetMapping(&quot;/getProductMsg&quot;)
public String getProductMsg(){
    //3.第三种方式:通过RestTemplate的配置加LoadBalancerClient注解
    String response = restTemplate.getForObject(&quot;http://PRODUCT/msg&quot;, String.class);
    log.info(&quot;response{}&quot;,response);
    return response;
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png) </div><div class="line"></div><div class="line"></div><div class="line">#### 3.负载均衡器Ribbion  </div><div class="line">1. 1.前面我们在说Eureka时候,谈到了服务端发现和客户端发现。Eureka属于客户端发现的方式,他的负载均衡是软负载,也就是客户端会向服务器(例如:EurekaServer)拉取已经注册的可用服务信息，然后根据负载均衡策略直接命中哪台服务器、发送请求。这整个过程都是在客户端完成的，并不需要服务端参数。SpringCloud中客户端负载均衡就是Ribbion  。他是基于NetflexRibbion实现的。通过SpringCloud的封装可以轻松的实现面向服务的restful模板请求自动转化成客户端负载均衡服务调用。</div><div class="line"></div><div class="line">一下组件都使用到了Ribbon:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/9.png) </div><div class="line"></div><div class="line">2. 2.SpringCloud在结合了Ribbon的负载均衡实现中,封装增加了HttpClient和OkHttp两种请求端实现,默认使用了Ribbon对Eureka服务发现的负载均衡client。</div><div class="line"></div><div class="line">3. 3.在上一节小结中,我们介绍了RestTemplate的三种实现方式。其中通过添加@LoadBalanced注解或者 直接写代码时候使用LoadBalancerClient,其实用到的就是Ribbon的组件</div><div class="line">4. 4.添加@LoadBalanced注解后,Ribbon会通过LoadBalancerClient自动的帮助你基于某种规则,比如:随机简单的轮训去连接目标服务,从而很容易使用Ribbon实现自定义的负载均衡算法。  </div><div class="line">5. 5.Ribbon实现负载均衡核心有3点:1.服务发现(也就是发现依赖服务的列表,也就是依据服务的名字,把该服务下的实例全都找出来)   2.服务选择规则(依据规则策略:如何从多个服务中选择一个有效的服务)  3.服务监听(监测失效服务做到高效剔除)  </div><div class="line">6. 6.主要组件是：ServerList、IRule、ServerListFilter。总体流程是:首先通过ServerList获取所有的可用服务列表。然后通过ServerListFilter过滤掉一部分地址，最后剩下的地址中通过IRule选择一个实例作为最终目标结果。</div><div class="line"></div><div class="line"></div><div class="line">#### 4 追踪源码自定义负载均衡策略</div><div class="line">略</div><div class="line">#### 5 Feign的使用</div><div class="line">##### 5.1 Feign的基本使用</div><div class="line">1. 1.本节使用Feign实现应用间通信。  </div><div class="line">2. 2.现在我们使用了Feign就不用使用restTemplate了,我们现在在ClientController中将restTemplate相关删除,并将RestTemplateConfig删除</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/10.png)</div><div class="line">3. 3.添加依赖:</div></pre></td></tr></table></figure>
<p><dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-feign</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/11.png)  </div><div class="line"></div><div class="line"></div><div class="line">4. 4.启动类中添加注解  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/12.png)  </div><div class="line">5. 5.定义好feign要调用的Server端接口  </div><div class="line">建立client包,定义一个ProductClient接口(里面的方法就是调用product服务的方法),此client代表order服务是一个相对于product的客户端服务。  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/13.png) </div><div class="line">product中ServerController里面调用的方法:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/14.png) </div><div class="line">6. 6.此接口定义完之后,在Controller里面定义,然后接口请求:http://localhost:8081/getProductMsg  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/15.png)  </div><div class="line"></div><div class="line">##### 5.2 Feign的总结  </div><div class="line">1. 声明式REST客户端(伪RPC)  </div><div class="line">2. 采用了基于接口的注解(定义一个接口,然后在其上加注解)  </div><div class="line">3. 内部使用了Ribbon作为负载均衡  </div><div class="line"></div><div class="line">#### 6 Feign获取商品列表  </div><div class="line">在Oder服务的OrderServiceImpl中的create里面1、2、3是我们还没有做的,这节我们需要通过Feign获取商品列表  </div><div class="line"></div><div class="line">##### 6.1 Product服务中添加获取商品列表  </div><div class="line"></div><div class="line">###### 1.Product--&gt;dao  </div><div class="line">ProductInfoRepository:</div></pre></td></tr></table></figure></p>
<p>public interface ProductInfoRepository extends JpaRepository<productinfo,string>{<br>     List<productinfo> findByProductStatus(Integer productStatus);</productinfo></productinfo,string></p>
<pre><code>List&lt;ProductInfo&gt; findByProductIdIn(List&lt;String&gt; productIdList);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">###### 2.Product--&gt;service</div><div class="line">ProductService:</div></pre></td></tr></table></figure></p>
<p>public interface ProductService {<br>    /**</p>
<pre><code> * 查询所有在架商品列表
 */
List&lt;ProductInfo&gt; findUpAll();
/**
 * 查询商品列表
 */
List&lt;ProductInfo&gt; findList(List&lt;String&gt; productIdList);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ProductServiceImpl:  </div><div class="line"></div><div class="line"></div><div class="line">```  </div><div class="line">@Service</div><div class="line">public class ProductServiceImpl implements ProductService &#123;</div><div class="line">    @Autowired</div><div class="line">    private ProductInfoRepository repository;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;ProductInfo&gt; findUpAll() &#123;</div><div class="line">        return repository.findByProductStatus(ProductStatusEnum.UP.getCode());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;ProductInfo&gt; findList(List&lt;String&gt; productIdList) &#123;</div><div class="line">        return repository.findByProductIdIn(productIdList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="3-Product–-gt-controller"><a href="#3-Product–-gt-controller" class="headerlink" title="3.Product–&gt;controller"></a>3.Product–&gt;controller</h6><p>ProductController:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@RequestMapping(&quot;/product&quot;)</div><div class="line">public class ProductController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProductService productService;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProductCategoryService productCategoryService;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取商品列表(给订单服务使用)</div><div class="line">     * @param productIdList</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @GetMapping(&quot;/listForOrder&quot;)</div><div class="line">    public List&lt;ProductInfo&gt; listForOrder(@RequestBody List&lt;String&gt; productIdList)&#123;</div><div class="line">        return productService.findList(productIdList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="6-2-Order服务中调用商品列表"><a href="#6-2-Order服务中调用商品列表" class="headerlink" title="6.2 Order服务中调用商品列表"></a>6.2 Order服务中调用商品列表</h5><p>在client的ProductClient添加调用product的方法  </p>
<h6 id="1-Order–-gt-ProductClient"><a href="#1-Order–-gt-ProductClient" class="headerlink" title="1.Order–&gt;ProductClient"></a>1.Order–&gt;ProductClient</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@FeignClient(name = &quot;product&quot;)</div><div class="line">public interface ProductClient &#123;</div><div class="line">    @GetMapping(&quot;/listForOrder&quot;)</div><div class="line">    List&lt;ProductInfo&gt; listForOrder(@RequestBody List&lt;String&gt; productIdList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="2-Order–-gt-ClientController"><a href="#2-Order–-gt-ClientController" class="headerlink" title="2.Order–&gt;ClientController"></a>2.Order–&gt;ClientController</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@Slf4j</div><div class="line">public class ClientController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProductClient productClient;</div><div class="line"></div><div class="line"></div><div class="line">    @GetMapping(&quot;/getProductMsg&quot;)</div><div class="line">    public String getProductMsg()&#123;</div><div class="line">        String msg = productClient.productMsg();</div><div class="line">        log.info(&quot;getProductMsg()&quot;,msg);</div><div class="line">        return msg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @GetMapping(&quot;/getProductList&quot;)</div><div class="line">    public String getProductList()&#123;</div><div class="line">        List&lt;ProductInfo&gt; productInfos = productClient.listForOrder(Arrays.asList(&quot;157875196366160022&quot;));</div><div class="line">        return &quot;ok&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="3-Order–-gt-请求测试"><a href="#3-Order–-gt-请求测试" class="headerlink" title="3.Order–&gt;请求测试"></a>3.Order–&gt;请求测试</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/16.png" alt="">  </p>
<h4 id="7-扣库存-Feign"><a href="#7-扣库存-Feign" class="headerlink" title="7.扣库存(Feign)"></a>7.扣库存(Feign)</h4><p>我们已经获取了商品列表,现在开始在Product微服务实现扣库存<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/17.png" alt=""><br>从创建订单接口我们知道,前端会传过来商品的信息和购买数量:我们在DTO中构造一个对象:CartDTO用来传送上面的对象  </p>
<ol>
<li>1.Product–&gt;CartDTO对象<br>新建DTO包,新建CartDTO类:  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class CartDTO &#123;</div><div class="line"> /**</div><div class="line">     * 商品id</div><div class="line">     */</div><div class="line">  private String productId;</div><div class="line">    /**</div><div class="line">     * 商品数量</div><div class="line">     */</div><div class="line">  private Integer productQuantity;</div><div class="line"></div><div class="line">  public CartDTO()&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  public CartDTO(String productId,Integer productQuantity)&#123;</div><div class="line">      this.productId = productId;</div><div class="line">      this.productQuantity = productQuantity;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>2.Product–&gt;Exception自定义异常  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class ProductException extends RuntimeException &#123;</div><div class="line">    private Integer code;</div><div class="line"></div><div class="line">    public ProductException(Integer code,String message)&#123;</div><div class="line">      super(message);</div><div class="line">      this.code =code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ProductException(ResultEnum resultEnum)&#123;</div><div class="line">           super(resultEnum.getMessage());</div><div class="line">           this.code = resultEnum.getCode();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>3.Product–&gt;返回枚举  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public enum ResultEnum &#123;</div><div class="line">    PRODUCT_NOT_EXIST(1,&quot;商品不存在&quot;),</div><div class="line">    PRODUCT_STOCK_ERROE(2,&quot;商品库存错误&quot; );</div><div class="line">    private Integer code;</div><div class="line">    private String message;</div><div class="line"></div><div class="line">    ResultEnum(Integer code, String message) &#123;</div><div class="line">        this.code = code;</div><div class="line">        this.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getMessage() &#123;</div><div class="line">        return message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMessage(String message) &#123;</div><div class="line">        this.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Integer getCode() &#123;</div><div class="line">        return code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCode(Integer code) &#123;</div><div class="line">        this.code = code;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>4.Product–&gt;Service里面新建方法  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">@Transactional(rollbackFor = Exception.class)</div><div class="line">public void decreaseStock(List&lt;CartDTO&gt; cartDTOList) &#123;</div><div class="line">    /**</div><div class="line">     * 遍历:查看是否存在</div><div class="line">     */</div><div class="line">    for (CartDTO cartDTO:cartDTOList)&#123;</div><div class="line">        Optional&lt;ProductInfo&gt; productInfoOptional = repository.findById(cartDTO.getProductId());</div><div class="line">        //商品不存在</div><div class="line">        if(!productInfoOptional.isPresent())&#123;</div><div class="line">         throw new ProductException(ResultEnum.PRODUCT_NOT_EXIST);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //商品存在-库存错误</div><div class="line">        ProductInfo productInfo = productInfoOptional.get();</div><div class="line">        int result = productInfo.getProductStock() - cartDTO.getProductQuantity();</div><div class="line">        if(result&lt;0)&#123;</div><div class="line">            throw new ProductException(ResultEnum.PRODUCT_STOCK_ERROE);</div><div class="line">        &#125;</div><div class="line">        //保存</div><div class="line">        productInfo.setProductStock(result);</div><div class="line">        repository.save(productInfo);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>5.Product–&gt;controller</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@RequestMapping(&quot;/product&quot;)</div><div class="line">public class ProductController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProductService productService;</div><div class="line"></div><div class="line">    @PostMapping(&quot;/decreaseStock&quot;)</div><div class="line">    public void decreaseStock(@RequestBody List&lt;CartDTO&gt; cartDTOList)&#123;</div><div class="line">        productService.decreaseStock(cartDTOList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>6.在Order服务中client里面的ProductClient添加:减库存方法  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@FeignClient(name = &quot;product&quot;)</div><div class="line">public interface ProductClient &#123;</div><div class="line">    @GetMapping(&quot;/msg&quot;)</div><div class="line">    String productMsg();</div><div class="line"></div><div class="line">    @PostMapping(&quot;/product/decreaseStock&quot;)</div><div class="line">    void decreaseStock(@RequestBody List&lt;CartDTO&gt; cartDTOList);</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">7. 7.Order服务中:ClientController</div></pre></td></tr></table></figure>
<p>@RestController<br>@Slf4j<br>public class ClientController {</p>
<pre><code>@Autowired
private ProductClient productClient;


@GetMapping(&quot;/getProductMsg&quot;)
public String getProductMsg(){
    String msg = productClient.productMsg();
    log.info(&quot;getProductMsg()&quot;,msg);
    return msg;
}

@GetMapping(&quot;/getProductList&quot;)
public String getProductList(){
    List&lt;ProductInfo&gt; productInfos = productClient.listForOrder(Arrays.asList(&quot;157875196366160022&quot;));
    return productInfos.toString();
}

@GetMapping(&quot;/productDecreaseStock&quot;)
public String productDecreaseStock(){
   productClient.decreaseStock(Arrays.asList(new CartDTO(&quot;157875196366160022&quot;,1)));
   return &quot;ok&quot;;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">8. 8.测试  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/19.png)  </div><div class="line">库存减少了  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/20.png)  </div><div class="line"></div><div class="line"></div><div class="line">#### 8.整合接口打通下单流程(Feign)</div><div class="line">之前我们已经完善了,商品的查询,扣库存,那么我们这一节就要完成整套业务的打通。我们之前在Order服务中,创建订单时候,里面还有需要实现的如下几步:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/21.png)  </div><div class="line"></div><div class="line">1. 1.现在我们补充完毕：</div></pre></td></tr></table></figure></p>
<p>@Service<br>public class OrderServiceImpl implements OrderService {<br>    @Autowired<br>    private OrderMasterRepository orderMasterRepository;</p>
<pre><code>@Autowired
private OrderDetailRepository orderDetailRepository;
@Autowired
private ProductClient productClient;
@Override
public OrderDTO create(OrderDTO orderDTO) {
    String orderId = KeyUtil.genUniqueKey();
    //1.TODO 查询商品信息(调用商品服务)
    List&lt;String&gt; productIdList = orderDTO.getOrderDetailList().stream().map(OrderDetail::getProductId).collect(Collectors.toList());
    List&lt;ProductInfo&gt; productInfoList = productClient.listForOrder(productIdList);
    //2.TODO 计算订单总价
    //定义总价
    BigDecimal orderAmout = new BigDecimal(BigInteger.ZERO);
    for(OrderDetail orderDetail:orderDTO.getOrderDetailList()){
        //总价=(单价*数量)+总价
        Integer productQuantity = orderDetail.getProductQuantity();
        for(ProductInfo productInfo:productInfoList){
            if(productInfo.getProductId().equals(orderDetail.getProductId())){
                orderAmout = productInfo.getProductPrice().multiply(new BigDecimal(productQuantity)).add(orderAmout);

               //订单详情赋值
                BeanUtils.copyProperties(productInfo,orderDetail);
                orderDetail.setOrderId(orderId);
                orderDetail.setDetailId(KeyUtil.genUniqueKey());

                //订单详情入库
                orderDetailRepository.save(orderDetail);
            }
        }

    }
    //3.TODO 扣除库存(调用商品服务)
    List&lt;CartDTO&gt; cartDTOList = orderDTO.getOrderDetailList().stream()
            .map(e -&gt; new CartDTO(e.getProductId(), e.getProductQuantity()))
            .collect(Collectors.toList());
    productClient.decreaseStock(cartDTOList);

    //4. 订单入库
    OrderMaster orderMaster = new OrderMaster();
    //先设置主键 会copy到orderMaster
    orderDTO.setOrderId(orderId);
    BeanUtils.copyProperties(orderDTO,orderMaster);
    orderMaster.setOrderAmount(orderAmout);
    orderMaster.setOrderStatus(OrderStatusEnum.NEW.getCode());
    orderMaster.setPayStatus(PayStatusEnum.WAIT.getCode());
    orderMasterRepository.save(orderMaster);
    return orderDTO;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 2.测试  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/22.png)</div><div class="line"></div><div class="line">#### 9.项目改造成多模块</div><div class="line">多模块改造参考:https://blog.csdn.net/yangshangwei/article/details/88809468  </div><div class="line">##### 9.1 项目缺陷</div><div class="line">虽然我们之前已经完成了下单并扣除库存，虽然通信是完成了,但是有些地方做的不好。有如下问题:  </div><div class="line">1.在Product微服务中,获取商品列表(给订单服务使用)</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/23.png)</div><div class="line">返回的ProductInfo是数据库实体:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/24.png)</div><div class="line">基本上,我们不会把自己数据库映射的表对象暴露给外部的。  </div><div class="line">2.在订单服务和商品服务之间都有共有的对象:CartDTO,ProductInfo.重复定义。对象属于哪一个服务就在那一个服务中定义。</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/25.png)    </div><div class="line">3.在Order(订单)服务里,定义了ProductClient接口使用Feign主键调用，我们在项目中可能一个服务就是很多人来做,各个服务费透明的,所以我们在Oder服务中不能把Product的服务代码请求路径等写到Order服务中.</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/26.png) </div><div class="line"></div><div class="line">##### 9.2 Product多模块拆分</div><div class="line">###### 9.2.1模块之间职责  </div><div class="line">针对解决以上情况,我们把项目分成3个模块:product-server、prodect-client、product-common  </div><div class="line"></div><div class="line">1. 1.product-server:存放所有业务逻辑:包括,controller、service</div><div class="line">2. 2.prodect-client:对外暴露的接口,商品模块对外暴露的接口:商品列表和扣库存。  </div><div class="line">3. 3.product-common:公用的对象:既会被内部模块调用,也会被外部模块调用。</div><div class="line">###### 9.2.2模块之间依赖关系  </div><div class="line">1. 1.product-common是公用的对象,所以product-server会依赖product-common,返回的商品对象prodect-client也会依赖product-common</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/27.png) </div><div class="line"></div><div class="line">2. 2.product商品多模块划分可以参考:https://blog.csdn.net/qq_29479041/article/details/84230669  </div><div class="line">3. 3.在本地打包</div></pre></td></tr></table></figure></p>
<p>mvn -Dmaven.test.skip=true -U clean install<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用以上命令,会将对应模块打包并安装到本地maven仓库</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/28.png)  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">##### 9.3 Order多模块拆分</div><div class="line">1. 1.一次类推,Order服务也分为3个模块,但是order-client目前是没有代码:其目前不需要给外提供服务  order-common目前也没有代码:目前没有需求  </div><div class="line">2. 2.在订单服务需要注意的是:订单服务调用商品服务,那么需要在订单服务里面的启动类中添加扫描到商品服务的路径:@EnableFeignClients(basePackages = &quot;com.yxm.product.client&quot;)</div><div class="line">3. 3.最外层pom文件引入product-client的jar包  </div><div class="line">4. 4.&lt;dependencyManagement&gt;是管理jar包版本,不会下载对应依赖</div><div class="line"></div><div class="line"></div><div class="line">##### 9.5 测试  </div><div class="line">启动注册中心，通过product-server和order-server中的main函数启动俩微服务</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/29.png)  </div><div class="line"></div><div class="line">下单  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/30.png)   </div><div class="line"></div><div class="line">```  </div><div class="line">select * from order_master a where a.order_id = &apos;1558247336963513928&apos;</div><div class="line">select * from order_detail a  where a.order_id = &apos;1558247336963513928&apos;</div></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/31.png" alt="">   </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/32.png" alt="">  </p>
<p>源码:github地址:<a href="https://github.com/startshineye/SpringCloud_Shell/tree/develop_multimodulw">https://github.com/startshineye/SpringCloud_Shell/tree/develop_multimodulw</a>  </p>
<h4 id="10-同步或者异步"><a href="#10-同步或者异步" class="headerlink" title="10.同步或者异步"></a>10.同步或者异步</h4><ol>
<li>1.当前订单服务和商品服务,两个服务之间的通讯机制是同步的。订单会调用商品服务的扣库存接口。微服务中除了同步,有很多时候会集成到异步的场景下,通过队列和订阅主题,实现消息的 发布和订阅,一个微服务可以是消息的发布者,通过异步的方式发送到队列和订阅主题下,作为消费者的微服务,可以从队列或者主题中获取消息。通过消息中间件。把服务间的直接调用解耦。</li>
<li>比如以下图中:用户登录的时候,用户服务需要调用短信服务发短信。要给用户加积分,需要调用积分服务。还可能有其他服务，如果都采用同步的机制，服务间耦合过大,用户登录成功，需要向多个服务同步响应后才会成功，就会造成不好的用户体验。这个时候，我们通过消息队列可以实现很好的异步调用。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/33.png" alt="">  </li>
<li>3.再比如:订单服务在口库存前会调用查询商品服务,之后再调用减库存的接口来扣库存。我们对其改造:商品服务在更改库存的时候、发布库存变化的消息、订单服务来订阅这个消息、可以获取到商品的部分信息，比如:可购买的商品个数、商品id。订单服务在下单的时候不必同步的去查询数据确定商品的库存信息 而是查询自己服务中数据 然后在扣库存时候订单服务发布一个扣库存的消息、商品服务订阅这个消息。拿到消息后，减少本库存消息的库存量。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/34.png" alt=""> </li>
<li>4.消息中间件:目前常见的消息队列为:RabbitMQ、Kafka、ActiveMQ,我们现在使用RabbitMQ</li>
</ol>
<h4 id="11-RabbitMQ的安装"><a href="#11-RabbitMQ的安装" class="headerlink" title="11.RabbitMQ的安装"></a>11.RabbitMQ的安装</h4><p>进入下载网址:<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="external">https://www.rabbitmq.com/download.html</a><br>我们使用docker安装RabbitMQ<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/35.png" alt=""><br>我们使用带有管理界面的mq:3.8.0-beta.4-management<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/36.png" alt="">  </p>
<p><a href="https://blog.csdn.net/antma/article/details/81334932" target="_blank" rel="external">https://blog.csdn.net/antma/article/details/81334932</a><br><a href="https://www.jianshu.com/p/f3e49b495d74" target="_blank" rel="external">https://www.jianshu.com/p/f3e49b495d74</a>  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/18/SpringCloud-4-应用通信/" class="archive-article-date">
  	<time datetime="2019-04-17T16:57:11.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-18</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-3-服务拆分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SpringCloud-3-服务拆分/">SpringCloud-3-服务拆分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-微服务拆分的起点"><a href="#1-微服务拆分的起点" class="headerlink" title="1.微服务拆分的起点"></a>1.微服务拆分的起点</h4><h5 id="1-1如何拆分微服务"><a href="#1-1如何拆分微服务" class="headerlink" title="1.1如何拆分微服务?"></a>1.1如何拆分微服务?</h5><p>现在微服务概念炒得很热,关于如何拆分微服务,有以下几点。  </p>
<ol>
<li>1.先明白起点和终点<br>起点:既有架构的形态。<br>终点:好的架构不是设计出来的,而是进化而来的。  </li>
<li>典型架构<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/65.png" alt=""></li>
</ol>
<h5 id="1-2-适合上微服务么"><a href="#1-2-适合上微服务么" class="headerlink" title="1.2 适合上微服务么?"></a>1.2 适合上微服务么?</h5><p>业务形态不适合的<br>1.系统中包含很多很多强事务场景的(因为微服务是分布式的,分布式强事务CAP最多也就能达到最终一致性)<br>2.业务相对稳定、迭代周期长<br>3.访问压力不大、可用性要求不高(中小型企业的OA)  </p>
<h4 id="2-康威定律和微服务"><a href="#2-康威定律和微服务" class="headerlink" title="2.康威定律和微服务"></a>2.康威定律和微服务</h4><h5 id="2-1-康威定律"><a href="#2-1-康威定律" class="headerlink" title="2.1 康威定律"></a>2.1 康威定律</h5><p>除了业务形态不适合的,其实还有其他条件,很可能导致不适合迁移到微服务中去,首先我们看一下微服务理论基础:康威定律<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/66.png" alt=""></p>
<p>一句话概括就是:沟通的问题会影响系统设计<br>所以微服务都是强调小团队开发,大的系统拆分成微服务时候,大的团队随机也会拆分成小的团队。 </p>
<h5 id="2-2-微服务和团队结构"><a href="#2-2-微服务和团队结构" class="headerlink" title="2.2 微服务和团队结构"></a>2.2 微服务和团队结构</h5><ol>
<li>微服务特点<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/67.png" alt=""></li>
<li>传统vs微服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/68.png" alt=""></li>
</ol>
<h4 id="3-点餐业务服务拆分分析"><a href="#3-点餐业务服务拆分分析" class="headerlink" title="3.点餐业务服务拆分分析"></a>3.点餐业务服务拆分分析</h4><p>点餐系统分为:买家端 和 卖家端  </p>
<h5 id="3-1-服务拆分"><a href="#3-1-服务拆分" class="headerlink" title="3.1 服务拆分"></a>3.1 服务拆分</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/69.png" alt=""><br>上面:服务两种方式拆分:<br>第一种(按照终端):买家端(手机端)的ui单独为一个服务放到nginx里面,卖家端(PC端)的ui单独为一个服务,两个服务同时向后端的通用服务请求数据<br>第二种(按照业务):将订单ui,商品ui,支付ui都放到一个边缘服务。</p>
<p>以上两种都不对,如果只是自己运营的的点餐应用:团队只有一个,并且业务变化也不大,没有微服务化的必要。如果是一个快速发展的IT公司点餐部门,业务快速发展，需求不断提出，所以需要拆分成微服务。</p>
<p>所以说:起点和团队结构,沟通方式都会决定微服务的设计。  </p>
<h5 id="3-2-服务拆分方法论"><a href="#3-2-服务拆分方法论" class="headerlink" title="3.2 服务拆分方法论"></a>3.2 服务拆分方法论</h5><p>下图出自&lt;&lt;可扩展的艺术&gt;&gt;书籍<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/70.png" alt=""></p>
<ol>
<li>X轴 水平复制:通过应用程序扩展,通过负载均衡运行多个父本一样的应用程序</li>
<li>Z轴 数据分区:将服务按数据分区、每个服务器负责一个数据子集、每个服务器运行的代码是一样的  </li>
<li>Y轴 功能解耦:不同职责模块分成不同服务</li>
</ol>
<p>通过以上模型,知道服务拆分的两个关键职责:功能和数据 </p>
<h6 id="3-2-1-如何拆”功能”"><a href="#3-2-1-如何拆”功能”" class="headerlink" title="3.2.1 如何拆”功能”"></a>3.2.1 如何拆”功能”</h6><ol>
<li>1.单一职责(每个服务负责业务功能的单独一部分)、松耦合(服务之间耦合度低,修改一个服务不用导致另一个服务修改)、高内聚(服务内部相关行为都聚集在一个服务内,而不是分散在不同服务中心)。</li>
<li>2.关注点分离:-按职责  -按通用性 -按粒度级别(微服务并不是越小越好,要合适)  </li>
</ol>
<h6 id="3-2-2-如何拆”数据”"><a href="#3-2-2-如何拆”数据”" class="headerlink" title="3.2.2 如何拆”数据”"></a>3.2.2 如何拆”数据”</h6><p>拆分功能和拆分数据是有先后顺序  </p>
<ol>
<li>1.先考虑业务功能、再考虑业务功能对应的数据  </li>
<li>2.无状态服务（状态:如果一个数据要被多个服务共享才能完成一个请求,那么这个数据就称为状态,进而依赖这个状态数据的服务称为有状态服务）<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/71.png" alt=""><br>如上所示把业务数据存放到有状态服务的数据库,缓存中实现前端微服务和后端微服务质检无状态服务,数据间没有太大耦合性。  </li>
</ol>
<p>如何拆数据:<br>1.每个微服务都有单独数据存储(微服务共有数据库,有可能其中一个数据库出现问题会影响其他微服务,一个服务要获取另一个服务的数据,不能直接连接库去请求,而是调用另一个服务接口去获取数据,服务之间有隔离)<br>2.依据服务特点选择不同结构的数据库类型(如果:数据基于搜索的,那么es合适,如果是非机构化数据,那么nosql的mongodb合适)<br>3.难点在确定边界  </p>
<h6 id="3-2-3-点餐业务服务拆分分析"><a href="#3-2-3-点餐业务服务拆分分析" class="headerlink" title="3.2.3 点餐业务服务拆分分析"></a>3.2.3 点餐业务服务拆分分析</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/72.png" alt=""><br>1.不要期望服务拆分一次就正确,微服务是不断演进的  </p>
<h4 id="4-商品服务"><a href="#4-商品服务" class="headerlink" title="4.商品服务"></a>4.商品服务</h4><h5 id="4-1-商品服务api和sql介绍"><a href="#4-1-商品服务api和sql介绍" class="headerlink" title="4.1 商品服务api和sql介绍"></a>4.1 商品服务api和sql介绍</h5><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /product/list</div></pre></td></tr></table></figure>
<p>参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">无</div></pre></td></tr></table></figure>
<p>返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;code&quot;: 0,</div><div class="line">    &quot;msg&quot;: &quot;成功&quot;,</div><div class="line">    &quot;data&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;热榜&quot;,</div><div class="line">            &quot;type&quot;: 1,</div><div class="line">            &quot;foods&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;id&quot;: &quot;123456&quot;,</div><div class="line">                    &quot;name&quot;: &quot;皮蛋粥&quot;,</div><div class="line">                    &quot;price&quot;: 1.2,</div><div class="line">                    &quot;description&quot;: &quot;好吃的皮蛋粥&quot;,</div><div class="line">                    &quot;icon&quot;: &quot;http://xxx.com&quot;,</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;好吃的&quot;,</div><div class="line">            &quot;type&quot;: 2,</div><div class="line">            &quot;foods&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;id&quot;: &quot;123457&quot;,</div><div class="line">                    &quot;name&quot;: &quot;慕斯蛋糕&quot;,</div><div class="line">                    &quot;price&quot;: 10.9,</div><div class="line">                    &quot;description&quot;: &quot;美味爽口&quot;,</div><div class="line">                    &quot;icon&quot;: &quot;http://xxx.com&quot;,</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">sql</div></pre></td></tr></table></figure>
<p>– 类目<br>CREATE TABLE <code>product_category</code> (<br>    <code>category_id</code> INT NOT NULL AUTO_INCREMENT,<br>    <code>category_name</code> VARCHAR(64) NOT NULL COMMENT ‘类目名字’,<br>    <code>category_type</code> INT NOT NULL COMMENT ‘类目编号’,<br>    <code>create_time</code> TIMESTAMP NOT NULL COMMENT ‘创建时间’,<br>    <code>update_time</code> TIMESTAMP NOT NULL COMMENT ‘修改时间’,<br>    PRIMARY KEY (<code>category_id</code>),<br>    UNIQUE KEY <code>uqe_category_type</code> (<code>category_type</code>)<br>);<br>– 商品<br>CREATE TABLE <code>product_info</code> (<br>    <code>product_id</code> VARCHAR(32) NOT NULL,<br>    <code>product_name</code> VARCHAR(64) NOT NULL COMMENT ‘商品名称’,<br>    <code>product_price</code> DECIMAL(8,2) NOT NULL COMMENT ‘单价’,<br>    <code>product_stock</code> INT NOT NULL COMMENT ‘库存’,<br>    <code>product_description</code> VARCHAR(64) COMMENT ‘描述’,<br>    <code>product_icon</code> VARCHAR(512) COMMENT ‘小图’,<br>    <code>product_status</code> TINYINT(3) DEFAULT ‘0’ COMMENT ‘商品状态,0正常1下架’,<br>    <code>category_type</code> INT NOT NULL COMMENT ‘类目编号’,<br>    <code>create_time</code> TIMESTAMP NOT NULL COMMENT ‘创建时间’,<br>    <code>update_time</code> TIMESTAMP NOT NULL COMMENT ‘修改时间’,<br>    PRIMARY KEY (<code>product_id</code>)<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 4.2 商品服务编码  </div><div class="line">###### 4.2.1 创建工程</div><div class="line">1. 创建一个Eureka客户端服务,并修改pom.xml文件 保持版本一致性。    </div><div class="line">2. 修改项目名称并注册到Eureka注册中心  </div><div class="line">3. 添加注解:@EnableDiscoveryClient</div><div class="line"></div><div class="line">###### 4.2.2 启动项目,查看Eureka Server是否有注册的服务  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/73.png)  </div><div class="line"> </div><div class="line">###### 4.2.3 书写业务</div><div class="line">1. 1.添加mysql驱动和jpa依赖</div><div class="line">2. application.yml中配置数据源  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/74.png)</div><div class="line"></div><div class="line"></div><div class="line">#### 5.订单服务 </div><div class="line">##### 5.1 业务逻辑分析    </div><div class="line">### 创建订单</div></pre></td></tr></table></figure></p>
<p>POST /order/create<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">参数</div></pre></td></tr></table></figure></p>
<p>name: “张三”<br>phone: “18868822111”<br>address: “总部”<br>openid: “ew3euwhd7sjw9diwkq” //用户的微信openid<br>items: [{<br>    productId: “1423113435324”,<br>    productQuantity: 2 //购买数量<br>}]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">返回</div></pre></td></tr></table></figure>
<p>{<br>  “code”: 0,<br>  “msg”: “成功”,<br>  “data”: {<br>      “orderId”: “147283992738221”<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">订单服务业务逻辑思路:  </div><div class="line">1.参数校验  </div><div class="line">2.查询商品信息(此时信息有可能不在订单系统中,可能在商品微服务中,则调用商品服务查询)  </div><div class="line">3.计算总价  </div><div class="line">4.扣库存(调用商品服务)   </div><div class="line">5.订单入库   </div><div class="line"></div><div class="line">##### 5.2 编码实践    </div><div class="line">###### 5.2.1 创建应用 注册到注册中心</div><div class="line">略(按照:client客户端创建)  </div><div class="line"></div><div class="line">###### 5.2.2 dao</div><div class="line">订单服务业务逻辑思路:  </div><div class="line">1.参数校验  </div><div class="line">2.查询商品信息(此时信息有可能不在订单系统中,可能在商品微服务中,则调用商品服务查询)  </div><div class="line">3.计算总价  </div><div class="line">4.扣库存(调用商品服务)   </div><div class="line">5.订单入库  </div><div class="line"></div><div class="line">###### 5.2.3 service  </div><div class="line">1. 由于传递的参数包含:买家信息和订单信息,所以创建订单的service需要做一个数据转换 然后insert到对应买家和订单表里面,创建dto(Data Transfer Object)包,创建OrderDTO(买家和订单详情是一对多的关系,所以里面OrderDTO里是一个买家信息加许多商品信息)    </div><div class="line">2. OrderService里面创建订单的参数和返回为:OrderDTO  </div><div class="line">3. OrderServiceImpl里面实现创建订单:分为以下四步:1.查询商品 2.计算总价 3.扣除库存 4.订单入库。由于前3步都需要调用其他商品服务,所以我们写为:TODO  </div><div class="line">4. 创建OrderMaster时候,我们需要设置买家状态:orderStatus,payStatus我们用枚举实现如下:</div></pre></td></tr></table></figure>
<p>public enum OrderStatusEnum {<br>    NEW(0, “新订单”),<br>    FINISHED(1, “完结”),<br>    CANCEL(2, “取消”),<br>    ;<br>    private Integer code;<br>    private String message;<br>    OrderStatusEnum(Integer code, String message) {<br>        this.code = code;<br>        this.message = message;<br>    }<br>    public Integer getCode() {<br>        return code;<br>    }<br>    public String getMessage() {<br>        return message;<br>    }<br>}  </p>
<p>public enum PayStatusEnum {<br>    WAIT(0, “等待支付”),<br>    SUCCESS(1, “支付成功”),<br>    ;<br>    private Integer code;</p>
<pre><code>private String message;

PayStatusEnum(Integer code, String message) {
    this.code = code;
    this.message = message;
}

public Integer getCode() {
    return code;
}

public String getMessage() {
    return message;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. OrderId是主键,我们用简单的KeyUtil生成工具生成</div></pre></td></tr></table></figure></p>
<p>public class KeyUtil {<br>    /**</p>
<pre><code> * 生成唯一的主键
 * 格式: 时间+随机数
 */
public static synchronized  String  genUniqueKey(){
    Random random = new Random();
    Integer number = random.nextInt(900000)+100000;
    return System.currentTimeMillis()+String.valueOf(number);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. service逻辑如下:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/82.png)</div><div class="line"></div><div class="line"></div><div class="line">###### 5.2.4 controller</div><div class="line">1. controller里面需要实现的业务逻辑大部分都是在service中,此处只是多了个参数校验，所以分为以下几步:1.参数校验 2.查询商品信息(调用商品服务) 3.计算总价 4.扣库存(调用商品服务) 5.订单入库  </div><div class="line">2.  涉及很多参数时候,我们封装前端参数,此处叫:OrderForm,并在里面添加了参数校验,不用在controller方法里面(使用@NotEmpty)校验。OrderForm此处省略getter,setter也可以用lombok加上@Data注解。</div></pre></td></tr></table></figure></p>
<p>public class OrderForm {<br>    /**</p>
<pre><code> * 买家姓名
 */
@NotEmpty(message = &quot;姓名必填&quot;)
private String name;

/**
 * 买家手机号
 */
@NotEmpty(message = &quot;手机号必填&quot;)
private String phone;

/**
 * 买家地址
 */
@NotEmpty(message = &quot;地址必填&quot;)
private String address;

/**
 * 买家微信openid
 */
@NotEmpty(message = &quot;openid必填&quot;)
private String openid;

/**
 * 购物车
 */
@NotEmpty(message = &quot;购物车不能为空&quot;)
private String items;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 在create方法中添加@Valid注解  </div><div class="line"></div><div class="line"></div><div class="line">4. 如果参数校验有错误时候抛出异常(自定义异常)OrderException(Integer code, String message)，其中code,message不使用硬编码,定义一个枚举:ResultEnum</div></pre></td></tr></table></figure>
<p>public class OrderException extends RuntimeException {<br>    private Integer code;<br>    public OrderException(Integer code, String message){<br>      super(message);<br>      this.code = code;<br>    }<br>    public OrderException(ResultEnum resultEnum) {<br>        super(resultEnum.getMessage());<br>        this.code = resultEnum.getCode();<br>    }<br>}</p>
<p>@Getter<br>public enum ResultEnum {<br>    PARAM_ERROR(1, “参数错误”),<br>    CART_EMPTY(2, “购物车为空”)<br>    ;</p>
<pre><code>private Integer code;

private String message;

ResultEnum(Integer code, String message) {
    this.code = code;
    this.message = message;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">5. 在controller里面将校验过的参数：OrderForm转换成OrderDTO,此处转换封装成工具类处理(其中json转换成数据使用Gson)，转换失败时候抛出异常,打印日志      </div><div class="line"></div><div class="line">```  </div><div class="line">@Slf4j</div><div class="line">public class OrderForm2OrderDTOConverter &#123;</div><div class="line">    public static OrderDTO convert(OrderForm orderForm) &#123;</div><div class="line">        Gson gson = new Gson();</div><div class="line">        OrderDTO orderDTO = new OrderDTO();</div><div class="line">        orderDTO.setBuyerName(orderForm.getName());</div><div class="line">        orderDTO.setBuyerPhone(orderForm.getPhone());</div><div class="line">        orderDTO.setBuyerAddress(orderForm.getAddress());</div><div class="line">        orderDTO.setBuyerOpenid(orderForm.getOpenid());</div><div class="line"></div><div class="line">        List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();</div><div class="line">        try &#123;</div><div class="line">            orderDetailList = gson.fromJson(orderForm.getItems(),</div><div class="line">                    new TypeToken&lt;List&lt;OrderDetail&gt;&gt;() &#123;</div><div class="line">                    &#125;.getType());</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;【json转换】错误, string=&#123;&#125;&quot;, orderForm.getItems());</div><div class="line">            throw new OrderException(ResultEnum.PARAM_ERROR);</div><div class="line">        &#125;</div><div class="line">        orderDTO.setOrderDetailList(orderDetailList);</div><div class="line">        return orderDTO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>接口返回的结果data里面只有一个字段,所以不需要创建一个对象,一个封装一个map返回就行    </li>
</ol>
<pre><code>@RestController
@RequestMapping(&quot;/order&quot;)
@Slf4j
public class OrderController {

    @Autowired
    private OrderService orderService;

    /**
     * 1.参数校验
     * 2.查询商品信息(调用商品服务)
     * 3.计算总价
     * 4.扣库存(调用商品服务)
     * 5.订单入库
     */
    @PostMapping(&quot;/create&quot;)
    private Object create(@Valid OrderForm orderForm,
                          BindingResult bindingResult){
        //检验不通过抛出自定义异常
        if (bindingResult.hasErrors()){
            //https://www.cnblogs.com/weiapro/p/7633645.html
           log.error(&quot;【创建订单】参数不正确, orderForm={}&quot;, orderForm);
            throw new OrderException(ResultEnum.PARAM_ERROR.getCode(),
                    bindingResult.getFieldError().getDefaultMessage());
        }
        //orderForm-&gt;orderDTO
        OrderDTO orderDTO = OrderForm2OrderDTOConverter.convert(orderForm);
        if(CollectionUtils.isEmpty(orderDTO.getOrderDetailList())){
            log.error(&quot;【创建订单】购物车信息为空&quot;);
            throw new OrderException(ResultEnum.CART_EMPTY);
        }
        OrderDTO result = orderService.create(orderDTO);
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;orderId&quot;, result.getOrderId());
        return ResultVOUtil.success(map);
    }
}
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/83.png" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/13/SpringCloud-3-服务拆分/" class="archive-article-date">
  	<time datetime="2019-04-13T11:49:59.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/49/">49</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/CTI/" style="font-size: 11.11px;">CTI</a> <a href="/tags/Cookie/" style="font-size: 10.56px;">Cookie</a> <a href="/tags/DevelopmentSkills/" style="font-size: 10px;">DevelopmentSkills</a> <a href="/tags/Easyui/" style="font-size: 10px;">Easyui</a> <a href="/tags/ElasticStack/" style="font-size: 10.56px;">ElasticStack</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IE问题/" style="font-size: 10px;">IE问题</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/JavaSE/" style="font-size: 15px;">JavaSE</a> <a href="/tags/Jeecg/" style="font-size: 11.67px;">Jeecg</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Myeclipse/" style="font-size: 14.44px;">Myeclipse</a> <a href="/tags/Netty/" style="font-size: 16.67px;">Netty</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 16.67px;">Oracle</a> <a href="/tags/Redis/" style="font-size: 12.22px;">Redis</a> <a href="/tags/Servlet/" style="font-size: 11.67px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 10.56px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/SpringBoot/" style="font-size: 19.44px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 11.67px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 11.11px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Vue/" style="font-size: 18.89px;">Vue</a> <a href="/tags/Vue-js-前端开发-快速入门与专业应用/" style="font-size: 17.22px;">Vue.js+前端开发+快速入门与专业应用</a> <a href="/tags/Weblogic/" style="font-size: 12.22px;">Weblogic</a> <a href="/tags/Websocket/" style="font-size: 10.56px;">Websocket</a> <a href="/tags/Work-Problem/" style="font-size: 10px;">Work-Problem</a> <a href="/tags/bg/" style="font-size: 10px;">bg</a> <a href="/tags/c/" style="font-size: 10.56px;">c</a> <a href="/tags/crawler/" style="font-size: 17.78px;">crawler</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/easyui/" style="font-size: 10px;">easyui</a> <a href="/tags/hibernate/" style="font-size: 10.56px;">hibernate</a> <a href="/tags/html-css/" style="font-size: 10.56px;">html+css</a> <a href="/tags/html-css/" style="font-size: 15px;">html-css</a> <a href="/tags/html-ss/" style="font-size: 10px;">html-ss</a> <a href="/tags/im/" style="font-size: 13.89px;">im</a> <a href="/tags/ipcc/" style="font-size: 10px;">ipcc</a> <a href="/tags/jQuery/" style="font-size: 12.22px;">jQuery</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/java-String/" style="font-size: 10px;">java String</a> <a href="/tags/javaSE/" style="font-size: 10.56px;">javaSE</a> <a href="/tags/javaWeb/" style="font-size: 10px;">javaWeb</a> <a href="/tags/javascript/" style="font-size: 11.11px;">javascript</a> <a href="/tags/java并发编程/" style="font-size: 11.67px;">java并发编程</a> <a href="/tags/java集合/" style="font-size: 10.56px;">java集合</a> <a href="/tags/junit测试/" style="font-size: 10px;">junit测试</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 16.11px;">linux</a> <a href="/tags/log4j/" style="font-size: 11.67px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/netty/" style="font-size: 11.67px;">netty</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodeJs/" style="font-size: 10px;">nodeJs</a> <a href="/tags/redis/" style="font-size: 12.78px;">redis</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/shiro/" style="font-size: 12.78px;">shiro</a> <a href="/tags/sockJs/" style="font-size: 10px;">sockJs</a> <a href="/tags/socket网络编程/" style="font-size: 10.56px;">socket网络编程</a> <a href="/tags/struts1/" style="font-size: 11.11px;">struts1</a> <a href="/tags/vue/" style="font-size: 10.56px;">vue</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weblogic/" style="font-size: 11.11px;">weblogic</a> <a href="/tags/websocket/" style="font-size: 15.56px;">websocket</a> <a href="/tags/work/" style="font-size: 14.44px;">work</a> <a href="/tags/zyzx/" style="font-size: 18.33px;">zyzx</a> <a href="/tags/代理/" style="font-size: 11.67px;">代理</a> <a href="/tags/前端/" style="font-size: 10.56px;">前端</a> <a href="/tags/动手写一个MVC/" style="font-size: 12.22px;">动手写一个MVC</a> <a href="/tags/反射/" style="font-size: 15.56px;">反射</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/微博/" style="font-size: 10px;">微博</a> <a href="/tags/文件读取/" style="font-size: 10px;">文件读取</a> <a href="/tags/泛型/" style="font-size: 13.33px;">泛型</a> <a href="/tags/注解/" style="font-size: 11.11px;">注解</a> <a href="/tags/类加载器/" style="font-size: 13.33px;">类加载器</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/自己写一个apache服务器/" style="font-size: 16.67px;">自己写一个apache服务器</a> <a href="/tags/转载/" style="font-size: 12.22px;">转载</a> <a href="/tags/集合/" style="font-size: 12.22px;">集合</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>