<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-freeswitch-1-使用FreeSWITCH-SIP落地的配置总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/freeswitch-1-使用FreeSWITCH-SIP落地的配置总结/">freeswitch-1-使用FreeSWITCH SIP落地的配置总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考:<a href="https://blog.csdn.net/liyang051/article/details/46739639" target="_blank" rel="external">https://blog.csdn.net/liyang051/article/details/46739639</a>  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/29/freeswitch-1-使用FreeSWITCH-SIP落地的配置总结/" class="archive-article-date">
  	<time datetime="2019-07-29T15:47:43.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-29</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/freeswitch/">freeswitch</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ipcc-2-常见问题记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/ipcc-2-常见问题记录/">ipcc-2-常见问题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="ipcc对接第三方话务平台"><a href="#ipcc对接第三方话务平台" class="headerlink" title="ipcc对接第三方话务平台"></a>ipcc对接第三方话务平台</h4><h5 id="1-抓包找不到对应ip数据包"><a href="#1-抓包找不到对应ip数据包" class="headerlink" title="1.抓包找不到对应ip数据包"></a>1.抓包找不到对应ip数据包</h5><ol>
<li>1.分析:ipcc对接第三方话务平台的时候、我们抓包时候压根抓不到对应的ip网络交互、说明ipcc没能和第三方话务平台建立链接、说明freeswitch的sip对接地址注册有问题  </li>
<li>2.解决:a.查看对应的网关对接信息是否有问题,在freeswitch的/usr/local/freeswitch/conf/sip_profiles/external/gw5.xml配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/35.png" alt="">  </li>
<li>3.解决:b.查看freeswitch启动时候日志信息:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/36.png" alt=""><br>从上面看是gw5.xml网关对应的配置信息有误  </li>
<li>4.解决:c.打开fs的客户端fs_cli通过sofia status 查看网关注册状态<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/37.png" alt=""><br>从上面可以知道网关注册失败  </li>
</ol>
<p>综上:找相关人员再次获取相关信息。</p>
<h5 id="2-fs通过mrcp对接asr时候对接不上"><a href="#2-fs通过mrcp对接asr时候对接不上" class="headerlink" title="2.fs通过mrcp对接asr时候对接不上"></a>2.fs通过mrcp对接asr时候对接不上</h5><p>在测试环境下fs通过mrcp对接asr时候对接时候、启动fs和ipcc平台时候、发现和机器人交互时候总是感觉机器人获取不到用户说话的声音并且抓包时候也没有抓到包<br>解决: </p>
<ol>
<li>1.查看asr的配置信息并确认没问题<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/38.png" alt="">  </li>
<li>2.查看fs的启动日志:然后查看端口信息、发现端口被占用<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/39.png" alt=""><br>综上:杀掉端口对应进程、然后重启即可。</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/29/ipcc-2-常见问题记录/" class="archive-article-date">
  	<time datetime="2019-07-29T08:29:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-29</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ipcc/">ipcc</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-work-10-linux下硬盘分区挂载" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: work-10-linux下硬盘分区挂载<br>date: 2019-07-29 13:52:20<br>tags:</p>
<h2 id="linux"><a href="#linux" class="headerlink" title=" linux"></a> linux</h2><p><a href="https://blog.csdn.net/ren_19891209/article/details/79375495" target="_blank" rel="external">https://blog.csdn.net/ren_19891209/article/details/79375495</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/29/work-10-linux下硬盘分区挂载/" class="archive-article-date">
  	<time datetime="2019-07-29T05:52:20.594Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-29</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ElasticStack-3-Elasticsearch篇之入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/ElasticStack-3-Elasticsearch篇之入门/">ElasticStack-3-Elasticsearch篇之入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-术语介绍"><a href="#1-术语介绍" class="headerlink" title="1.术语介绍"></a>1.术语介绍</h3><ol>
<li><p>1.文档 Document<br>用户存储在es中的数据文档—–Mysql中表的一行数据  </p>
</li>
<li><p>2.索引 Index<br>由具有相同字段的文档列表组成(文档集合)—Mysql中的表table<br>在es1.6之前一个index下可以创建多个type、但是1.6之后一个index下只能创建一个type。  </p>
</li>
<li><p>3.节点Node<br>一个Elasticsearch的运行实例，是集群的构成单元。  </p>
</li>
<li><p>4.集群 Cluster<br>由一个或多个节点组成、对外提供服务。  </p>
</li>
</ol>
<h3 id="2-Document介绍"><a href="#2-Document介绍" class="headerlink" title="2.Document介绍"></a>2.Document介绍</h3><ol>
<li>1.Document是一个Json Object,由字段(Field)组成，常见数据类型如下:<br>-字符串:text(分词),keyword(不分词)<br>-数值型:long,integer,short,byte,double,float,half_float,scaled_float(不同类型占用空间不一致)<br>-布尔型:boolean<br>-日期:date<br>-二进制:binary<br>-范围类型:integer_range、float_range、long_range、double_range<br>、date_range  </li>
<li>2.每个文档有唯一的id标识(类似于Mysql中的主键)<br>-可以自动指定<br>-如果不指定、es会自动生成  </li>
</ol>
<p>例如:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/34.png" alt=""><br>1.上面是nginx的日志:日志包含ip、时间、请求方式、相应等<br>2.下面是es总存放的nginx日志的结构化数据、其就是一个文档  </p>
<ol>
<li>3.一个document有对应的元数据，用于标注文档的相关信息。<br>-_index:文档所在的索引名<br>-_type:文档所在的类型名<br>-_id:文档唯一id<br>-_uid:组合id,由_type和_id组成(6.x_type不再起作用,同_id一样)<br>-_source:文档的原始Json数据、可以从这里获取每个字段的内容<br>-_all:整合所有字段内容到字段，默认禁用  </li>
</ol>
<h3 id="3-Index介绍"><a href="#3-Index介绍" class="headerlink" title="3.Index介绍"></a>3.Index介绍</h3><ol>
<li>1.Index在数据库中类比的概念是:table,我们知道table有自己的scheme(表结构定义)、对应的在es里面、每一个Index都有自己的Scheme定义、他叫Mapping,用于定义定义字段名和类型</li>
<li>2.Index:具有相同结构的文档(Document)集合<br>-每个索引都有自己的mapping定义,用于定义字段名和类型。之前我们也看了一个document有字段名和字段值、他的字段是什么类型通过mapping定义。  </li>
<li>3.一个集群可以有多个索引,比如：nginx日志存储的时候可以按照每天生成一个索引来存储,如下:  <blockquote>
<p>nginx-log-2017-01-01<br>nginx-log-2017-01-02<br>nginx-log-2017-01-03  </p>
</blockquote>
</li>
</ol>
<h3 id="4-restapi介绍"><a href="#4-restapi介绍" class="headerlink" title="4.restapi介绍"></a>4.restapi介绍</h3><p>创建索引与写入数据  </p>
<ol>
<li><p>1.Elasticsearch集群对外提供RESTful API<br>-REST -REpresentational State Transfer(表现层状态转移)<br>-URI指定资源,如Index、Document等<br>-Http Method指明资源操作类型,如:GET、POST、PUT、DELETE等。  </p>
</li>
<li><p>2.常见两种交互方式<br>-Curl命令行<br>-Kibaba DevTools<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/40.png" alt="">  </p>
<h3 id="5-index-API介绍"><a href="#5-index-API介绍" class="headerlink" title="5.index API介绍"></a>5.index API介绍</h3></li>
<li>1.es有专门的Index API,用于创建、更新、删除索引配置等。<br>-创建索引api如下:<br>请求 /索引名<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/41.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/42.png" alt="">  <h3 id="6-Document-API介绍"><a href="#6-Document-API介绍" class="headerlink" title="6.Document API介绍"></a>6.Document API介绍</h3></li>
<li>1.es有专门的document API<br>-创建文档<br>第一种方式：指定id(使用put)<br>put /索引/类型/主键  具体json对象<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/43.png" alt=""><br>第二种方式:不指定id(不使用put)<br>post /索引/类型  具体json对象<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/44.png" alt="">  </li>
</ol>
<p>-查询文档<br>主键查询文档<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/45.png" alt=""><br>查询所有文档<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/46.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/47.png" alt=""><br>-更新文档<br>使用bulk<br>-删除文档<br>使用bulk<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/48.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/49.png" alt="">  </p>
<p>批量查询<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/50.png" alt="">  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/18/ElasticStack-3-Elasticsearch篇之入门/" class="archive-article-date">
  	<time datetime="2019-07-18T15:41:31.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-18</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ElasticStack/">ElasticStack</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-work-8-阿里云oss同步ossutil使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/work-8-阿里云oss同步ossutil使用/">work-8-阿里云oss同步ossutil使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阿里云ECS服务器上挂载的录音文件磁盘已经快不够了，为了保证呼叫的正常进行、需要将文件同步到oss阿里云文件服务器中。</p>
<h4 id="1-文件磁盘空间查看"><a href="#1-文件磁盘空间查看" class="headerlink" title="1.文件磁盘空间查看"></a>1.文件磁盘空间查看</h4><ol>
<li>1.查看文件磁盘空间<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/9.png" alt="">  </li>
</ol>
<h4 id="2-linux下阿里云oss搭建"><a href="#2-linux下阿里云oss搭建" class="headerlink" title="2.linux下阿里云oss搭建"></a>2.linux下阿里云oss搭建</h4><p>阿里云oss的操作可参考阿里云官方文档说明:<a href="https://help.aliyun.com/document_detail/50452.html?spm=a2c4g.11186623.3.3.2f012e69aklxKQ" target="_blank" rel="external">https://help.aliyun.com/document_detail/50452.html?spm=a2c4g.11186623.3.3.2f012e69aklxKQ</a>  </p>
<ol>
<li><p>1.查看系统位数:uname -r<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/10.png" alt=""></p>
</li>
<li><p>2.下载ossutil<br>wget <a href="http://gosspublic.alicdn.com/ossutil/1.6.3/ossutil64" target="_blank" rel="external">http://gosspublic.alicdn.com/ossutil/1.6.3/ossutil64</a>  </p>
</li>
<li><p>3.添加到环境变量<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/11.png" alt="">  </p>
</li>
<li><p>4.配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/12.png" alt="">  </p>
</li>
<li><p>5.查看oss中的Buckets<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/13.png" alt="">  </p>
</li>
<li><p>6.同步文件<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/14.png" alt="">  </p>
</li>
<li><p>7.同步文件夹<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/15.png" alt=""> </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ossutil cp -r /cc/data/ivrrecord2/20190619   oss://fz-oss/picccallcenter/ivrrecord2/20190619</div></pre></td></tr></table></figure>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/10/work-8-阿里云oss同步ossutil使用/" class="archive-article-date">
  	<time datetime="2019-07-10T10:39:31.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-10</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/work/">work</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-8-Zuul综合使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/07/SpringCloud-8-Zuul综合使用/">SpringCloud-8-Zuul综合使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>项目整体架构图如下:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/8.png" target="_blank" rel="external"></a>   </p>
<h4 id="8-1-Zuul-Pre和Post过滤器"><a href="#8-1-Zuul-Pre和Post过滤器" class="headerlink" title="8.1 Zuul:Pre和Post过滤器"></a>8.1 Zuul:Pre和Post过滤器</h4><ol>
<li>1.所有的请求都会到Zuul,然后到ServicreA、然后到ServiceB、再到ServiceC、现在我们对整体服务做一个权限校验。假如没有zuul服务、那么ServicreA、ServicreB、ServicreC都得校验一次做的太多受不了。所以权限校验我们放在Zuul里面统一处理。</li>
<li>2.我们以:<a href="http://localhost:8084/myProduct/product/list?token=12121为例子.。我们只有在连接后面添加:token=？才允许校验通过。" target="_blank" rel="external">http://localhost:8084/myProduct/product/list?token=12121为例子.。我们只有在连接后面添加:token=？才允许校验通过。</a>  <h5 id="8-1-1-Zuul统一校验"><a href="#8-1-1-Zuul统一校验" class="headerlink" title="8.1.1 Zuul统一校验"></a>8.1.1 Zuul统一校验</h5></li>
<li><p>1.新建TokenFilter做PRE过滤  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Component</div><div class="line">public class TokenFilter extends ZuulFilter&#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public String filterType() &#123;</div><div class="line">       return PRE_TYPE;</div><div class="line">   &#125;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public int filterOrder() &#123;</div><div class="line">       /**</div><div class="line">        * filter的顺序:对应的值越低优先级越高</div><div class="line">        * 我们把此Filter放在PRE_DECORATION_FILTER_ORDER前面</div><div class="line">        */</div><div class="line">       return PRE_DECORATION_FILTER_ORDER-1;</div><div class="line">   &#125;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public boolean shouldFilter() &#123;</div><div class="line">       /**</div><div class="line">        * 开启过滤</div><div class="line">        */</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Object run() throws ZuulException &#123;</div><div class="line">       RequestContext requestContext = RequestContext.getCurrentContext();</div><div class="line">       HttpServletRequest request = requestContext.getRequest();</div><div class="line">	</div><div class="line">       //这里从url参数里面获取,也可以从cookie,header里获取</div><div class="line">       String token = request.getParameter(&quot;token&quot;);</div><div class="line">       if(StringUtils.isEmpty(token))&#123;</div><div class="line">           requestContext.setSendZuulResponse(false);</div><div class="line">           requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</div><div class="line">       &#125;</div><div class="line">       return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>2.新建Post过滤器    </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class AddResponseHeaderFilter extends ZuulFilter&#123;</div><div class="line">    @Override</div><div class="line">    public String filterType() &#123;</div><div class="line">        return POST_TYPE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int filterOrder() &#123;</div><div class="line">        return SEND_RESPONSE_FILTER_ORDER - 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean shouldFilter() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object run() &#123;</div><div class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</div><div class="line">        HttpServletResponse response = requestContext.getResponse();</div><div class="line">        response.setHeader(&quot;X-Foo&quot;, UUID.randomUUID().toString());</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-2-Zuul-限流"><a href="#8-2-Zuul-限流" class="headerlink" title="8.2 Zuul:限流"></a>8.2 Zuul:限流</h4><h5 id="8-2-1-限流基本理论"><a href="#8-2-1-限流基本理论" class="headerlink" title="8.2.1 限流基本理论"></a>8.2.1 限流基本理论</h5><ol>
<li>1.Zuul充当的是api网关的角色、每个请求都会经过它、在他上面做api限流保护、防止攻击。比如我们的api是发短信的、我们需要限制客户端请求速度、从而在一定程序上抵制短信大攻击、降低损失。</li>
<li>2.Zuul的限流是放在前置过滤去去做的、更具体来说、时机是在请求被转发之前调用。如果前置过滤器有多个操作、限流放到最靠前那个。比如:Zuul前置过滤器里面有限流、鉴权。那么限流应该早于鉴权。</li>
<li>3.限流方案很多，这里以一种来说:令牌桶流。<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/16.png" target="_blank" rel="external"></a><br>a.中间桶(token bucket)：是存放令牌的、所以叫做令牌桶。<br>b.最上面会以固定的速率往令牌桶中添加令牌、如果已经放满了就丢掉。<br>c.外部请求过来、会从令牌桶中获取令牌、拿到令牌之后才可以继续往前走。如果拿不到令牌直接被拒绝。其实是和买房一样。 </li>
</ol>
<h5 id="8-2-2-限流代码实现"><a href="#8-2-2-限流代码实现" class="headerlink" title="8.2.2 限流代码实现"></a>8.2.2 限流代码实现</h5><h6 id="1-新建RateFilter类"><a href="#1-新建RateFilter类" class="headerlink" title="1.新建RateFilter类"></a>1.新建RateFilter类</h6><p><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/17.png" target="_blank" rel="external"></a><br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/18.png" target="_blank" rel="external"></a>   </p>
<h4 id="8-3-Zuul-鉴权和添加用户服务"><a href="#8-3-Zuul-鉴权和添加用户服务" class="headerlink" title="8.3 Zuul:鉴权和添加用户服务"></a>8.3 Zuul:鉴权和添加用户服务</h4><h5 id="8-3-1-Zuul权限校验"><a href="#8-3-1-Zuul权限校验" class="headerlink" title="8.3.1 Zuul权限校验"></a>8.3.1 Zuul权限校验</h5><p>我们使用Zuul的权限校验实现下面3个功能。</p>
<ol>
<li>1./order/create 只能买家访问(创建订单)  </li>
<li>2./order/finish 只能卖家访问(完结订单) </li>
<li><p>3./product/list 都可以访问(商品列表)  </p>
</li>
<li><p>1.新建鉴权Filter(AuthFilter)<br>新建鉴权Filter、用来区分买家和卖家</p>
</li>
</ol>
<ol>
<li>2.实现逻辑<br>怎样区分买家和卖家呢?有些人想到cookie、既然想到了cookie那么必须买家和卖家登录了之后才能获取到信息。那么登录功能写到哪里了，就需要有一个用户服务。</li>
</ol>
<h5 id="8-3-2-添加用户服务"><a href="#8-3-2-添加用户服务" class="headerlink" title="8.3.2 添加用户服务"></a>8.3.2 添加用户服务</h5><ol>
<li><p>1.API接口登录区分<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/18.png" target="_blank" rel="external"></a> </p>
</li>
<li><p>2.数据库  </p>
</li>
</ol>
<pre><code>CREATE TABLE `user_info` (
  `id` varchar(32) NOT NULL,
  `username` varchar(32) DEFAULT &apos;&apos;,
  `password` varchar(32) DEFAULT &apos;&apos;,
  `openid` varchar(64) DEFAULT &apos;&apos; COMMENT &apos;微信openid&apos;,
  `role` tinyint(1) NOT NULL COMMENT &apos;1买家2卖家&apos;,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;修改时间&apos;,
  PRIMARY KEY (`id`)
);
</code></pre><ol>
<li><p>3.创建应用<br>选择的依赖组件:<br>1.配置:Cloud Config–&gt;Config Cient<br>2.注册中心:Cloud Discovery–&gt;Eureka Discovery<br>3.数据库:SQL–&gt;Mysql/JPA<br>4.缓存:NoSQL–&gt;redis  </p>
</li>
<li><p>4.修改版本依赖</p>
</li>
<li><p>5.统一配置中心远端服务器创建user-dev.yml文件<br>我们只添加数据库连接信息和redis连接信息，其他信息在bootstrap.yml文件里面  </p>
</li>
</ol>
<ol>
<li><p>6.在config服务中访问:<a href="http://localhost:8083/user-dev.yml可以查看到对应文件" target="_blank" rel="external">http://localhost:8083/user-dev.yml可以查看到对应文件</a></p>
</li>
<li><p>7.因为user服务后面肯定会对外提供接口的、所以我们将其改造成多模块</p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/07/SpringCloud-8-Zuul综合使用/" class="archive-article-date">
  	<time datetime="2019-07-07T04:13:24.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-07</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ElasticStack-2-入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/24/ElasticStack-2-入门/">ElasticStack-2-入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-内容简介"><a href="#1-内容简介" class="headerlink" title="1.内容简介:"></a>1.内容简介:</h3><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/68.png" alt=""> </p>
<h3 id="2-Elastic-Search和Kibana入门"><a href="#2-Elastic-Search和Kibana入门" class="headerlink" title="2.Elastic Search和Kibana入门"></a>2.Elastic Search和Kibana入门</h3><h4 id="2-1-Elasticsearch安装与运行"><a href="#2-1-Elasticsearch安装与运行" class="headerlink" title="2.1 Elasticsearch安装与运行"></a>2.1 Elasticsearch安装与运行</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/69.png" alt=""> </p>
<p>浏览器输入:<a href="https://www.elastic.co---&gt;进入products--&gt;进入elasticsearch--&gt;Download" target="_blank" rel="external">https://www.elastic.co---&gt;进入products--&gt;进入elasticsearch--&gt;Download</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/70.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/71.png" alt=""><br>我这里以window下为例,下载后解压运行：bin\elasticsearch.bat</p>
<p>我们访问:<a href="http://127.0.0.1:9200就可以确认es是否已经启动。" target="_blank" rel="external">http://127.0.0.1:9200就可以确认es是否已经启动。</a>  </p>
<h4 id="2-2-Elasticsearch配置详解"><a href="#2-2-Elasticsearch配置详解" class="headerlink" title="2.2 Elasticsearch配置详解"></a>2.2 Elasticsearch配置详解</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/72.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/73.png" alt=""></p>
<ol>
<li><p>1.elasticsearch.yml配置文件说明:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/74.png" alt=""> </p>
</li>
<li><p>2.Development与 Production模式说明<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/75.png" alt="">  </p>
</li>
</ol>
<h4 id="2-3-Elasticsearch本地快速搭建集群"><a href="#2-3-Elasticsearch本地快速搭建集群" class="headerlink" title="2.3 Elasticsearch本地快速搭建集群"></a>2.3 Elasticsearch本地快速搭建集群</h4><p>window下启动错误解决:<br><a href="https://blog.csdn.net/fanrenxiang/article/details/81358332" target="_blank" rel="external">https://blog.csdn.net/fanrenxiang/article/details/81358332</a>  </p>
<p>集群搭建按照下面图所示:启动3个服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/76.png" alt=""> </p>
<ol>
<li><p>1.启动默认的服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/77.png" alt=""> </p>
</li>
<li><p>2.启动第二个实例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/78.png" alt=""><br>查看集群:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/79.png" alt="">  </p>
</li>
<li><p>3.启动第3个实例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/80.png" alt=""> </p>
</li>
</ol>
<h4 id="2-4-Kibana安装与演示"><a href="#2-4-Kibana安装与演示" class="headerlink" title="2.4 Kibana安装与演示"></a>2.4 Kibana安装与演示</h4><p>Kibana是使用node.js开发的产品。<br>同样在<a href="https://www.elastic.co/cn/里面的产品--&gt;Kibana--&gt;下载--&gt;Download" target="_blank" rel="external">https://www.elastic.co/cn/里面的产品--&gt;Kibana--&gt;下载--&gt;Download</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/83.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/84.png" alt=""><br>注意:需要进入kibana.yml文件，然后修改里面的Elasticsearch的地址指向:<br>1.Open config/kibana.yml in an editor<br>2.Set elasticsearch.hosts to point at your Elasticsearch instance</p>
<p>然后访问：<a href="http://localhost:5601" target="_blank" rel="external">http://localhost:5601</a></p>
<h4 id="2-5-Kibana配置详解"><a href="#2-5-Kibana配置详解" class="headerlink" title="2.5 Kibana配置详解"></a>2.5 Kibana配置详解</h4><p>Kibana的配置详解<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/85.png" alt=""><br>Kibana常用功能说明<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/86.png" alt="">  </p>
<h4 id="2-6-Elasticsearch术语介绍与CRUD实际操作"><a href="#2-6-Elasticsearch术语介绍与CRUD实际操作" class="headerlink" title="2.6 Elasticsearch术语介绍与CRUD实际操作"></a>2.6 Elasticsearch术语介绍与CRUD实际操作</h4><h5 id="2-6-1-Elasticsearch常用术语"><a href="#2-6-1-Elasticsearch常用术语" class="headerlink" title="2.6.1 Elasticsearch常用术语"></a>2.6.1 Elasticsearch常用术语</h5><ol>
<li>1.Document文档数据、既然是数据、可以理解成数据表里面的一条数据。</li>
<li>2.Index 索引 可以理解成:数据库。所有document都是存在于Index数据中的。    </li>
<li>3.Type索引中的数据类型。可以理解成数据库中的一个表</li>
<li>4.Field字段、文档的属性。类似于mysql中的字段。</li>
<li>5.Query DSL查询语句。</li>
</ol>
<h5 id="2-6-2-Elasticsearch的CRUD"><a href="#2-6-2-Elasticsearch的CRUD" class="headerlink" title="2.6.2 Elasticsearch的CRUD"></a>2.6.2 Elasticsearch的CRUD</h5><p>CRUD其实就是数据的增删改查,这里面的数据就是文档，所以CRUD只是对文档的操作。  </p>
<ol>
<li>1.Create 创建文档  </li>
<li>2.Read 读取文档  </li>
<li>3.Update 更新文档  </li>
<li>4.Delete 删除文档  </li>
</ol>
<p>我们在Index(accounts)下创建一个type(person)文档id为1  文档内容就是下面的左图json格式。右边是一个创建文档后返回的内容。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/87.png" alt=""> </p>
<p>我们需要实际操作的话,只需要在Kibanna的Dev Tools下的console中输入一下内容。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/88.png" alt=""><br>上面文档就算插入成功了，文档插入成功之后、我们需要获取这个文档也就是读取文档：read<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/89.png" alt=""> </p>
<p>更新<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/90.png" alt=""> </p>
<p>删除<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/91.png" alt="">  </p>
<h4 id="2-7-Elasticsearch查询简介"><a href="#2-7-Elasticsearch查询简介" class="headerlink" title="2.7 Elasticsearch查询简介"></a>2.7 Elasticsearch查询简介</h4><ol>
<li><p>1.查询的基本语法<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/92.png" alt="">  </p>
</li>
<li><p>2.查询实例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/93.png" alt="">  </p>
</li>
<li><p>3.在官方文档可以查看到详细的语法<br>进入官网–&gt;lean(了解)–&gt;doc(文档) –&gt;Elasticsearch Reference–&gt;Query DSL</p>
</li>
</ol>
<h3 id="3-Beats、Filebea入门"><a href="#3-Beats、Filebea入门" class="headerlink" title="3.Beats、Filebea入门"></a>3.Beats、Filebea入门</h3><h4 id="3-1-Beats简介"><a href="#3-1-Beats简介" class="headerlink" title="3.1 Beats简介"></a>3.1 Beats简介</h4><p>Beats定义:Lightweight Data Shipper(官方定义为:轻量级的数据传送者)。官方目前有下面几个beats。</p>
<ol>
<li>1.Filebeat—主要针对日志文件  </li>
<li>2.Metricbeat—主要收集：像操作系统、CPU、内存、磁盘、还有像常用软件:nginx、Mysql的度量指标。Metricbeat能很快收集这些度量指标、然后很快的放入es中进行可视化分析、展示、告警。</li>
<li>3.Packetbeat—网络数据(比如服务器传输情况)   </li>
<li>4.Winlogbeat Window 数据—Window的日志数据。</li>
<li>5.Heartbeat—健康检查<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/94.png" alt=""><br>如上图我们知道：Beat处于数据的起始端、他们可以将数据直接存储到Elasticsearch中、也可以传输到logstash,然后logstash通过分析或者转换把数据传送到Elasticsearch中、最后通过Kibana对数据进行展示。</li>
</ol>
<h4 id="3-2Filebeat简介"><a href="#3-2Filebeat简介" class="headerlink" title="3.2Filebeat简介"></a>3.2Filebeat简介</h4><p>Filebeat主要是对日志文件进行处理的，如下为处理流程:<br>Filebeat输入日志文件、拿到日志文件后进行简单处理(Filter)、然后输出OutPut</p>
<p>我们用以下图查看Filebeat的构成:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/95.png" alt="">  </p>
<ol>
<li>1.左边是Filebeat,右边是Filebeat的输出对象。我们可以看到输出对象有:Elasticsearch、Logstash、Kafka、Redis</li>
<li>2.从左边可以看到Filebeat包含两个部分：Prospect(观察者)和Harvester(收割者)<br>Prospect针对/var/log/*.log文件可以探测其文件是否有变化、如果有变化  Harvester就需要收集新的日志。将日志从每一个日志文件中取出来、然后发送到output对象。</li>
<li>3.一个Filebeat可以有多个Prospect(观察者)和Harvester(收割者)、上面的Prospect(观察者)和Harvester(收割者)针对的日志文件是不同”的。</li>
<li>4.Prospect(观察者)针对于不同的配置文件(system.log和wifi.log)会启动多个Harvester。也就是一个Harvester针对于一个配置文件。</li>
</ol>
<h4 id="3-3-Filebeat配置简介"><a href="#3-3-Filebeat配置简介" class="headerlink" title="3.3 Filebeat配置简介"></a>3.3 Filebeat配置简介</h4><h5 id="3-3-1-Filebeat-Input配置简介"><a href="#3-3-1-Filebeat-Input配置简介" class="headerlink" title="3.3.1 Filebeat Input配置简介"></a>3.3.1 Filebeat Input配置简介</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/96.png" alt=""> </p>
<ol>
<li>2.使用yml语法、跟之前elasticsearch一致。  </li>
<li>2.Filebeat其中一个组成是Prospect、在其配置文件中有一个Prospect配置。  </li>
<li>3.之前说了Prospect是不止一个的、可以配置多个。所以是个数组。yml的数组格式使用”-“隔离的。上图是配置了两个Prospect</li>
<li>4每一个Prospect有自己的输入类型、这里是log、说明是配置文件。paths也是一个数组、用于指定日志的路径的。</li>
<li>5.目前input_type有两个类型:一个是log、另一个是stdin(标准输入)</li>
</ol>
<h5 id="3-3-2-Filebeat-Output配置简介"><a href="#3-3-2-Filebeat-Output配置简介" class="headerlink" title="3.3.2 Filebeat Output配置简介"></a>3.3.2 Filebeat Output配置简介</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/97.png" alt=""></p>
<ol>
<li>1.Filebeat Output支持以下类型对象:Console(标准输出)、Elasticsearch、Logstash、Kafka、Redis、File(指把一个日志文件输出到另一个日志文件中)。</li>
</ol>
<h5 id="3-3-3-Filebeat-Filter配置简介"><a href="#3-3-3-Filebeat-Filter配置简介" class="headerlink" title="3.3.3 Filebeat Filter配置简介"></a>3.3.3 Filebeat Filter配置简介</h5><p>对读入的内容进行一定的处理、当然他的处理能力相对较弱。例如:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/98.png" alt=""><br>例子:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/99.png" alt=""></p>
<h4 id="3-4Filebeat高级使用简介"><a href="#3-4Filebeat高级使用简介" class="headerlink" title="3.4Filebeat高级使用简介"></a>3.4Filebeat高级使用简介</h4><ol>
<li><p>1.从上面我们知道Filebea缺乏数据转换的能力。针对于这个问题，Elasticsearch增加了一个Node类型、Elasticsearch Ingest Node<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/100.png" alt=""></p>
</li>
<li><p>2.Filebeat Module简介:Filebeat本身想把数据快速存放到Elasticsearch中大致要做一些处理，首先要写合适的Filebeat配置文件。然后去配置Ingest Node中的pipeline、然后对存储的数据进行kibana的合理的可视化配置。Filebeat看到了这些数据做起来是比较复杂的。所以官方推出了一些模块、把常用的日志格式做了统一化的处理达到开箱急用的配置。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/101.png" alt=""></p>
</li>
</ol>
<h4 id="3-5-Filebeat演示"><a href="#3-5-Filebeat演示" class="headerlink" title="3.5 Filebeat演示"></a>3.5 Filebeat演示</h4><p>实际演示Filebeat收集nginx log<br>1.我们通过stdin收集日志。<br>2.通过console输出结果。  </p>
<p>实践  </p>
<ol>
<li>1.下载Filebeat(Filebeat是基于go开发、需要下载不同的安装包)  </li>
<li><p>2.查看我们需要收集的nginx日志<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/102.png" alt="">  </p>
</li>
<li><p>3.配置我们的filebeat<br>a.input_type: stdin (我们从标准输入流获取数据)<br>b.output.console: pretty: true  </p>
</li>
<li><p>4.接下来用filebeat:收集nginx的两条数据<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/103.png" alt="">  </p>
</li>
<li><p>5.最后获取到的信息是:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/104.png" alt="">  </p>
</li>
</ol>
<h4 id="3-6-Packetbeat简介"><a href="#3-6-Packetbeat简介" class="headerlink" title="3.6 Packetbeat简介"></a>3.6 Packetbeat简介</h4><h5 id="3-6-1-简介"><a href="#3-6-1-简介" class="headerlink" title="3.6.1 简介"></a>3.6.1 简介</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/105.png" alt=""><br>拥有了Packetbeat类似于就拥有了轻量级的wireshake<br>1.实时抓取网络包<br>2.自动解析应用层协议  </p>
<h5 id="3-6-2-demo抓取es的网络数据包"><a href="#3-6-2-demo抓取es的网络数据包" class="headerlink" title="3.6.2 demo抓取es的网络数据包"></a>3.6.2 demo抓取es的网络数据包</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/106.png" alt="">  </p>
<p>1 1.指定网卡:lo0  </p>
<ol>
<li>2.protocols:指定协议  </li>
<li>3.ports:指定端口  </li>
<li>4.send_request:true 指定request请求的body,默认为false   </li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/107.png" alt="">  </p>
<h4 id="3-7-Packetbeat演示"><a href="#3-7-Packetbeat演示" class="headerlink" title="3.7 Packetbeat演示"></a>3.7 Packetbeat演示</h4><ol>
<li>1.下载包  </li>
<li>2.我们抓取es的包、首先我们把es跑起来  </li>
<li>3.检查配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/108.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/109.png" alt="">  </li>
<li><p>4.运行paketbeat：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/110.png" alt="">  </p>
</li>
<li><p>5.查看paketbeat输出<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/111.png" alt="">  </p>
</li>
</ol>
<h3 id="4、Logstash入门"><a href="#4、Logstash入门" class="headerlink" title="4、Logstash入门"></a>4、Logstash入门</h3><h4 id="4-1-Logstash简介"><a href="#4-1-Logstash简介" class="headerlink" title="4.1 Logstash简介"></a>4.1 Logstash简介</h4><ol>
<li>1.Logstash定义为一个:Data Shipper、他比Beats的定义少了一个light-weight<br>也就是说Logstash不是轻量级的、会比Beats占用更多的资源。所以会占用一定的资源、当然功能 也会越强大。</li>
<li><p>2.Logstash其实就是具备ETL的功能、对数据进行以下操作:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/112.png" alt="">  </p>
</li>
<li><p>3.处理流程(其实就是3步:input、Filter、Output)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/113.png" alt="">  </p>
</li>
</ol>
<h4 id="4-2-Logstash配置"><a href="#4-2-Logstash配置" class="headerlink" title="4.2 Logstash配置"></a>4.2 Logstash配置</h4><h5 id="4-2-1-我们看下Input和Output配置。"><a href="#4-2-1-我们看下Input和Output配置。" class="headerlink" title="4.2.1 我们看下Input和Output配置。"></a>4.2.1 我们看下Input和Output配置。</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/114.png" alt=""> </p>
<ol>
<li>1.logstash的配置不是yml文件、指定的是一个file文件、path路径是在tmp文件下面的。  </li>
<li>2.output是指标准输出、指定的编码是:rubydebug  </li>
</ol>
<h5 id="4-2-2-Filter配置"><a href="#4-2-2-Filter配置" class="headerlink" title="4.2.2 Filter配置"></a>4.2.2 Filter配置</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/115.png" alt=""><br>实例:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/116.png" alt="">  </p>
<h4 id="4-3-Logstash演示"><a href="#4-3-Logstash演示" class="headerlink" title="4.3 Logstash演示"></a>4.3 Logstash演示</h4><p>我们使用Logstash收集nginx log  经过logstash输出日志会是怎样子?<br>我们正常下载Logstash，然后解压，最后我们进入:nginx_logstash.conf,主要是需要配置3个地方。logstash有3大配置:input配置、filter配置、output配置。</p>
<ol>
<li>1.input<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/20.png" alt=""><br>标准输入</li>
<li>2.filter<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/21.png" alt=""></li>
<li>3.output</li>
</ol>
<p>我们启动logstash<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/22.png" alt="">  </p>
<h3 id="5、案例实战"><a href="#5、案例实战" class="headerlink" title="5、案例实战"></a>5、案例实战</h3><h4 id="5-1-实战目标和方案介绍"><a href="#5-1-实战目标和方案介绍" class="headerlink" title="5.1 实战目标和方案介绍"></a>5.1 实战目标和方案介绍</h4><p>我们此次实践的目标:  </p>
<ol>
<li>1.收集Elasticsearch集群的查询语句。  </li>
<li>2.分析查询语句的常用语句、相应时长等。</li>
</ol>
<p>方案:</p>
<ol>
<li>1.应用Packetbeat+Logstash完成数据收集工作  </li>
<li>2.使用Kibaba+Elasticsearch完成数据分析工作  </li>
</ol>
<p>架构图如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/23.png" alt="">  </p>
<ol>
<li>1.Production cluster就是我们业务集群  我们现在监控他的es查询语句情况  </li>
<li>2.做法:我们用Packetbeat监听Production cluster端口、然后所有的查询语句通过网络抓包的形式都可以获取到、然后Packetbeat将所有数据发送到logstash、然后发送给监控集群、最后通过监控集群发送给Kibana。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/24.png" alt="">   </li>
</ol>
<p>方案之logstash:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/30.png" alt="">   </p>
<ol>
<li>1.input输入:接收beats的数据 监听的端口是:5044  </li>
<li>2.filter中:如果request请求中包含search的关键字、我们再做grok处理  </li>
<li>3.output中也做了判断:请求中有search时候、我们输出到 elasticsearch  </li>
</ol>
<p>方案之packetbeat:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/31.png" alt="">  </p>
<h4 id="5-2-实战之数据收集演示"><a href="#5-2-实战之数据收集演示" class="headerlink" title="5.2 实战之数据收集演示"></a>5.2 实战之数据收集演示</h4><h5 id="5-2-1-启动elasticsearch"><a href="#5-2-1-启动elasticsearch" class="headerlink" title="5.2.1 启动elasticsearch"></a>5.2.1 启动elasticsearch</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/32.png" alt="">  </p>
<h5 id="5-2-2-启动Kinbana"><a href="#5-2-2-启动Kinbana" class="headerlink" title="5.2.2 启动Kinbana"></a>5.2.2 启动Kinbana</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/33.png" alt="">   </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/24/ElasticStack-2-入门/" class="archive-article-date">
  	<time datetime="2019-06-24T15:47:55.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ElasticStack/">ElasticStack</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ElasticStack-1-前言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/24/ElasticStack-1-前言/">ElasticStack-1-前言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-为什么使用ElasticStack"><a href="#1-为什么使用ElasticStack" class="headerlink" title="1.为什么使用ElasticStack"></a>1.为什么使用ElasticStack</h4><p>我们知道的一般大数据分析工具有如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/57.png" alt=""><br>我们为什么还需要使用ElasticStack呢?<br>原因:  </p>
<ol>
<li>1.使用门槛低、开发周期短、上线快<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/58.png" alt="">  </li>
<li>2.性能好、查询快、实时展示结果<br>对T+1说不，以前我们查询数据结果，都是时隔一段时间或者一天再分析，现在我们需要”现在、立刻马上要数据”  </li>
<li><p>3.扩容方便、快速支撑增长迅猛的数据<br>刚开始也许只是GB数据、随着业务量变大、TB、PB级别的数据也不是问题。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/59.png" alt=""> </p>
<h4 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h4><h5 id="2-1-ElasticStack组成"><a href="#2-1-ElasticStack组成" class="headerlink" title="2.1 ElasticStack组成"></a>2.1 ElasticStack组成</h5><p>传统的ELK其实就是:Elasticsearch、Logstash、Kibana，自从加入了Beats后,进行升级，变成了Elastic Stack。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/60.png" alt="">   </p>
<h5 id="2-2-各个模块功能"><a href="#2-2-各个模块功能" class="headerlink" title="2.2 各个模块功能"></a>2.2 各个模块功能</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/61.png" alt="">  </p>
</li>
<li><p>1.Elasticsearch主要是做数据处理的  </p>
</li>
<li>2.Beats和    Logstash是做数据收集与处理，相当于早期的ETL<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/62.png" alt=""></li>
<li>3.Kibna数据搜索与可视化分析<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/63.png" alt=""></li>
</ol>
<h5 id="2-3-ElasticStack功能"><a href="#2-3-ElasticStack功能" class="headerlink" title="2.3 ElasticStack功能"></a>2.3 ElasticStack功能</h5><p>一定要内外兼修、不仅仅会使用API还得了解原理。  </p>
<ol>
<li>1.ElasticStack是一个完备的数据分析工具集合<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/64.png" alt=""></li>
<li>2.学习安排:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/65.png" alt="">  </li>
<li><p>3.Elasticsearch篇章讲解举例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/66.png" alt="">  </p>
</li>
<li><p>4.实践项目<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/67.png" alt=""> </p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/24/ElasticStack-1-前言/" class="archive-article-date">
  	<time datetime="2019-06-24T14:40:53.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ElasticStack/">ElasticStack</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-7-服务网管" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/15/SpringCloud-7-服务网管/">SpringCloud-7-服务网管</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-服务网关和Zuul"><a href="#1-服务网关和Zuul" class="headerlink" title="1.服务网关和Zuul"></a>1.服务网关和Zuul</h3><h4 id="1-1-为什么需要服务网关"><a href="#1-1-为什么需要服务网关" class="headerlink" title="1.1 为什么需要服务网关"></a>1.1 为什么需要服务网关</h4><p>加入没有网关服务,当前系统起了多个服务,比如：订单、广告、商品、支付、用户。等等…<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/38.png" target="_blank" rel="external"></a> </p>
<p>那么客户端怎么调用呢?和每个服务一步步打交道、显然不现实。需要一个接收request请求的统一入口。充当这个角色的是服务网关。一旦有了服务网关,所有请求都通过他,所以我们需要了解他发挥什么作用,具备什么要素?<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/39.png" target="_blank" rel="external"></a></p>
<h4 id="1-2-服务网关的作用"><a href="#1-2-服务网关的作用" class="headerlink" title="1.2 服务网关的作用"></a>1.2 服务网关的作用</h4><h5 id="1-稳定性、高可用"><a href="#1-稳定性、高可用" class="headerlink" title="1.稳定性、高可用"></a>1.稳定性、高可用</h5><p>保证24小时可用,网络瘫痪、系统全挂、不能提供外面的服务。 </p>
<h5 id="2-性能、并发性"><a href="#2-性能、并发性" class="headerlink" title="2.性能、并发性"></a>2.性能、并发性</h5><p>所有的请求都经过网关、所以网关的压力是巨大的、所以网关的性能也必须高。</p>
<h5 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3.安全性"></a>3.安全性</h5><p>要确保使用服务的安全、防止外部随意访问、比如金融行业、会进行通讯数据的加密措施。</p>
<h5 id="4-扩展性"><a href="#4-扩展性" class="headerlink" title="4.扩展性"></a>4.扩展性</h5><p>各种请求都经过网关服务、所以网关上大有文章可做、可进行扩展。<br>理论上、网关是处理各种非业务功能的绝佳场所。诸如:协议转发、防刷、流量管控、日志监控等。</p>
<h4 id="1-3-常用的网关方案"><a href="#1-3-常用的网关方案" class="headerlink" title="1.3 常用的网关方案"></a>1.3 常用的网关方案</h4><p>网关并非是微服务出来后的新鲜事物。业界成熟的网关服务有:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/40.png" target="_blank" rel="external"></a><br>一代的Zuul在性能上确实没有优势、不能喝nginx比较。当然，二代Zuul有较大的提升。</p>
<p>原始的点餐项目是如下:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/41.png" target="_blank" rel="external"></a></p>
<ol>
<li>1.nginx在前,tomcat在后、nginx做了负载均衡和反向代理。现在我们可以让nginx发挥他负载均衡和反向代理的优势后面的tomcat可以换成Zuul  </li>
<li>2.项目改造过程中、合理利用原来的资源、发挥新加入事物的优势、因地制宜解决问题。<h4 id="1-4-Zuul的特点"><a href="#1-4-Zuul的特点" class="headerlink" title="1.4 Zuul的特点"></a>1.4 Zuul的特点</h4>Zuul相对nginx来说有所不足、但是作为SpringCloud完整微服务生态体系的前置网关服务是一个很不错的选择。有一种说法路由加过滤器等于Zuul<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/42.png" target="_blank" rel="external"></a>  </li>
</ol>
<p><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/43.png" target="_blank" rel="external"></a><br>Zuul的组织架构图如下所示:<br>可以看到,过滤器之间是没有直接通信的,他们是通过Request Context进行数据通信的。<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/44.png" target="_blank" rel="external"></a>  </p>
<p>Zuul的一次Http的生命周期:</p>
<ol>
<li>1.Origin Server就是我们的业务服务。  </li>
<li>2.请求先过来之后会到pre filters这种类型的过滤器,比如我们的参数校验就可以在这里面来做。  </li>
<li>3.routing filters作用就是将http请求转发到Origin Server中去：如果重写http请求可以在这里面做。</li>
<li>4.post filters 这个时候你已经拿到了返回的结果,这个时候如果你想对结果进行处理和加工,可以在这里面来做</li>
<li>5.error Filters如果在前两个filter发生异常时候,就可以在error filter中进行全局异常处理。<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/45.png" target="_blank" rel="external"></a> </li>
</ol>
<h3 id="2-Zuul的使用"><a href="#2-Zuul的使用" class="headerlink" title="2.Zuul的使用"></a>2.Zuul的使用</h3><ol>
<li>1.新建项目api-gateway<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/46.png" target="_blank" rel="external"></a><br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/47.png" target="_blank" rel="external"></a> </li>
<li>2.选择依赖<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/48.png" target="_blank" rel="external"></a>   </li>
<li>3.删除不需要的文件<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/49.png" target="_blank" rel="external"></a>   </li>
<li>4.修改版本一致<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/50.png" target="_blank" rel="external"></a></li>
<li>5.修改配置文件(从统一配置文件中获取配置信息)<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/51.png" target="_blank" rel="external"></a></li>
</ol>
<h4 id="2-1-路由转发"><a href="#2-1-路由转发" class="headerlink" title="2.1 路由转发"></a>2.1 路由转发</h4><p>我们现在实现Zuul的路由转发功能,我们在api-gateway项目的启动类上添加:@EnableZuulProxy。我们现在要实现product服务下请求里面的/product/list</p>
<ol>
<li><p>1.启动我们的product服务(8081端口),然后访问:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/52.png" target="_blank" rel="external"></a>  </p>
</li>
<li><p>2.通过Zuul服务(8084端口)路由转发请求:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/53.png" target="_blank" rel="external"></a><br>只要注册到Eureka上的服务都可以通过:ip:port/服务名/url  </p>
</li>
</ol>
<ol>
<li><p>3.自定义Zuul路由转发地址<br>以上我们是通过默认的路由转发、默认的地址是:ip:port/服务名/url。但是有时候我们不想把服务名暴露出来 而是想用自己定义的路由地址。此时就需要配置Zuul了。<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/55.png" target="_blank" rel="external"></a><br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/54.png" target="_blank" rel="external"></a>  </p>
</li>
<li><p>4.查询Zuul的所有routes,我们可以通过Zuul对应的服务api-gateway启动地址:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/117.png" target="_blank" rel="external"></a>  </p>
</li>
</ol>
<ol>
<li>5.我们如果想要拦截某些请求<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/1.png" target="_blank" rel="external"></a> </li>
</ol>
<h4 id="2-3-Cookie和动态路由"><a href="#2-3-Cookie和动态路由" class="headerlink" title="2.3 Cookie和动态路由"></a>2.3 Cookie和动态路由</h4><h5 id="2-3-1-Cookie"><a href="#2-3-1-Cookie" class="headerlink" title="2.3.1 Cookie"></a>2.3.1 Cookie</h5><p>我们在开发搭建web项目的时候,经常要使用cookie,需要把cookie返回到后端。在这里使用了Zuul组件、默认情况下Cookie是无法传递过去的。如下:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/3.png" target="_blank" rel="external"></a><br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/2.png" target="_blank" rel="external"></a><br>我们从Zuul的配置中可以设置cookie的开启和关闭<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/4.png" target="_blank" rel="external"></a><br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/5.png" target="_blank" rel="external"></a>  </p>
<h5 id="2-3-2-动态路由"><a href="#2-3-2-动态路由" class="headerlink" title="2.3.2 动态路由"></a>2.3.2 动态路由</h5><p>我们能不能改了路由配置之后自动生效了,就是动态路由。如果需要达到动态路由效果。我们只需要将api-gateway的配置放到config配置中心中去。我们如何做到config统一配置中配置改变了我们的api-gateway服务也动态改变了代码。我们添加Zuul的配置类。<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/6.png" target="_blank" rel="external"></a>  </p>
<h4 id="2-4-路由和高可用小结"><a href="#2-4-路由和高可用小结" class="headerlink" title="2.4 路由和高可用小结"></a>2.4 路由和高可用小结</h4><p><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/07/7.png" target="_blank" rel="external"></a>  </p>
<h5 id="2-4-1-典型应用场景"><a href="#2-4-1-典型应用场景" class="headerlink" title="2.4.1 典型应用场景"></a>2.4.1 典型应用场景</h5><ol>
<li><p>1.Zuul的前置过滤器(Pre)<br>a.限流   b.鉴权    c.参数校验调整   d.请求转发  </p>
</li>
<li><p>2.Zuul的后置过滤器(Post)<br>人过留名<br>a.统计  b.日志  </p>
</li>
</ol>
<h5 id="2-4-2-高可用"><a href="#2-4-2-高可用" class="headerlink" title="2.4.2 高可用"></a>2.4.2 高可用</h5><p>所有的请求都需要经过Zuul、所以生产环境中、我们需要部署多台Zuul,以避免单点故障。Zuul的高可用是必须的。  </p>
<ol>
<li>1.多个Zuul节点注册到Eureka Server(将多个节点注册到Eureka Server就可以实现高可用)  </li>
<li>2.Nginx和Zuul “混搭”(使用nginx对外暴露一个url,nginx把请求转发到多个zuul服务上、这样可以做到彼此的取长补短)。</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/15/SpringCloud-7-服务网管/" class="archive-article-date">
  	<time datetime="2019-06-15T03:01:28.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-6-消息和异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: SpringCloud-6-消息和异步<br>date: 2019-05-26 18:44:01<br>tags:</p>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title=" SpringCloud"></a> SpringCloud</h2><h3 id="1-异步和消息"><a href="#1-异步和消息" class="headerlink" title="1.异步和消息"></a>1.异步和消息</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><ol>
<li>1.之前我们使用的方式是同步方式。</li>
<li>2.异步优点:a.客户端请求不会阻塞进程、服务端的相应可以是非及时的。  </li>
<li>3.http常见是支持同步、但是http也是支持异步的。</li>
</ol>
<h4 id="2-异步的常见形态"><a href="#2-异步的常见形态" class="headerlink" title="2.异步的常见形态"></a>2.异步的常见形态</h4><ol>
<li>1.通知</li>
<li>2.请求/异步响应:客户端发送请求到服务端,服务端异步响应,客户端不会阻塞,服务端默认不会立马响应。    </li>
<li><p>3.消息</p>
<h4 id="3-MQ应用场景"><a href="#3-MQ应用场景" class="headerlink" title="3.MQ应用场景"></a>3.MQ应用场景</h4><p>MQ是分布式应用系统最常用的组件。典型应用场景有如下:</p>
</li>
<li><p>1.异步处理:用户注册之后,通过短信服务、积分服务去做他们相应的操作,这样就能提高用户体验。  </p>
</li>
<li>2.流量消峰:一般用于秒杀场景,秒杀过程中一般由于流量较大,会导致应用会挂掉、要解决这个问题。把请求放在消息队列中,如果超过消息队列的长度将抛弃此请求,返回错误信息。 </li>
<li>3.日志处理：这个典型的组件就是kafka，kafka最初的设计就是用于日志处理,大数据里面用的特别多。通过日志采集、定时写入kafka队列，然后kafka队列定时接收 储存 和转发。</li>
<li>应用解耦：比如用户下单后,订单服务需要通知商品服务、之前是订单服务通过调用商品服务的接口,这样订单服务和商品服务是耦合的。使用mq,用户下单后，订单服务完成持续化处理、将消息写入消息队列、返回用户订单下单成功、商品服务来订阅这个消息采用拉或者推形式获取下单信息、商品服务获取到下单信息后进行商品的扣库存等操作。这样达到应解耦。  </li>
</ol>
<h3 id="2-RabbitMQ的基本使用"><a href="#2-RabbitMQ的基本使用" class="headerlink" title="2.RabbitMQ的基本使用"></a>2.RabbitMQ的基本使用</h3><p>我们Order服务使用RabbitMQ实现订单和商品服务解耦。  </p>
<ol>
<li>1.添加热rabbitmq依赖<br>在order服务中server子模块添加以下依赖:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;!--引入RabbitMQ依赖--&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;  </div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line">2. 2.添加配置到github远程仓库  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/94.png)  </div><div class="line"></div><div class="line">3. 3.创建MQ消息接收方  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/95.png)  </div><div class="line"></div><div class="line">4. 4.创建mq发送方进行测试</div><div class="line">我们在测试test文件目录下创建测试类: </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/97.png)   </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/96.png) </div><div class="line"></div><div class="line">测试出现了上面问题,原因是因为没有myQueue队列  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/98.png) </div><div class="line">此时正常启动。  </div><div class="line"></div><div class="line">这个时候一切正常。  </div><div class="line"></div><div class="line">5. 5.以上是我们自己在RabbitMQ中创建的队列。我们是否可以自动创建队列,然后再调用队列接口。</div></pre></td></tr></table></figure>
<p> @RabbitListener(queuesToDeclare = @Queue(“myQueue1”)) //自动创建队列myQueue1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. 6.自动创建并且和队列绑定</div></pre></td></tr></table></figure></p>
<p>  @RabbitListener(bindings =@QueueBinding(value =@Queue(“myQueue”),exchange =@Exchange(“myExchange”)))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2.2 什么情况下需要用到exchange  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/1.png)</div><div class="line">我们现在是一个小小点餐系统,但是如果后面,我们什么都卖,又卖水果,又卖数码,同时对这两种商品下单,商品变多了,人也多了，订单服务是单独的人来维护,数码供应商、水果供应商都是由单独的人来维护。订单服务要根据不同的商品类型发出不同的MQ消息。相对应的、数码供应商只关注数码订单、水果及其他订单不关注。此时就牵涉到消息的分组。 演示如下:  </div><div class="line">1.我们接收方模拟两个接收服务(a.数码服务 b.水果服务)  </div><div class="line">exchange因为都是订单,我们我们叫做myOrder  </div><div class="line">想要分组归类,我们用key  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/2.png)</div><div class="line">2.我们发送方 (类似订单服务)如下: </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/3.png)  </div><div class="line"></div><div class="line"></div><div class="line">### 3.SpringCloudStream的使用 </div><div class="line">可以参数博客:https://www.cnblogs.com/zhixiang-org-cn/p/10093367.html </div><div class="line">#### 3.1.基本介绍  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/4.png)  </div><div class="line">1. 1.应用模型:应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream 中Binder 交互，通过我们配置来绑定，而 Spring Cloud Stream 的 Binder 负责与中间件交互。所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。  </div><div class="line">2. 2.抽象绑定器(The Binder Abstraction):Spring Cloud Stream实现Kafkat和RabbitMQ的Binder实现，也包括了一个TestSupportBinder，用于测试。你也可以写根据API去写自己的Binder.Spring Cloud Stream 同样使用了Spring boot的自动配置，并且抽象的Binder使Spring Cloud Stream的应用获得更好的灵活性，比如：我们可以在application.yml或application.properties中指定参数进行配置使用Kafka或者RabbitMQ，而无需修改我们的代码。  </div><div class="line"></div><div class="line">3. 3.Binder(SpringCloudStream)是应用程序(Application)和消息中间件(Middleware)之间的粘合剂，使用 SpringCloudStream最大的好处莫过于对消息中间件的进一步封装。可以做到代码层面对消息中间件的无感知,设置于动态的切换中间件,但是也有局限:目前SpringCloudStream仅支持2种Binder：一种是RabbitMQ、另一种是Kafka  </div><div class="line"></div><div class="line">#### 3.2.使用SpringCloudStream  </div><div class="line">为了详细了解SpringCloudStream的话,可以详细了解下:https://www.cnblogs.com/leeSmall/p/8900518.html这篇博文。  </div><div class="line">##### 1.引入依赖  </div><div class="line">在order-server.xml中添加如下依赖:</div></pre></td></tr></table></figure></p>
<p><dependency><br>   <groupid>org.springframework.cloud</groupid><br>   <artifactid>spring-cloud-starter-stream-rabbit</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">##### 2.添加mq的配置  </div><div class="line">之前我们已经配置过了,这里可以省略  </div><div class="line"></div><div class="line"></div><div class="line">##### 3.使用stream发送和接收消息  </div><div class="line">1. 1.定义接口:提供输入输出接口</div></pre></td></tr></table></figure></p>
<p>public interface StreamClient {</p>
<pre><code>@Input(&quot;myMessage&quot;)
SubscribableChannel input();

@Input(&quot;myMessage&quot;)
MessageChannel output();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 2.添加stream接收端</div></pre></td></tr></table></figure></p>
<p>@Component<br>@EnableBinding(StreamClient.class)<br>@Slf4j<br>public class StreamReceiver {<br>   @StreamListener(“myMessage”)<br>    public void process(Object message){<br>      log.info(“StreamReceiver:{}”,message);<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 3.添加stream发送端</div></pre></td></tr></table></figure></p>
<p>@RestController<br>public class SendMessageController {<br>    @Autowired<br>    private StreamClient streamClient;</p>
<pre><code>@GetMapping(&quot;/sendMessage&quot;)
public void process(){
    String message = &quot;now &quot; + new Date();
    streamClient.output().send(MessageBuilder.withPayload(message).build());
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">4. 4.测试  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/5.png)   </div><div class="line">有时候我们后端启用2个order服务,然后重启后 客户端发送消息,发现2个都接收到了,那么我们如何多集群情况下,只有一个实例接收消息呢?</div><div class="line">stream里面有个分组,我们配置一下就可以了 那就是使用分组。   </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/10.png)</div><div class="line"></div><div class="line"></div><div class="line">##### 3.使用stream传递对象  </div><div class="line">之前我们在用例中stream传递的是String、实际工作中stream更重要的是传递对象。</div><div class="line">生产者:发送OrderDetail对象  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/11.png)  </div><div class="line"></div><div class="line">消息接受者:  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/12.png)  </div><div class="line"></div><div class="line">下面我们看一下:mq里面接收的是什么格式数据呢?  </div><div class="line">我们在上面看不到消息了,原因是消息已经被消费完了,所以我们需要把接收端,消费消息的停掉。让mq端有消息的累计。</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/13.png)   </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/14.png)   </div><div class="line"></div><div class="line">上面我们可以看到消息是:OrderDTO对象,如果我们需要在MQ中获取的消息是json格式:则在stream的配置中添加：content-type: application/json  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/16.png)    </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/15.png)    </div><div class="line"></div><div class="line">有时候我们的消费者：StreamReceiver消费完消息之后,我们需要给发送者一个通知,传统的做法是在业务逻辑里面后面做处理。  </div><div class="line">现在我们加上注解即可:  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/17.png)  </div><div class="line"></div><div class="line">总结:使用Stream可以降低对消息中间件的复杂度,让开发者更多的关注业务开发。  </div><div class="line"></div><div class="line"></div><div class="line">### 4.商品和订单服务中使用MQ  </div><div class="line">#### 4.1 引言  </div><div class="line">我们结合点餐业务来使用mq</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/18.png)  </div><div class="line">1. 1.之前我们按照上面图提示到:一旦有库存的变化(商品)、都会发布一个消息、订单拿到这个消息之后,会把库存的消息记录到自己的服务里面(这里我们把他记录到redis里面)</div><div class="line">2. 2.导致库存的变化有很多种:a.第一次商品上线的时候,会填写库存,这个时候库存就变化了。b.还有就是货物快卖完的时候需要补货。相当于加库存。我们以扣库存为例,使用消息队列进行通信。</div><div class="line"></div><div class="line">#### 4.2 product服务接入到配置中心  </div><div class="line">1. 1.添加配置中心的依赖  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/19.png)  </div><div class="line">2. 2.修改appliaction.yml文件为:bootstrap.yml文件,并修改其中的配置  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/21.png) </div><div class="line"></div><div class="line">3. 3.在github上建立对应的product-dev.yml文件,并将共有的信息拷贝到里面去  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/20.png) </div><div class="line">4. 4.在config服务中看是否可以访问到此配置文件。  </div><div class="line">5. 5.启动时候正常启动:说明我们已经把product服务接入到配置中心了。  </div><div class="line"></div><div class="line">#### 4.3 product服务在扣库存时候发送队列消息    </div><div class="line">1. 1.添加springBoot里面的amqp依赖  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/22.png) </div><div class="line"></div><div class="line">2. 2.在统一配置中心中添加mq的连接信息  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/23.png)  </div><div class="line"> </div><div class="line">#### 4.4 product服务在扣库存地方操作消息队列  </div><div class="line">我们在扣库存的service中添加扣库存(decreaseStock)后消息通知:  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/24.png)  </div><div class="line"></div><div class="line">然后我们使用postman测试:  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/25.png)  </div><div class="line">数据库里面的库存从33变成32,数据库扣除成功了</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/26.png)  </div><div class="line">但是我们登录mq的管理后端却发现没有对应的amqpTemplate的productInfo队列，</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/27.png)</div><div class="line">为什么没有这个队列呢?原因是因为我们压根就没有创建队列，只有在接收方添加注解:@RabbitListener注解才会自动创建，我们 上面只有发送方,所以我们先手动创建下:然后点几次发送,后面发现我们在消息队列中有了相应的消息:</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/28.png)</div><div class="line"></div><div class="line"></div><div class="line">以上就完成了消息的发送,现在消息已经从商品服务发送到消息队列里面了,接下来我们要在订单服务接收消息。</div><div class="line">在Order服务的message包下面添加接收消息:</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/29.png)  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/30.png)  </div><div class="line"></div><div class="line">我们先删除之前的productInfo队列,然后重启服务会发现会自动创建队列  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/31.png) </div><div class="line"></div><div class="line">#### 4.5 Order服务获取到扣库存信息存储到redis  </div><div class="line">我们order服务获取到了product服务发送的信息,现在需要把这些信息存储到redis中  </div><div class="line">redis可以使用docker安装、也可以使用自己免安装的版本  </div><div class="line"></div><div class="line">1. 1.项目中引入依赖(order-server中pom.xml)</div></pre></td></tr></table></figure></p>
<p><dependency><br>            <groupid>org.springframework.cloud</groupid><br>            <artifactid>spring-boot-starter-data-redis</artifactid><br>        </dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 2.配置redis里面的参数,在统一配置中心添加</div></pre></td></tr></table></figure></p>
<p>spring:<br>  redis:<br>    host: localhost<br>    port: 6379<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 3.书写存储到redis(使用StringRedisTemplate)  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/32.png) </div><div class="line"></div><div class="line">4. 4.postman测试</div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/33.png) </div><div class="line"></div><div class="line">#### 4.6 残留的问题  </div><div class="line">[](https://raw.githubusercontent.com/startshineye/img/master/2019/06/34.png)  </div><div class="line">1. 1.从上面我们知道:扣库存是遍历了商品,然后操作数据库,再然后就是发送mq消息,假如decreaseStockInputList长度大于1,我们第一件商品扣库存之后、发送消息到mq,但是第二件商品报了异常,由于有事务,数据库会回滚,但是mq里面的消息不会回滚,所有有脏数据。</div><div class="line">2. 2.我们修改下,我们在数据库扣完库存之后再发mq消息  </div><div class="line">Product服务修改:</div></pre></td></tr></table></figure></p>
<p>@Override<br>    public void decreaseStock(List<decreasestockinput> decreaseStockInputList) {<br>        //1.获取到扣库存列表<br>        List<productinfo> productInfoList = decreaseStockProcess(decreaseStockInputList);<br>        //2.转换成ProductInfoOutput列表<br>        List<productinfooutput> productInfoOutputList = productInfoList.stream().map(e -&gt; {<br>            ProductInfoOutput output = new ProductInfoOutput();<br>            BeanUtils.copyProperties(e, output);<br>            return output;<br>        }).collect(Collectors.toList());<br>        //3.发送mq消息<br>        amqpTemplate.convertAndSend(“productInfo”, JsonUtil.toJson(productInfoOutputList));<br>    }</productinfooutput></productinfo></decreasestockinput></p>
<pre><code>@Transactional(rollbackFor = Exception.class)
public List&lt;ProductInfo&gt;  decreaseStockProcess(List&lt;DecreaseStockInput&gt; decreaseStockInputList) {
    /**
     * 遍历:查看是否存在
     */
    List&lt;ProductInfo&gt; productInfoList = new ArrayList&lt;&gt;();
    for (DecreaseStockInput cartDTO:decreaseStockInputList){
        Optional&lt;ProductInfo&gt; productInfoOptional = repository.findById(cartDTO.getProductId());
        //商品不存在
        if(!productInfoOptional.isPresent()){
            throw new ProductException(ResultEnum.PRODUCT_NOT_EXIST);
        }
        //商品存在-库存错误
        ProductInfo productInfo = productInfoOptional.get();
        int result = productInfo.getProductStock() - cartDTO.getProductQuantity();
        if(result&lt;0){
            throw new ProductException(ResultEnum.PRODUCT_STOCK_ERROE);
        }
        //保存
        productInfo.setProductStock(result);
        repository.save(productInfo);
        productInfoList.add(productInfo);
    }
    return productInfoList;
}
</code></pre><p>```</p>
<p>Order服务修改:<br>JsonUtil添加如下方法:<br><a href="https://raw.githubusercontent.com/startshineye/img/master/2019/06/35.png" target="_blank" rel="external"></a>  </p>
<h3 id="5-异步和库存分析"><a href="#5-异步和库存分析" class="headerlink" title="5.异步和库存分析"></a>5.异步和库存分析</h3><p>项目改造成异步后,数据一致性等问题是经常遇到的,很多时候在单体服务中,依靠本地事务,我们很容易保证数据的一致性。但是一旦切换到分布式异步情况下就很可能出现数据不一致的情况。比如这里的发消息,数据库回滚数据是自动的。消息多发了要怎么办？这个就需要重新仔细考虑,稍不留神机会出错。下面我们以下面通路进一步看下更多考虑的点。<br>参考一下链接:<a href="https://cloud.tencent.com/developer/article/1344252" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1344252</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/26/SpringCloud-6-消息和异步/" class="archive-article-date">
  	<time datetime="2019-05-26T10:44:01.572Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-26</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/50/">50</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/CTI/" style="font-size: 11.05px;">CTI</a> <a href="/tags/Cookie/" style="font-size: 10.53px;">Cookie</a> <a href="/tags/DevelopmentSkills/" style="font-size: 10px;">DevelopmentSkills</a> <a href="/tags/Easyui/" style="font-size: 10px;">Easyui</a> <a href="/tags/ElasticStack/" style="font-size: 11.05px;">ElasticStack</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IE问题/" style="font-size: 10px;">IE问题</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 12.11px;">JVM</a> <a href="/tags/JavaSE/" style="font-size: 15.26px;">JavaSE</a> <a href="/tags/Jeecg/" style="font-size: 11.58px;">Jeecg</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Myeclipse/" style="font-size: 14.21px;">Myeclipse</a> <a href="/tags/Netty/" style="font-size: 16.84px;">Netty</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 16.84px;">Oracle</a> <a href="/tags/Redis/" style="font-size: 12.11px;">Redis</a> <a href="/tags/Servlet/" style="font-size: 11.58px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 10.53px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/SpringBoot/" style="font-size: 19.47px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 12.11px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 11.05px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Vue/" style="font-size: 18.95px;">Vue</a> <a href="/tags/Vue-js-前端开发-快速入门与专业应用/" style="font-size: 17.37px;">Vue.js+前端开发+快速入门与专业应用</a> <a href="/tags/Weblogic/" style="font-size: 12.11px;">Weblogic</a> <a href="/tags/Websocket/" style="font-size: 10.53px;">Websocket</a> <a href="/tags/Work-Problem/" style="font-size: 10px;">Work-Problem</a> <a href="/tags/bg/" style="font-size: 10px;">bg</a> <a href="/tags/c/" style="font-size: 10.53px;">c</a> <a href="/tags/crawler/" style="font-size: 17.89px;">crawler</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/easyui/" style="font-size: 10px;">easyui</a> <a href="/tags/freeswitch/" style="font-size: 10px;">freeswitch</a> <a href="/tags/hibernate/" style="font-size: 10.53px;">hibernate</a> <a href="/tags/html-css/" style="font-size: 10.53px;">html+css</a> <a href="/tags/html-css/" style="font-size: 15.26px;">html-css</a> <a href="/tags/html-ss/" style="font-size: 10px;">html-ss</a> <a href="/tags/im/" style="font-size: 13.68px;">im</a> <a href="/tags/ipcc/" style="font-size: 10.53px;">ipcc</a> <a href="/tags/jQuery/" style="font-size: 12.11px;">jQuery</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/java-String/" style="font-size: 10px;">java String</a> <a href="/tags/javaSE/" style="font-size: 10.53px;">javaSE</a> <a href="/tags/javaWeb/" style="font-size: 10px;">javaWeb</a> <a href="/tags/javascript/" style="font-size: 11.05px;">javascript</a> <a href="/tags/java并发编程/" style="font-size: 11.58px;">java并发编程</a> <a href="/tags/java集合/" style="font-size: 10.53px;">java集合</a> <a href="/tags/junit测试/" style="font-size: 10px;">junit测试</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 16.32px;">linux</a> <a href="/tags/log4j/" style="font-size: 11.58px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/netty/" style="font-size: 11.58px;">netty</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodeJs/" style="font-size: 10px;">nodeJs</a> <a href="/tags/redis/" style="font-size: 12.63px;">redis</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/shiro/" style="font-size: 12.63px;">shiro</a> <a href="/tags/sockJs/" style="font-size: 10px;">sockJs</a> <a href="/tags/socket网络编程/" style="font-size: 10.53px;">socket网络编程</a> <a href="/tags/struts1/" style="font-size: 11.05px;">struts1</a> <a href="/tags/vue/" style="font-size: 10.53px;">vue</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weblogic/" style="font-size: 11.05px;">weblogic</a> <a href="/tags/websocket/" style="font-size: 15.79px;">websocket</a> <a href="/tags/work/" style="font-size: 14.74px;">work</a> <a href="/tags/zyzx/" style="font-size: 18.42px;">zyzx</a> <a href="/tags/代理/" style="font-size: 11.58px;">代理</a> <a href="/tags/前端/" style="font-size: 10.53px;">前端</a> <a href="/tags/动手写一个MVC/" style="font-size: 12.11px;">动手写一个MVC</a> <a href="/tags/反射/" style="font-size: 15.79px;">反射</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/微博/" style="font-size: 10px;">微博</a> <a href="/tags/文件读取/" style="font-size: 10px;">文件读取</a> <a href="/tags/泛型/" style="font-size: 13.16px;">泛型</a> <a href="/tags/注解/" style="font-size: 11.05px;">注解</a> <a href="/tags/类加载器/" style="font-size: 13.16px;">类加载器</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/自己写一个apache服务器/" style="font-size: 16.84px;">自己写一个apache服务器</a> <a href="/tags/转载/" style="font-size: 12.11px;">转载</a> <a href="/tags/集合/" style="font-size: 12.11px;">集合</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>