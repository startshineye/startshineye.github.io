<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/page/4/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-work-9-maven仓库包下载不下来" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/18/work-9-maven仓库包下载不下来/">work-9-maven仓库包下载不下来</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有时候,我们通过配置本地maven后发现对应的包下载不下来,可参考如下:<a href="https://www.jianshu.com/p/7861c6f2b517" target="_blank" rel="external">https://www.jianshu.com/p/7861c6f2b517</a>  </p>
<p>java对应的日志操作：<a href="https://blog.csdn.net/u010598111/article/details/80556437" target="_blank" rel="external">https://blog.csdn.net/u010598111/article/details/80556437</a>  </p>
<p><a href="https://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html" target="_blank" rel="external">https://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html</a></p>
<h4 id="2-SpringBoot2-x-整合druid-并将数据库密码加密"><a href="#2-SpringBoot2-x-整合druid-并将数据库密码加密" class="headerlink" title="2.SpringBoot2.x 整合druid,并将数据库密码加密"></a>2.SpringBoot2.x 整合druid,并将数据库密码加密</h4><p><a href="https://www.jianshu.com/p/7cf0ceb72f73" target="_blank" rel="external">https://www.jianshu.com/p/7cf0ceb72f73</a>  </p>
<p><a href="https://www.bywei.cn/post/782.html" target="_blank" rel="external">https://www.bywei.cn/post/782.html</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/18/work-9-maven仓库包下载不下来/" class="archive-article-date">
  	<time datetime="2019-05-18T11:14:37.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-18</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/work/">work</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ipcc-1-ipcc整体架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/ipcc-1-ipcc整体架构/">ipcc-1-ipcc整体架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-ipcc总体架构模块"><a href="#1-ipcc总体架构模块" class="headerlink" title="1.ipcc总体架构模块"></a>1.ipcc总体架构模块</h3><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/37.png" alt=""> </p>
<h3 id="2-系统模块图"><a href="#2-系统模块图" class="headerlink" title="2.系统模块图"></a>2.系统模块图</h3><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/213.png" alt=""></p>
<h4 id="2-1-acd模块"><a href="#2-1-acd模块" class="headerlink" title="2.1 acd模块"></a>2.1 acd模块</h4><ol>
<li><p>1.acd模块<br>acd在平台中的位置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/214.png" alt="">  </p>
</li>
<li><p>2.配置坐席呼出<br><a href="https://blog.csdn.net/weixin_34242819/article/details/90492301" target="_blank" rel="external">https://blog.csdn.net/weixin_34242819/article/details/90492301</a><br>对于登录坐席工号进行呼出的情况,我们有如下步骤:1.坐席签入后能上线成功  2.坐席能够正确路由到运营商的sip电话进行呼叫  </p>
</li>
</ol>
<h5 id="2-1-1-坐席签入后能上线成功"><a href="#2-1-1-坐席签入后能上线成功" class="headerlink" title="2.1.1 坐席签入后能上线成功"></a>2.1.1 坐席签入后能上线成功</h5><h6 id="坐席上线"><a href="#坐席上线" class="headerlink" title="坐席上线"></a>坐席上线</h6><p>1.在cti_work表中找到分机,如:100003。<br>2.配置100003到cti_work_queue中去<br>3.在cti_outcaller中配置上线的主叫<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/64.png" alt=""><br>3.在cti_telno中配置分机路由:100003分机呼出使用内线字段、长度在1-6(因为:100003是6位数)、<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/215.png" alt=""><br>4.查看/cc/bin/log下面的日志:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/62.png" alt=""><br>发现话机没有注册,打开一看:是注册的服务错了<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/63.png" alt=""><br>5.如果出问题,查看Acdgate模块下Tomcat日志,在查看/cc/log/acd_acd01.log下的日志<br>acd_acd01.log里面r:开头的。   </p>
<h6 id="机器人锁定坐席转人工"><a href="#机器人锁定坐席转人工" class="headerlink" title="机器人锁定坐席转人工"></a>机器人锁定坐席转人工</h6><p>我们在排查之前可以关掉hmp,设置:hmpcheck=0<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/69.png" alt=""><br>1.在确保坐席能够上线情况下,先配置转人工的机器人场景:1013502011<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/65.png" alt=""><br>2.在批次场景里面创建人批次场景,然后创建对应批次,进行外呼<br>3.查看acd_acd01_xxxx.log下的日志:锁定坐席成功与否?—&gt;TRptque::getandlockagent<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/66.png" alt=""><br>4.外呼后查看日志:httpg_httpg01_xxxx.log<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/67.png" alt=""><br>查看机器人转人工文档说明书知道:”att_status”:”0”不在线，”att_status”:”1”在线<br>5.如果和ai交互时候,传递的参数不对的话,我们查看acd模块:<br>TRptque::getandlockagent res=[-1]表示没有获取到空闲坐席<br>6.如果转人工时候,坐席挂不断,说明是坐席表里面的相同workno有多条。  </p>
<p>6.正常交互如下:<br>acd:2019-09-15 09:48:03.453 TRptque::getandlockagent res=[0], workno=[100002] quueueid=[52] usid = [90046126300563]<br>httpg:ai获取空闲坐席:key:[{“userid”:”900461263”,”inaction”:0,”inparams”:{“call_id”:”900461263”,”call_sor_id”:”15188317019”,”call_dst_id”:”051289578445”,”att_status”:”1”}}].<br>ai转人工传递queueid:ok:0,resultbuf[{“ret”:0,”userid”:”900461263”,”outaction”:”11”,”outparams”:{“call_dst_id”:”051289578445”,”queue_id”:”52”,”call_id”:”900461263”,”inter_idx”:”8”,”call_sor_id”:”15188317019”}}].   </p>
<h5 id="2-1-2-正确路由到运营商的sip电话进行呼叫"><a href="#2-1-2-正确路由到运营商的sip电话进行呼叫" class="headerlink" title="2.1.2 正确路由到运营商的sip电话进行呼叫"></a>2.1.2 正确路由到运营商的sip电话进行呼叫</h5><p>1.acd.cfg配置(配置是不是开启did,did是优先级最高的,如果开启,呼叫客户的主叫号码将会是did号码-DID的中文意思是直接拨入，是运营商提出的概念，通过这个号码，运营商可以呼叫到voip系统内，freeswitch上实现外乎呼叫的方式为配置一个网关，指定运营商的接入号和密码，有呼叫这个号码时，运营商会把这个号码送给freeswitch。)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/216.png" alt=""><br>2.acd.cfg配置(设置使用的主叫号码:usefromcaller,如果想要使用cti_work里面的,需要配置为1)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/217.png" alt=""><br>3.配置坐席呼出的主叫显示:cti_outcaller<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/218.png" alt=""><br>4.使用web页面上的软电话条进行呼叫,然后查看呼叫的结果里面是不是我们配置的主叫<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/219.png" alt=""><br>从上面我们可以知道,坐席呼出时候是两通电话。</p>
<h4 id="2-2-fsg模块"><a href="#2-2-fsg模块" class="headerlink" title="2.2.fsg模块"></a>2.2.fsg模块</h4><p>FSG模块作为:AG(CTI)和FS进行交互模块,其作用就是一个接口调用服务。<br>对应的配置文件是:/cc/cfg/fsg.cfg<br>对应的日志文件是:/cc/log/fsg<em>**</em>.log和/cc/bin/log/log*.log<br>其日志记录了ipcc内部和外部中继网络交互的日志详情。  </p>
<h5 id="2-2-1-fsg模块修改日志"><a href="#2-2-1-fsg模块修改日志" class="headerlink" title="2.2.1.fsg模块修改日志"></a>2.2.1.fsg模块修改日志</h5><p>有时候,我们为了排查和外部对接的错误信息时候,可以通过两种方式:<br>1.修改fsg的日志级别为6<br>2.通过tcpdump -w xx.cap抓包<br>以下为修改fsg的日志级别为6的设置  </p>
<h6 id="2-2-1-1-删除原来的fsg相关日志文件"><a href="#2-2-1-1-删除原来的fsg相关日志文件" class="headerlink" title="2.2.1.1.删除原来的fsg相关日志文件"></a>2.2.1.1.删除原来的fsg相关日志文件</h6><ol>
<li>删除/cc/bin/log文件目录下的文件  </li>
<li>删除/cc/log/fsg*.log文件  <h6 id="2-2-1-2-修改日志级别配置文件fsg-cfg"><a href="#2-2-1-2-修改日志级别配置文件fsg-cfg" class="headerlink" title="2.2.1.2.修改日志级别配置文件fsg.cfg"></a>2.2.1.2.修改日志级别配置文件fsg.cfg</h6></li>
<li>修改fsg.cfg里面SET下的日志级别文件为6<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/18.png" alt=""><br>acd在平台起到用户转座席排队，座席分配，座席操作控制等和座席呼叫相关的功能。<h6 id="2-2-1-3-以写入文件的方式启动fsg-sh"><a href="#2-2-1-3-以写入文件的方式启动fsg-sh" class="headerlink" title="2.2.1.3.以写入文件的方式启动fsg.sh"></a>2.2.1.3.以写入文件的方式启动fsg.sh</h6>进入/cc/bin下输入</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fsg.sh restart &gt; /cc/bin/log/xxx.log</div></pre></td></tr></table></figure>
<h4 id="2-3-ag模块"><a href="#2-3-ag模块" class="headerlink" title="2.3 ag模块"></a>2.3 ag模块</h4><h5 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h5><p>AG在整个YC平台中起着集中管理的作用。AG模块就是我们常说的CTI模块。<br>AG起的作用有以下几点：<br>1、    管理多个适配节点的接入。<br>2、    统一对多个节点的电路进行全局编号。<br>3、    对电路进行分组管理。<br>4、    呼入电话路由相应的IVR流程进行处理。<br>5、    呼出电话路由到相应的电路组。<br>6、    管理呼叫电话分配媒体资源（播音，录音，会议，传真等媒体资源）</p>
<h5 id="2-3-2-呼叫问题排查-AG问题排查"><a href="#2-3-2-呼叫问题排查-AG问题排查" class="headerlink" title="2.3.2 呼叫问题排查(AG问题排查)"></a>2.3.2 呼叫问题排查(AG问题排查)</h5><p>理解T、HT、R、HR是理解ag模块的关键  </p>
<ol>
<li>1.按照流程来:T是收到  R是发送 HR是收到发送端的消息 HT是给T端返回信息  </li>
<li>2.对于AG来说:T端是ACD、Dyflow等;R端是fsg  </li>
<li>3.对于FSG来说: T端是ag  R是fsapi  </li>
<li>4.ACD等来说:T端是自己 R端是ag  </li>
</ol>
<p>我们查相关日志时候,先从ag模块(cti模块)查询起,然后一次找到T、R。<br>分析:看ag的日志—&gt;这种交互ag的日志是两边都有的–&gt;从ag里面开始分析—&gt;平台挂机0、200是用户挂的—&gt;从ag开始看确定消息在什么地方不对了 然后再分析fsg测 或者是ivr测的日志<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/10/37.png" alt="">  </p>
<h4 id="2-日志文件模块"><a href="#2-日志文件模块" class="headerlink" title="2.日志文件模块"></a>2.日志文件模块</h4><h5 id="2-1-查看和机器人交互日志"><a href="#2-1-查看和机器人交互日志" class="headerlink" title="2.1.查看和机器人交互日志"></a>2.1.查看和机器人交互日志</h5><p>和机器人交互日志都是通过ivr流程中http传数据,所以在httpg日志,需要看就提详细信息可以看dyflow日志</p>
<h5 id="2-2-查看任务加载-工作日-时间段-呼叫情况"><a href="#2-2-查看任务加载-工作日-时间段-呼叫情况" class="headerlink" title="2.2.查看任务加载,工作日,时间段,呼叫情况"></a>2.2.查看任务加载,工作日,时间段,呼叫情况</h5><ol>
<li>1.任务即是notify,但是任务在呼叫前任务加载,工作日,时间段都是在dbg_dbg01模块</li>
<li>2.查看任务呼叫情况:callnotify_callnotify01.log  </li>
<li>3.查看任务调用api模块:callnotify_callnotifyapi.log  </li>
<li>4.查看任务呼叫失败情况,没有数据插入到cti_cdr、ocm_result：查看callnotify_callnotifyfailsql.log  </li>
</ol>
<h4 id="3-ipcc对接其他server"><a href="#3-ipcc对接其他server" class="headerlink" title="3.ipcc对接其他server"></a>3.ipcc对接其他server</h4><p>参考:<a href="https://blog.csdn.net/gredn/article/details/40581871" target="_blank" rel="external">https://blog.csdn.net/gredn/article/details/40581871</a></p>
<h5 id="3-1-修改freeswitch配置"><a href="#3-1-修改freeswitch配置" class="headerlink" title="3.1 修改freeswitch配置"></a>3.1 修改freeswitch配置</h5><p>从平台架构我们知道,我们现在需要和外部第三方sipServer对接,首先需要打通各自的网络,然后就是配置相关的网管  </p>
<ol>
<li>1.进入freeswitch目录下freeswitch/conf/sip_profiles/external其中有外部网管模块。 拷贝存在的一个网关配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/62.png" alt="">  </li>
<li>2.修改gw3.xml中对接的外部sipServer地址和端口:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/63.png" alt=""> </li>
<li>3.重启freeswitch<br>进入freeswitch的bin目录停止fs:./freeswitch -stop<br>进入freeswitch的bin目录启动fs:./freeswitch -nc -nonat  </li>
</ol>
<h5 id="3-2-修改号码网管路由"><a href="#3-2-修改号码网管路由" class="headerlink" title="3.2 修改号码网管路由"></a>3.2 修改号码网管路由</h5><ol>
<li>1.修改cti_route表<br>打开数据库表cti_route配置主叫外显号码和网关对应的关系<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/64.png" alt=""> </li>
<li>2.重启fsg<br>进入/cc/bin目录下:执行:./fsg.sh restart  </li>
</ol>
<h5 id="3-3-使用抓包工具抓包"><a href="#3-3-使用抓包工具抓包" class="headerlink" title="3.3 使用抓包工具抓包"></a>3.3 使用抓包工具抓包</h5><p>对接完之后,如果电话不通,那么就需要使用wireshake进行网络抓包,分析包  </p>
<h4 id="4-ipcc对每个号码并发进行控制"><a href="#4-ipcc对每个号码并发进行控制" class="headerlink" title="4.ipcc对每个号码并发进行控制"></a>4.ipcc对每个号码并发进行控制</h4><p>在/cc/cfg/notify.cfg下的callnotify添加:examentline=1表明开启了号码并发设置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/6.png" alt="">  </p>
<h4 id="5-ipcc配置空号检测"><a href="#5-ipcc配置空号检测" class="headerlink" title="5.ipcc配置空号检测"></a>5.ipcc配置空号检测</h4><ol>
<li>1.首先正常安装并启用空号检测da2(安装数据库、程序)  </li>
<li>2.如果空号检测部署在一台服务器上，我们呼叫平台部署在多台服务器上，我们如何配置呢?  </li>
<li>3.查看/usr/local/freeswitch/conf下面文件:da2.json<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/7.png" alt="">  </li>
<li>4.重启freeswitch:进入freeswitch的bin目录:执行:./freeswitch -stop 再执行:./freeswitch -nc -nonat  </li>
<li>5.打开freeswitch客户端:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./fs_cli -P 8031 -p testtest</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/8.png" alt=""> </p>
<ol>
<li>6.在fs控制台客户端输入:da2 show<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/9.png" alt=""><br>出现上面问题说明成功,如果一直不成功检查对应数据库表  </li>
</ol>
<h4 id="6-ipcc中cdr关于服务"><a href="#6-ipcc中cdr关于服务" class="headerlink" title="6.ipcc中cdr关于服务"></a>6.ipcc中cdr关于服务</h4><ol>
<li>1.服务水平只对呼入而言的 呼出不用管  calltype=100 and dir=1  </li>
<li>2.starttime  connecttime和endtime 是整个电话的开始 接起和结束时间</li>
<li>3.workstarttime 是电话进入acd的时间  workconnect是坐席接起电话的时间 workendtime是坐席服务结束的时间 acmtime 在呼入的时候是坐席开始振铃时间（注意  在呼出的时候是用户振铃时间）</li>
<li>4.acmtime是服务水平的统计标志</li>
<li>5.用户呼叫系统的全部电话（呼入我们目前都要进入ivr ）：calltype&lt;300 and dir = 1 </li>
<li>6.坐席呼出用户的电话  calltype=100 || calltype=113||calltype=114  and dir=0</li>
<li>7.自动外呼呼出的电话   notifyid is not null</li>
<li>8.里面 connecttime  workconnecttime字段很重要 判断是否接通的依据</li>
<li>9.建议：现在数据除了cdr表外 通话数据 坐席数据 其实已经通过ice推送给ccms了、ccms能不能做一些文件存储 然后通过一些外部工具进行数据分析、毕竟cdr是生产上的 不能频繁访问、 ZeroC ICE提供一种打补丁方式，名为IcePatch2。基本功能就是通过ICE通讯将服务器上的最近软件部署到各个客户端中，这间接的实现了文件传输功能，</li>
</ol>
<h4 id="7-ipcc中任务呼叫失败原因"><a href="#7-ipcc中任务呼叫失败原因" class="headerlink" title="7.ipcc中任务呼叫失败原因"></a>7.ipcc中任务呼叫失败原因</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/81.png" alt="">  </p>
<h4 id="8-ipcc中任务脚本通知"><a href="#8-ipcc中任务脚本通知" class="headerlink" title="8.ipcc中任务脚本通知"></a>8.ipcc中任务脚本通知</h4><p>通过shell脚本的iniwrite和ice不能并存,如果用ice需要把iniwrite改成iniwrite1或者其他<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/82.png" alt=""> </p>
<h4 id="9-ipcc中配置"><a href="#9-ipcc中配置" class="headerlink" title="9.ipcc中配置"></a>9.ipcc中配置</h4><p>ipcc各种配置请参考对应的doc文档。  </p>
<h3 id="2-空号检测模块搭建及录音库文件更新"><a href="#2-空号检测模块搭建及录音库文件更新" class="headerlink" title="2.空号检测模块搭建及录音库文件更新"></a>2.空号检测模块搭建及录音库文件更新</h3><p>注意:金服空号检测服务器由于私有云不能访问到外网,所以将空号检测license所在服务部署到了金服金融云。(金融云是连通公有云和私有云的桥梁)  </p>
<p>空号检测服务daserver是根据局端返回的录音文件:然后通过asr识别来返回信令结果:dropcause  </p>
<h4 id="2-1服务搭建"><a href="#2-1服务搭建" class="headerlink" title="2.1服务搭建"></a>2.1服务搭建</h4><ol>
<li>1.解压da.tar.gz数据库  </li>
<li>2.安装mysql<br>centos6<br>-yum install mysql-server<br>-service mysqld start<br>-chkconfig mysqld on   </li>
</ol>
<p>centos7<br>-yum install mariadb-server<br>-systemctl start mariadb.service<br>-systemctl enable mariadb.service   </p>
<ol>
<li><p>3.创建数据库da<br>mysqladmin -uroot -p create da  </p>
</li>
<li><p>4.导入数据到da<br>mysql -uroot -p da &lt; da.sql<br>生成的数据库和表如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/99.png" alt=""></p>
</li>
<li>5.执行machinecode获取机器码,发给cdevelop@qq.com申请授权码,写入 license.txt .<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/95.png" alt="">    </li>
<li><p>6.根据安装文档word版本,配置数据库和JSON  </p>
</li>
<li><p>7.启动daserver<br>临时启动: ./daserver<br>后台启动: nohup ./daserver &amp;  </p>
</li>
</ol>
<p>注意:启动出现 ./daserver: relocation error: ./libssl.so.10: symbol private_ossl_minimum_dh_bits, version libcrypto.so.10 not defined in file libcrypto.so.10 with link time reference<br>一般是系统已经有了其他版本的ssl,删除 本目录的 libssl.so.10 文件  </p>
<h4 id="2-2更新录音文件库"><a href="#2-2更新录音文件库" class="headerlink" title="2.2更新录音文件库"></a>2.2更新录音文件库</h4><p>电话在拨打过程中出现了运营商返回的错误信令:dropcause为480<br>通过查询da模块(空号检测模块)录制的录音知道:”您拨打的号码是非本地号码,请在拨打号码前加0” 我们知道空号检测模块的录音库中没有识别到此空号录音，所以我们需要更新录音库(使用da提供的win下的工具samplemgr,连接da所在license的库数据库da)，有时候我们是无法直接连接license所在的da数据，而只能连接测试数据库，所以我们需要在测试环境下操作，然后把对应的数据替换到生产库。  </p>
<h5 id="2-2-1更新da语音库"><a href="#2-2-1更新da语音库" class="headerlink" title="2.2.1更新da语音库"></a>2.2.1更新da语音库</h5><ol>
<li>1.打开samplemgr,连接对应的数据库<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/96.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/97.png" alt="">      </li>
<li><p>2.启动服务,输入key(key是da数据库中)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/100.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/98.png" alt=""><br>启动成功日志:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/101.png" alt="">  </p>
</li>
<li><p>3.添加录音库测试<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/102.png" alt=""><br>文件要求 8000hz 16位 单声道，文件名要是数字，比如 电话号码.wav 这样子。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/103.png" alt=""><br>后续步骤按照samplemgr里面的文档:添加样本例子.docx  </p>
</li>
</ol>
<h5 id="2-2-2-测试环境da数据导入到生产环境"><a href="#2-2-2-测试环境da数据导入到生产环境" class="headerlink" title="2.2.2 测试环境da数据导入到生产环境"></a>2.2.2 测试环境da数据导入到生产环境</h5><p>注意:1.由于da表结构中字段类型是:blob所以我们不能使用SQLyog或者Navicat工具直接将表数据导出，经测试直接导出的数据通过source导入到生产环境时候会由于乱码导入报错。而只能直接在测试环境所在服务是使用mysqldump指令导出数据。  </p>
<h6 id="1-测试环境da数据导出"><a href="#1-测试环境da数据导出" class="headerlink" title="1.测试环境da数据导出"></a>1.测试环境da数据导出</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/104.png" alt=""></p>
<ol>
<li>1.进入测试环境da数据库数据(以导出mfcc数据为例)<br>mysqldump -u <username> -p <dbname> &gt; /path/to/<em>*</em>.sql<br>我们直接输入:mysqldump -u root -p123456 da mfcc&gt;mfcc.sql 报错如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/105.png" alt=""><br>说明我们导出表数据时候不能直接输入密码。我们更换成如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/106.png" alt="">  <h6 id="2-生产环境da数据导入"><a href="#2-生产环境da数据导入" class="headerlink" title="2.生产环境da数据导入"></a>2.生产环境da数据导入</h6></dbname></username></li>
<li>1.连接生产环境数据库(注：如果连接不上时候加上-h 127.0.01参数)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/107.png" alt=""> </li>
<li>2.数据导入<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/108.png" alt="">  </li>
</ol>
<h6 id="3-启动da的license所在服务"><a href="#3-启动da的license所在服务" class="headerlink" title="3.启动da的license所在服务"></a>3.启动da的license所在服务</h6><p>从数据导入之后使用./daserver启用之后,大概到了下午4点11分左右,局端又返回许多480结果,然后查看da的录音<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/110.png" alt=""><br>听录音是没有识别到,于是进入freeswitch里面的log下的da.log打开后发现下午4点11分左右就不开始识别了:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/111.png" alt=""><br>查看daserver进程发现进程挂了,所以使用下面后太启动方式。  </p>
<ol>
<li>1.进入daserver所在目录下执行后台启动指令:<br>nohup ./daserver &amp;<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/109.png" alt="">  </li>
</ol>
<h4 id="10-定时备份日志"><a href="#10-定时备份日志" class="headerlink" title="10.定时备份日志"></a>10.定时备份日志</h4><ol>
<li><p>1.编写clearlog.sh  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /cc/log/bak</div><div class="line">find /cc/bin/log -mtime +1 -type f -name &quot;log*.log&quot; -exec mv &#123;&#125; /cc/log/bak/. \;</div><div class="line">tar zcvf fslog$(date +&quot;%Y%m%d%H%M&quot;)tar.gz log*.log </div><div class="line">rm -f log*.log</div><div class="line">find /cc/log -mtime +1 -type f -name &quot;*.log&quot; -exec mv &#123;&#125; /cc/log/bak/. \;</div><div class="line">tar zcvf log$(date +&quot;%Y%m%d%H%M&quot;).log.tar.gz *.log </div><div class="line">rm -f *.log</div></pre></td></tr></table></figure>
</li>
<li><p>2.添加到系统定时任务中去<br>a.在root下执行 crontab -e<br>b.将0 0 <em> </em> *  /cc/bin/cleanlog.sh &gt; /dev/null 2&gt;&amp;1 放进去 保存退出。</p>
</li>
<li><p>3.运维查询每天日志的最小、最大拨打时间  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SELECT MIN(starttime),MAX(starttime),SUBSTRING(starttime,1,10) FROM cti_cdr WHERE entid = 1308 GROUP BY SUBSTRING(starttime,1,10) ORDER BY starttime ASC;</div><div class="line">```  </div><div class="line"></div><div class="line">#### 11.停止掉空号检测  </div><div class="line">1.进入:/cc/freeswitch/conf;不是删除da2.json  </div><div class="line">2.注释掉:load mod_da2  </div><div class="line">进入:/cc/freeswitch/conf/autoload_configs找到文件:modules.conf.xml</div><div class="line">然后注释掉:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/10/114.png)  </div><div class="line">3.fsg.cfg里面:注释掉:识别da2的注释掉</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/10/116.png)</div><div class="line"></div><div class="line">#### 12.fs中注释掉影响通话质量的元素  </div><div class="line">1.conf/vars.xml里面的以下几行注释掉:</div></pre></td></tr></table></figure>
</li>
</ol>
<!--RECORD_SILENCE_THRESHOLD vad调节阀值,声音能量，配置太小旁边人说话会被当成说话800 -->
  <!--X-PRE-PROCESS cmd="set" data="RECORD_SILENCE_THRESHOLD=800"/->

  <!-- EOS_SILENCE_THRESHOLD 没说话的静音阈值200-->
  <!--X-PRE-PROCESS cmd="set" data="EOS_SILENCE_THRESHOLD=200"/-->
  <!--RECORD_FINAL_TIMEOUT_MS 停顿超时，说话结束-->
  <!--X-PRE-PROCESS cmd="set" data="RECORD_FINAL_TIMEOUT_MS=600"/-->
 <!--X-PRE-PROCESS cmd="set" data="RECORD_STEREO=true"/-->
<p>```</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/14/ipcc-1-ipcc整体架构/" class="archive-article-date">
  	<time datetime="2019-05-14T11:36:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ipcc/">ipcc</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-work-7-搭建配置nginx负载均衡服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/13/work-7-搭建配置nginx负载均衡服务器/">work-7-搭建配置nginx负载均衡服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考地址1:<a href="https://blog.csdn.net/u010395496/article/details/79921903" target="_blank" rel="external">https://blog.csdn.net/u010395496/article/details/79921903</a><br>参考地址2：<a href="https://blog.csdn.net/lao4j/article/details/80190703" target="_blank" rel="external">https://blog.csdn.net/lao4j/article/details/80190703</a><br>参考地址3(keepalived+nginx实现主备):<a href="https://wenku.baidu.com/view/31b8970d856a561253d36f86.html?from=search" target="_blank" rel="external">https://wenku.baidu.com/view/31b8970d856a561253d36f86.html?from=search</a><br>nginx实现负载均衡、热备、动静分离:<a href="https://blog.csdn.net/forever_2/article/details/79194788" target="_blank" rel="external">https://blog.csdn.net/forever_2/article/details/79194788</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/13/work-7-搭建配置nginx负载均衡服务器/" class="archive-article-date">
  	<time datetime="2019-05-13T03:51:58.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/work/">work</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-4-应用通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/18/SpringCloud-4-应用通信/">SpringCloud-4-应用通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-HTTP-vs-RPC"><a href="#1-HTTP-vs-RPC" class="headerlink" title="1.HTTP vs RPC"></a>1.HTTP vs RPC</h4><ol>
<li>应用(微服务)间通讯方式主要有两种:HTTP和RPC</li>
<li>两种方式的主角:RPC–Dubbo  HTTP–SpringCloud  </li>
<li>Dubbo定位始终是一个RPC远程调用框架,而SpringCloud是微服务下的一站式解决方式</li>
<li>SpringCloud微服务下服务调用使用的是:HTTP Restful,HTTP Restful本身轻量、适应性强、可以很容易跨语言跨平台。</li>
<li>SpringCloud中服务间两种restful调用方式:1. RestTemplate 2.Feign  </li>
</ol>
<h4 id="2-RestTemplate的三种使用方式"><a href="#2-RestTemplate的三种使用方式" class="headerlink" title="2.RestTemplate的三种使用方式"></a>2.RestTemplate的三种使用方式</h4><ol>
<li>1.RestTemplate是一个HTTP客户端,类似于HttpClient,功能差不多,但是用法上更加简单。  <h4 id="2-1-RestTemplate例子"><a href="#2-1-RestTemplate例子" class="headerlink" title="2.1 RestTemplate例子"></a>2.1 RestTemplate例子</h4></li>
<li>1.使用 “订单服务-&gt;商品服务”为例</li>
<li>2.订单服务调用商品服务,我们把商品服务当做server端,订单服务当做client端</li>
<li>3.为了不影响之前的代码逻辑,我们新建单独的包为例子。  </li>
<li>4.product端新建ServerController</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author yxm</div><div class="line"> * @date 2019/4/20 0:16:16</div><div class="line"> */</div><div class="line">@RestController</div><div class="line">public class ServerController &#123;</div><div class="line">    </div><div class="line">    @GetMapping(&quot;/msg&quot;)</div><div class="line">   public String msg()&#123;</div><div class="line">       return &quot;this is product server mmsg&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>5.order服务中新建ClientController<br>RestTemplate第一种方式  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author yxm</div><div class="line"> * @date 2019/4/20 0:18:18</div><div class="line"> */</div><div class="line">@RestController</div><div class="line">@Slf4j</div><div class="line">public class ClientController &#123;</div><div class="line"></div><div class="line">    @GetMapping(&quot;/getProductMsg&quot;)</div><div class="line">    public String getProductMsg()&#123;</div><div class="line">        //1.RestTemplate第一种方式 </div><div class="line">        RestTemplate restTemplate = new RestTemplate();</div><div class="line">        String response = restTemplate.getForObject(&quot;http://localhost:8080/msg&quot;, String.class);</div><div class="line">        log.info(&quot;response&#123;&#125;&quot;,response);</div><div class="line">        return response;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于product服务已经启用了8080端口,我们用-D指令在order服务中用-Dserver.port=8081,不建议直接写到配置文件。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/84.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png" alt=""><br>以上是第一种调用方式。缺点:1.url为固定写死的,上线时候部署多台服务器,有时候连部署到哪台服务器都不知道。2.对方可能启动了多个实例,如果写死到一台实现不了负载均衡,其他服务器就不能访问了。</p>
<ol>
<li>6.RestTemplate第二种方式  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@Slf4j</div><div class="line">public class ClientController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private LoadBalancerClient loadBalancerClient;</div><div class="line"></div><div class="line">    @GetMapping(&quot;/getProductMsg&quot;)</div><div class="line">    public String getProductMsg()&#123;</div><div class="line"></div><div class="line">        //2.第二种方式:通过LoadBalancerClient获取服务名,ip和port</div><div class="line">        /**</div><div class="line">         * SpringCloud提供了LoadBalancerClient,将其注入到Spring中</div><div class="line">         */</div><div class="line">        RestTemplate restTemplate = new RestTemplate();</div><div class="line">        ServiceInstance product = loadBalancerClient.choose(&quot;PRODUCT&quot;);</div><div class="line">        String url = String.format(&quot;http://%s:%s&quot;, product.getHost(), product.getPort());</div><div class="line">        String response = restTemplate.getForObject(url, String.class);</div><div class="line">        log.info(&quot;response&#123;&#125;&quot;,response);</div><div class="line">        return response;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">第二种方式每次都需要那么写(创建对象,获取ip,获取port,在调用获取),还是比较麻烦   </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png) </div><div class="line"></div><div class="line">7. 7.第三种方式</div></pre></td></tr></table></figure>
<p>@Component<br>public class RestTemplateConfig {<br>    @Bean<br>    @LoadBalanced<br>    public RestTemplate restTemplate(){<br>        return new RestTemplate();<br>    }<br>}</p>
<p>@RestController<br>@Slf4j<br>public class ClientController {<br>   @Autowired<br>   private RestTemplate restTemplate;</p>
<pre><code>@GetMapping(&quot;/getProductMsg&quot;)
public String getProductMsg(){
    //3.第三种方式:通过RestTemplate的配置加LoadBalancerClient注解
    String response = restTemplate.getForObject(&quot;http://PRODUCT/msg&quot;, String.class);
    log.info(&quot;response{}&quot;,response);
    return response;
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png) </div><div class="line"></div><div class="line"></div><div class="line">#### 3.负载均衡器Ribbion  </div><div class="line">1. 1.前面我们在说Eureka时候,谈到了服务端发现和客户端发现。Eureka属于客户端发现的方式,他的负载均衡是软负载,也就是客户端会向服务器(例如:EurekaServer)拉取已经注册的可用服务信息，然后根据负载均衡策略直接命中哪台服务器、发送请求。这整个过程都是在客户端完成的，并不需要服务端参数。SpringCloud中客户端负载均衡就是Ribbion  。他是基于NetflexRibbion实现的。通过SpringCloud的封装可以轻松的实现面向服务的restful模板请求自动转化成客户端负载均衡服务调用。</div><div class="line"></div><div class="line">一下组件都使用到了Ribbon:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/9.png) </div><div class="line"></div><div class="line">2. 2.SpringCloud在结合了Ribbon的负载均衡实现中,封装增加了HttpClient和OkHttp两种请求端实现,默认使用了Ribbon对Eureka服务发现的负载均衡client。</div><div class="line"></div><div class="line">3. 3.在上一节小结中,我们介绍了RestTemplate的三种实现方式。其中通过添加@LoadBalanced注解或者 直接写代码时候使用LoadBalancerClient,其实用到的就是Ribbon的组件</div><div class="line">4. 4.添加@LoadBalanced注解后,Ribbon会通过LoadBalancerClient自动的帮助你基于某种规则,比如:随机简单的轮训去连接目标服务,从而很容易使用Ribbon实现自定义的负载均衡算法。  </div><div class="line">5. 5.Ribbon实现负载均衡核心有3点:1.服务发现(也就是发现依赖服务的列表,也就是依据服务的名字,把该服务下的实例全都找出来)   2.服务选择规则(依据规则策略:如何从多个服务中选择一个有效的服务)  3.服务监听(监测失效服务做到高效剔除)  </div><div class="line">6. 6.主要组件是：ServerList、IRule、ServerListFilter。总体流程是:首先通过ServerList获取所有的可用服务列表。然后通过ServerListFilter过滤掉一部分地址，最后剩下的地址中通过IRule选择一个实例作为最终目标结果。</div><div class="line"></div><div class="line"></div><div class="line">#### 4 追踪源码自定义负载均衡策略</div><div class="line">略</div><div class="line">#### 5 Feign的使用</div><div class="line">##### 5.1 Feign的基本使用</div><div class="line">1. 1.本节使用Feign实现应用间通信。  </div><div class="line">2. 2.现在我们使用了Feign就不用使用restTemplate了,我们现在在ClientController中将restTemplate相关删除,并将RestTemplateConfig删除</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/10.png)</div><div class="line">3. 3.添加依赖:</div></pre></td></tr></table></figure>
<p><dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-feign</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/11.png)  </div><div class="line"></div><div class="line"></div><div class="line">4. 4.启动类中添加注解  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/12.png)  </div><div class="line">5. 5.定义好feign要调用的Server端接口  </div><div class="line">建立client包,定义一个ProductClient接口(里面的方法就是调用product服务的方法),此client代表order服务是一个相对于product的客户端服务。  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/13.png) </div><div class="line">product中ServerController里面调用的方法:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/14.png) </div><div class="line">6. 6.此接口定义完之后,在Controller里面定义,然后接口请求:http://localhost:8081/getProductMsg  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/15.png)  </div><div class="line"></div><div class="line">##### 5.2 Feign的总结  </div><div class="line">1. 声明式REST客户端(伪RPC)  </div><div class="line">2. 采用了基于接口的注解(定义一个接口,然后在其上加注解)  </div><div class="line">3. 内部使用了Ribbon作为负载均衡  </div><div class="line"></div><div class="line">#### 6 Feign获取商品列表  </div><div class="line">在Oder服务的OrderServiceImpl中的create里面1、2、3是我们还没有做的,这节我们需要通过Feign获取商品列表  </div><div class="line"></div><div class="line">##### 6.1 Product服务中添加获取商品列表  </div><div class="line"></div><div class="line">###### 1.Product--&gt;dao  </div><div class="line">ProductInfoRepository:</div></pre></td></tr></table></figure></p>
<p>public interface ProductInfoRepository extends JpaRepository<productinfo,string>{<br>     List<productinfo> findByProductStatus(Integer productStatus);</productinfo></productinfo,string></p>
<pre><code>List&lt;ProductInfo&gt; findByProductIdIn(List&lt;String&gt; productIdList);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">###### 2.Product--&gt;service</div><div class="line">ProductService:</div></pre></td></tr></table></figure></p>
<p>public interface ProductService {<br>    /**</p>
<pre><code> * 查询所有在架商品列表
 */
List&lt;ProductInfo&gt; findUpAll();
/**
 * 查询商品列表
 */
List&lt;ProductInfo&gt; findList(List&lt;String&gt; productIdList);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ProductServiceImpl:  </div><div class="line"></div><div class="line"></div><div class="line">```  </div><div class="line">@Service</div><div class="line">public class ProductServiceImpl implements ProductService &#123;</div><div class="line">    @Autowired</div><div class="line">    private ProductInfoRepository repository;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;ProductInfo&gt; findUpAll() &#123;</div><div class="line">        return repository.findByProductStatus(ProductStatusEnum.UP.getCode());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;ProductInfo&gt; findList(List&lt;String&gt; productIdList) &#123;</div><div class="line">        return repository.findByProductIdIn(productIdList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="3-Product–-gt-controller"><a href="#3-Product–-gt-controller" class="headerlink" title="3.Product–&gt;controller"></a>3.Product–&gt;controller</h6><p>ProductController:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@RequestMapping(&quot;/product&quot;)</div><div class="line">public class ProductController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProductService productService;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProductCategoryService productCategoryService;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取商品列表(给订单服务使用)</div><div class="line">     * @param productIdList</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @GetMapping(&quot;/listForOrder&quot;)</div><div class="line">    public List&lt;ProductInfo&gt; listForOrder(@RequestBody List&lt;String&gt; productIdList)&#123;</div><div class="line">        return productService.findList(productIdList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="6-2-Order服务中调用商品列表"><a href="#6-2-Order服务中调用商品列表" class="headerlink" title="6.2 Order服务中调用商品列表"></a>6.2 Order服务中调用商品列表</h5><p>在client的ProductClient添加调用product的方法  </p>
<h6 id="1-Order–-gt-ProductClient"><a href="#1-Order–-gt-ProductClient" class="headerlink" title="1.Order–&gt;ProductClient"></a>1.Order–&gt;ProductClient</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@FeignClient(name = &quot;product&quot;)</div><div class="line">public interface ProductClient &#123;</div><div class="line">    @GetMapping(&quot;/listForOrder&quot;)</div><div class="line">    List&lt;ProductInfo&gt; listForOrder(@RequestBody List&lt;String&gt; productIdList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="2-Order–-gt-ClientController"><a href="#2-Order–-gt-ClientController" class="headerlink" title="2.Order–&gt;ClientController"></a>2.Order–&gt;ClientController</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@Slf4j</div><div class="line">public class ClientController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProductClient productClient;</div><div class="line"></div><div class="line"></div><div class="line">    @GetMapping(&quot;/getProductMsg&quot;)</div><div class="line">    public String getProductMsg()&#123;</div><div class="line">        String msg = productClient.productMsg();</div><div class="line">        log.info(&quot;getProductMsg()&quot;,msg);</div><div class="line">        return msg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @GetMapping(&quot;/getProductList&quot;)</div><div class="line">    public String getProductList()&#123;</div><div class="line">        List&lt;ProductInfo&gt; productInfos = productClient.listForOrder(Arrays.asList(&quot;157875196366160022&quot;));</div><div class="line">        return &quot;ok&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="3-Order–-gt-请求测试"><a href="#3-Order–-gt-请求测试" class="headerlink" title="3.Order–&gt;请求测试"></a>3.Order–&gt;请求测试</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/16.png" alt="">  </p>
<h4 id="7-扣库存-Feign"><a href="#7-扣库存-Feign" class="headerlink" title="7.扣库存(Feign)"></a>7.扣库存(Feign)</h4><p>我们已经获取了商品列表,现在开始在Product微服务实现扣库存<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/17.png" alt=""><br>从创建订单接口我们知道,前端会传过来商品的信息和购买数量:我们在DTO中构造一个对象:CartDTO用来传送上面的对象  </p>
<ol>
<li>1.Product–&gt;CartDTO对象<br>新建DTO包,新建CartDTO类:  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class CartDTO &#123;</div><div class="line"> /**</div><div class="line">     * 商品id</div><div class="line">     */</div><div class="line">  private String productId;</div><div class="line">    /**</div><div class="line">     * 商品数量</div><div class="line">     */</div><div class="line">  private Integer productQuantity;</div><div class="line"></div><div class="line">  public CartDTO()&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  public CartDTO(String productId,Integer productQuantity)&#123;</div><div class="line">      this.productId = productId;</div><div class="line">      this.productQuantity = productQuantity;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>2.Product–&gt;Exception自定义异常  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class ProductException extends RuntimeException &#123;</div><div class="line">    private Integer code;</div><div class="line"></div><div class="line">    public ProductException(Integer code,String message)&#123;</div><div class="line">      super(message);</div><div class="line">      this.code =code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ProductException(ResultEnum resultEnum)&#123;</div><div class="line">           super(resultEnum.getMessage());</div><div class="line">           this.code = resultEnum.getCode();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>3.Product–&gt;返回枚举  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public enum ResultEnum &#123;</div><div class="line">    PRODUCT_NOT_EXIST(1,&quot;商品不存在&quot;),</div><div class="line">    PRODUCT_STOCK_ERROE(2,&quot;商品库存错误&quot; );</div><div class="line">    private Integer code;</div><div class="line">    private String message;</div><div class="line"></div><div class="line">    ResultEnum(Integer code, String message) &#123;</div><div class="line">        this.code = code;</div><div class="line">        this.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getMessage() &#123;</div><div class="line">        return message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMessage(String message) &#123;</div><div class="line">        this.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Integer getCode() &#123;</div><div class="line">        return code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCode(Integer code) &#123;</div><div class="line">        this.code = code;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>4.Product–&gt;Service里面新建方法  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">@Transactional(rollbackFor = Exception.class)</div><div class="line">public void decreaseStock(List&lt;CartDTO&gt; cartDTOList) &#123;</div><div class="line">    /**</div><div class="line">     * 遍历:查看是否存在</div><div class="line">     */</div><div class="line">    for (CartDTO cartDTO:cartDTOList)&#123;</div><div class="line">        Optional&lt;ProductInfo&gt; productInfoOptional = repository.findById(cartDTO.getProductId());</div><div class="line">        //商品不存在</div><div class="line">        if(!productInfoOptional.isPresent())&#123;</div><div class="line">         throw new ProductException(ResultEnum.PRODUCT_NOT_EXIST);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //商品存在-库存错误</div><div class="line">        ProductInfo productInfo = productInfoOptional.get();</div><div class="line">        int result = productInfo.getProductStock() - cartDTO.getProductQuantity();</div><div class="line">        if(result&lt;0)&#123;</div><div class="line">            throw new ProductException(ResultEnum.PRODUCT_STOCK_ERROE);</div><div class="line">        &#125;</div><div class="line">        //保存</div><div class="line">        productInfo.setProductStock(result);</div><div class="line">        repository.save(productInfo);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>5.Product–&gt;controller</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@RequestMapping(&quot;/product&quot;)</div><div class="line">public class ProductController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private ProductService productService;</div><div class="line"></div><div class="line">    @PostMapping(&quot;/decreaseStock&quot;)</div><div class="line">    public void decreaseStock(@RequestBody List&lt;CartDTO&gt; cartDTOList)&#123;</div><div class="line">        productService.decreaseStock(cartDTOList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>6.在Order服务中client里面的ProductClient添加:减库存方法  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@FeignClient(name = &quot;product&quot;)</div><div class="line">public interface ProductClient &#123;</div><div class="line">    @GetMapping(&quot;/msg&quot;)</div><div class="line">    String productMsg();</div><div class="line"></div><div class="line">    @PostMapping(&quot;/product/decreaseStock&quot;)</div><div class="line">    void decreaseStock(@RequestBody List&lt;CartDTO&gt; cartDTOList);</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">7. 7.Order服务中:ClientController</div></pre></td></tr></table></figure>
<p>@RestController<br>@Slf4j<br>public class ClientController {</p>
<pre><code>@Autowired
private ProductClient productClient;


@GetMapping(&quot;/getProductMsg&quot;)
public String getProductMsg(){
    String msg = productClient.productMsg();
    log.info(&quot;getProductMsg()&quot;,msg);
    return msg;
}

@GetMapping(&quot;/getProductList&quot;)
public String getProductList(){
    List&lt;ProductInfo&gt; productInfos = productClient.listForOrder(Arrays.asList(&quot;157875196366160022&quot;));
    return productInfos.toString();
}

@GetMapping(&quot;/productDecreaseStock&quot;)
public String productDecreaseStock(){
   productClient.decreaseStock(Arrays.asList(new CartDTO(&quot;157875196366160022&quot;,1)));
   return &quot;ok&quot;;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">8. 8.测试  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/19.png)  </div><div class="line">库存减少了  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/20.png)  </div><div class="line"></div><div class="line"></div><div class="line">#### 8.整合接口打通下单流程(Feign)</div><div class="line">之前我们已经完善了,商品的查询,扣库存,那么我们这一节就要完成整套业务的打通。我们之前在Order服务中,创建订单时候,里面还有需要实现的如下几步:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/21.png)  </div><div class="line"></div><div class="line">1. 1.现在我们补充完毕：</div></pre></td></tr></table></figure></p>
<p>@Service<br>public class OrderServiceImpl implements OrderService {<br>    @Autowired<br>    private OrderMasterRepository orderMasterRepository;</p>
<pre><code>@Autowired
private OrderDetailRepository orderDetailRepository;
@Autowired
private ProductClient productClient;
@Override
public OrderDTO create(OrderDTO orderDTO) {
    String orderId = KeyUtil.genUniqueKey();
    //1.TODO 查询商品信息(调用商品服务)
    List&lt;String&gt; productIdList = orderDTO.getOrderDetailList().stream().map(OrderDetail::getProductId).collect(Collectors.toList());
    List&lt;ProductInfo&gt; productInfoList = productClient.listForOrder(productIdList);
    //2.TODO 计算订单总价
    //定义总价
    BigDecimal orderAmout = new BigDecimal(BigInteger.ZERO);
    for(OrderDetail orderDetail:orderDTO.getOrderDetailList()){
        //总价=(单价*数量)+总价
        Integer productQuantity = orderDetail.getProductQuantity();
        for(ProductInfo productInfo:productInfoList){
            if(productInfo.getProductId().equals(orderDetail.getProductId())){
                orderAmout = productInfo.getProductPrice().multiply(new BigDecimal(productQuantity)).add(orderAmout);

               //订单详情赋值
                BeanUtils.copyProperties(productInfo,orderDetail);
                orderDetail.setOrderId(orderId);
                orderDetail.setDetailId(KeyUtil.genUniqueKey());

                //订单详情入库
                orderDetailRepository.save(orderDetail);
            }
        }

    }
    //3.TODO 扣除库存(调用商品服务)
    List&lt;CartDTO&gt; cartDTOList = orderDTO.getOrderDetailList().stream()
            .map(e -&gt; new CartDTO(e.getProductId(), e.getProductQuantity()))
            .collect(Collectors.toList());
    productClient.decreaseStock(cartDTOList);

    //4. 订单入库
    OrderMaster orderMaster = new OrderMaster();
    //先设置主键 会copy到orderMaster
    orderDTO.setOrderId(orderId);
    BeanUtils.copyProperties(orderDTO,orderMaster);
    orderMaster.setOrderAmount(orderAmout);
    orderMaster.setOrderStatus(OrderStatusEnum.NEW.getCode());
    orderMaster.setPayStatus(PayStatusEnum.WAIT.getCode());
    orderMasterRepository.save(orderMaster);
    return orderDTO;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 2.测试  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/22.png)</div><div class="line"></div><div class="line">#### 9.项目改造成多模块</div><div class="line">多模块改造参考:https://blog.csdn.net/yangshangwei/article/details/88809468  </div><div class="line">##### 9.1 项目缺陷</div><div class="line">虽然我们之前已经完成了下单并扣除库存，虽然通信是完成了,但是有些地方做的不好。有如下问题:  </div><div class="line">1.在Product微服务中,获取商品列表(给订单服务使用)</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/23.png)</div><div class="line">返回的ProductInfo是数据库实体:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/24.png)</div><div class="line">基本上,我们不会把自己数据库映射的表对象暴露给外部的。  </div><div class="line">2.在订单服务和商品服务之间都有共有的对象:CartDTO,ProductInfo.重复定义。对象属于哪一个服务就在那一个服务中定义。</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/25.png)    </div><div class="line">3.在Order(订单)服务里,定义了ProductClient接口使用Feign主键调用，我们在项目中可能一个服务就是很多人来做,各个服务费透明的,所以我们在Oder服务中不能把Product的服务代码请求路径等写到Order服务中.</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/26.png) </div><div class="line"></div><div class="line">##### 9.2 Product多模块拆分</div><div class="line">###### 9.2.1模块之间职责  </div><div class="line">针对解决以上情况,我们把项目分成3个模块:product-server、prodect-client、product-common  </div><div class="line"></div><div class="line">1. 1.product-server:存放所有业务逻辑:包括,controller、service</div><div class="line">2. 2.prodect-client:对外暴露的接口,商品模块对外暴露的接口:商品列表和扣库存。  </div><div class="line">3. 3.product-common:公用的对象:既会被内部模块调用,也会被外部模块调用。</div><div class="line">###### 9.2.2模块之间依赖关系  </div><div class="line">1. 1.product-common是公用的对象,所以product-server会依赖product-common,返回的商品对象prodect-client也会依赖product-common</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/27.png) </div><div class="line"></div><div class="line">2. 2.product商品多模块划分可以参考:https://blog.csdn.net/qq_29479041/article/details/84230669  </div><div class="line">3. 3.在本地打包</div></pre></td></tr></table></figure></p>
<p>mvn -Dmaven.test.skip=true -U clean install<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用以上命令,会将对应模块打包并安装到本地maven仓库</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/28.png)  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">##### 9.3 Order多模块拆分</div><div class="line">1. 1.一次类推,Order服务也分为3个模块,但是order-client目前是没有代码:其目前不需要给外提供服务  order-common目前也没有代码:目前没有需求  </div><div class="line">2. 2.在订单服务需要注意的是:订单服务调用商品服务,那么需要在订单服务里面的启动类中添加扫描到商品服务的路径:@EnableFeignClients(basePackages = &quot;com.yxm.product.client&quot;)</div><div class="line">3. 3.最外层pom文件引入product-client的jar包  </div><div class="line">4. 4.&lt;dependencyManagement&gt;是管理jar包版本,不会下载对应依赖</div><div class="line"></div><div class="line"></div><div class="line">##### 9.5 测试  </div><div class="line">启动注册中心，通过product-server和order-server中的main函数启动俩微服务</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/29.png)  </div><div class="line"></div><div class="line">下单  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/30.png)   </div><div class="line"></div><div class="line">```  </div><div class="line">select * from order_master a where a.order_id = &apos;1558247336963513928&apos;</div><div class="line">select * from order_detail a  where a.order_id = &apos;1558247336963513928&apos;</div></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/31.png" alt="">   </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/32.png" alt="">  </p>
<p>源码:github地址:<a href="https://github.com/startshineye/SpringCloud_Shell/tree/develop_multimodulw">https://github.com/startshineye/SpringCloud_Shell/tree/develop_multimodulw</a>  </p>
<h4 id="10-同步或者异步"><a href="#10-同步或者异步" class="headerlink" title="10.同步或者异步"></a>10.同步或者异步</h4><ol>
<li>1.当前订单服务和商品服务,两个服务之间的通讯机制是同步的。订单会调用商品服务的扣库存接口。微服务中除了同步,有很多时候会集成到异步的场景下,通过队列和订阅主题,实现消息的 发布和订阅,一个微服务可以是消息的发布者,通过异步的方式发送到队列和订阅主题下,作为消费者的微服务,可以从队列或者主题中获取消息。通过消息中间件。把服务间的直接调用解耦。</li>
<li>比如以下图中:用户登录的时候,用户服务需要调用短信服务发短信。要给用户加积分,需要调用积分服务。还可能有其他服务，如果都采用同步的机制，服务间耦合过大,用户登录成功，需要向多个服务同步响应后才会成功，就会造成不好的用户体验。这个时候，我们通过消息队列可以实现很好的异步调用。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/33.png" alt="">  </li>
<li>3.再比如:订单服务在口库存前会调用查询商品服务,之后再调用减库存的接口来扣库存。我们对其改造:商品服务在更改库存的时候、发布库存变化的消息、订单服务来订阅这个消息、可以获取到商品的部分信息，比如:可购买的商品个数、商品id。订单服务在下单的时候不必同步的去查询数据确定商品的库存信息 而是查询自己服务中数据 然后在扣库存时候订单服务发布一个扣库存的消息、商品服务订阅这个消息。拿到消息后，减少本库存消息的库存量。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/34.png" alt=""> </li>
<li>4.消息中间件:目前常见的消息队列为:RabbitMQ、Kafka、ActiveMQ,我们现在使用RabbitMQ</li>
</ol>
<h4 id="11-RabbitMQ的安装"><a href="#11-RabbitMQ的安装" class="headerlink" title="11.RabbitMQ的安装"></a>11.RabbitMQ的安装</h4><p>进入下载网址:<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="external">https://www.rabbitmq.com/download.html</a><br>我们使用docker安装RabbitMQ<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/35.png" alt=""><br>我们使用带有管理界面的mq:3.8.0-beta.4-management<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/36.png" alt="">  </p>
<p><a href="https://blog.csdn.net/antma/article/details/81334932" target="_blank" rel="external">https://blog.csdn.net/antma/article/details/81334932</a><br><a href="https://www.jianshu.com/p/f3e49b495d74" target="_blank" rel="external">https://www.jianshu.com/p/f3e49b495d74</a>  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/18/SpringCloud-4-应用通信/" class="archive-article-date">
  	<time datetime="2019-04-17T16:57:11.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-18</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-3-服务拆分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SpringCloud-3-服务拆分/">SpringCloud-3-服务拆分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-微服务拆分的起点"><a href="#1-微服务拆分的起点" class="headerlink" title="1.微服务拆分的起点"></a>1.微服务拆分的起点</h4><h5 id="1-1如何拆分微服务"><a href="#1-1如何拆分微服务" class="headerlink" title="1.1如何拆分微服务?"></a>1.1如何拆分微服务?</h5><p>现在微服务概念炒得很热,关于如何拆分微服务,有以下几点。  </p>
<ol>
<li>1.先明白起点和终点<br>起点:既有架构的形态。<br>终点:好的架构不是设计出来的,而是进化而来的。  </li>
<li>典型架构<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/65.png" alt=""></li>
</ol>
<h5 id="1-2-适合上微服务么"><a href="#1-2-适合上微服务么" class="headerlink" title="1.2 适合上微服务么?"></a>1.2 适合上微服务么?</h5><p>业务形态不适合的<br>1.系统中包含很多很多强事务场景的(因为微服务是分布式的,分布式强事务CAP最多也就能达到最终一致性)<br>2.业务相对稳定、迭代周期长<br>3.访问压力不大、可用性要求不高(中小型企业的OA)  </p>
<h4 id="2-康威定律和微服务"><a href="#2-康威定律和微服务" class="headerlink" title="2.康威定律和微服务"></a>2.康威定律和微服务</h4><h5 id="2-1-康威定律"><a href="#2-1-康威定律" class="headerlink" title="2.1 康威定律"></a>2.1 康威定律</h5><p>除了业务形态不适合的,其实还有其他条件,很可能导致不适合迁移到微服务中去,首先我们看一下微服务理论基础:康威定律<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/66.png" alt=""></p>
<p>一句话概括就是:沟通的问题会影响系统设计<br>所以微服务都是强调小团队开发,大的系统拆分成微服务时候,大的团队随机也会拆分成小的团队。 </p>
<h5 id="2-2-微服务和团队结构"><a href="#2-2-微服务和团队结构" class="headerlink" title="2.2 微服务和团队结构"></a>2.2 微服务和团队结构</h5><ol>
<li>微服务特点<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/67.png" alt=""></li>
<li>传统vs微服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/68.png" alt=""></li>
</ol>
<h4 id="3-点餐业务服务拆分分析"><a href="#3-点餐业务服务拆分分析" class="headerlink" title="3.点餐业务服务拆分分析"></a>3.点餐业务服务拆分分析</h4><p>点餐系统分为:买家端 和 卖家端  </p>
<h5 id="3-1-服务拆分"><a href="#3-1-服务拆分" class="headerlink" title="3.1 服务拆分"></a>3.1 服务拆分</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/69.png" alt=""><br>上面:服务两种方式拆分:<br>第一种(按照终端):买家端(手机端)的ui单独为一个服务放到nginx里面,卖家端(PC端)的ui单独为一个服务,两个服务同时向后端的通用服务请求数据<br>第二种(按照业务):将订单ui,商品ui,支付ui都放到一个边缘服务。</p>
<p>以上两种都不对,如果只是自己运营的的点餐应用:团队只有一个,并且业务变化也不大,没有微服务化的必要。如果是一个快速发展的IT公司点餐部门,业务快速发展，需求不断提出，所以需要拆分成微服务。</p>
<p>所以说:起点和团队结构,沟通方式都会决定微服务的设计。  </p>
<h5 id="3-2-服务拆分方法论"><a href="#3-2-服务拆分方法论" class="headerlink" title="3.2 服务拆分方法论"></a>3.2 服务拆分方法论</h5><p>下图出自&lt;&lt;可扩展的艺术&gt;&gt;书籍<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/70.png" alt=""></p>
<ol>
<li>X轴 水平复制:通过应用程序扩展,通过负载均衡运行多个父本一样的应用程序</li>
<li>Z轴 数据分区:将服务按数据分区、每个服务器负责一个数据子集、每个服务器运行的代码是一样的  </li>
<li>Y轴 功能解耦:不同职责模块分成不同服务</li>
</ol>
<p>通过以上模型,知道服务拆分的两个关键职责:功能和数据 </p>
<h6 id="3-2-1-如何拆”功能”"><a href="#3-2-1-如何拆”功能”" class="headerlink" title="3.2.1 如何拆”功能”"></a>3.2.1 如何拆”功能”</h6><ol>
<li>1.单一职责(每个服务负责业务功能的单独一部分)、松耦合(服务之间耦合度低,修改一个服务不用导致另一个服务修改)、高内聚(服务内部相关行为都聚集在一个服务内,而不是分散在不同服务中心)。</li>
<li>2.关注点分离:-按职责  -按通用性 -按粒度级别(微服务并不是越小越好,要合适)  </li>
</ol>
<h6 id="3-2-2-如何拆”数据”"><a href="#3-2-2-如何拆”数据”" class="headerlink" title="3.2.2 如何拆”数据”"></a>3.2.2 如何拆”数据”</h6><p>拆分功能和拆分数据是有先后顺序  </p>
<ol>
<li>1.先考虑业务功能、再考虑业务功能对应的数据  </li>
<li>2.无状态服务（状态:如果一个数据要被多个服务共享才能完成一个请求,那么这个数据就称为状态,进而依赖这个状态数据的服务称为有状态服务）<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/71.png" alt=""><br>如上所示把业务数据存放到有状态服务的数据库,缓存中实现前端微服务和后端微服务质检无状态服务,数据间没有太大耦合性。  </li>
</ol>
<p>如何拆数据:<br>1.每个微服务都有单独数据存储(微服务共有数据库,有可能其中一个数据库出现问题会影响其他微服务,一个服务要获取另一个服务的数据,不能直接连接库去请求,而是调用另一个服务接口去获取数据,服务之间有隔离)<br>2.依据服务特点选择不同结构的数据库类型(如果:数据基于搜索的,那么es合适,如果是非机构化数据,那么nosql的mongodb合适)<br>3.难点在确定边界  </p>
<h6 id="3-2-3-点餐业务服务拆分分析"><a href="#3-2-3-点餐业务服务拆分分析" class="headerlink" title="3.2.3 点餐业务服务拆分分析"></a>3.2.3 点餐业务服务拆分分析</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/72.png" alt=""><br>1.不要期望服务拆分一次就正确,微服务是不断演进的  </p>
<h4 id="4-商品服务"><a href="#4-商品服务" class="headerlink" title="4.商品服务"></a>4.商品服务</h4><h5 id="4-1-商品服务api和sql介绍"><a href="#4-1-商品服务api和sql介绍" class="headerlink" title="4.1 商品服务api和sql介绍"></a>4.1 商品服务api和sql介绍</h5><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /product/list</div></pre></td></tr></table></figure>
<p>参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">无</div></pre></td></tr></table></figure>
<p>返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;code&quot;: 0,</div><div class="line">    &quot;msg&quot;: &quot;成功&quot;,</div><div class="line">    &quot;data&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;热榜&quot;,</div><div class="line">            &quot;type&quot;: 1,</div><div class="line">            &quot;foods&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;id&quot;: &quot;123456&quot;,</div><div class="line">                    &quot;name&quot;: &quot;皮蛋粥&quot;,</div><div class="line">                    &quot;price&quot;: 1.2,</div><div class="line">                    &quot;description&quot;: &quot;好吃的皮蛋粥&quot;,</div><div class="line">                    &quot;icon&quot;: &quot;http://xxx.com&quot;,</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;好吃的&quot;,</div><div class="line">            &quot;type&quot;: 2,</div><div class="line">            &quot;foods&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;id&quot;: &quot;123457&quot;,</div><div class="line">                    &quot;name&quot;: &quot;慕斯蛋糕&quot;,</div><div class="line">                    &quot;price&quot;: 10.9,</div><div class="line">                    &quot;description&quot;: &quot;美味爽口&quot;,</div><div class="line">                    &quot;icon&quot;: &quot;http://xxx.com&quot;,</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">sql</div></pre></td></tr></table></figure>
<p>– 类目<br>CREATE TABLE <code>product_category</code> (<br>    <code>category_id</code> INT NOT NULL AUTO_INCREMENT,<br>    <code>category_name</code> VARCHAR(64) NOT NULL COMMENT ‘类目名字’,<br>    <code>category_type</code> INT NOT NULL COMMENT ‘类目编号’,<br>    <code>create_time</code> TIMESTAMP NOT NULL COMMENT ‘创建时间’,<br>    <code>update_time</code> TIMESTAMP NOT NULL COMMENT ‘修改时间’,<br>    PRIMARY KEY (<code>category_id</code>),<br>    UNIQUE KEY <code>uqe_category_type</code> (<code>category_type</code>)<br>);<br>– 商品<br>CREATE TABLE <code>product_info</code> (<br>    <code>product_id</code> VARCHAR(32) NOT NULL,<br>    <code>product_name</code> VARCHAR(64) NOT NULL COMMENT ‘商品名称’,<br>    <code>product_price</code> DECIMAL(8,2) NOT NULL COMMENT ‘单价’,<br>    <code>product_stock</code> INT NOT NULL COMMENT ‘库存’,<br>    <code>product_description</code> VARCHAR(64) COMMENT ‘描述’,<br>    <code>product_icon</code> VARCHAR(512) COMMENT ‘小图’,<br>    <code>product_status</code> TINYINT(3) DEFAULT ‘0’ COMMENT ‘商品状态,0正常1下架’,<br>    <code>category_type</code> INT NOT NULL COMMENT ‘类目编号’,<br>    <code>create_time</code> TIMESTAMP NOT NULL COMMENT ‘创建时间’,<br>    <code>update_time</code> TIMESTAMP NOT NULL COMMENT ‘修改时间’,<br>    PRIMARY KEY (<code>product_id</code>)<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 4.2 商品服务编码  </div><div class="line">###### 4.2.1 创建工程</div><div class="line">1. 创建一个Eureka客户端服务,并修改pom.xml文件 保持版本一致性。    </div><div class="line">2. 修改项目名称并注册到Eureka注册中心  </div><div class="line">3. 添加注解:@EnableDiscoveryClient</div><div class="line"></div><div class="line">###### 4.2.2 启动项目,查看Eureka Server是否有注册的服务  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/73.png)  </div><div class="line"> </div><div class="line">###### 4.2.3 书写业务</div><div class="line">1. 1.添加mysql驱动和jpa依赖</div><div class="line">2. application.yml中配置数据源  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/74.png)</div><div class="line"></div><div class="line"></div><div class="line">#### 5.订单服务 </div><div class="line">##### 5.1 业务逻辑分析    </div><div class="line">### 创建订单</div></pre></td></tr></table></figure></p>
<p>POST /order/create<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">参数</div></pre></td></tr></table></figure></p>
<p>name: “张三”<br>phone: “18868822111”<br>address: “总部”<br>openid: “ew3euwhd7sjw9diwkq” //用户的微信openid<br>items: [{<br>    productId: “1423113435324”,<br>    productQuantity: 2 //购买数量<br>}]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">返回</div></pre></td></tr></table></figure>
<p>{<br>  “code”: 0,<br>  “msg”: “成功”,<br>  “data”: {<br>      “orderId”: “147283992738221”<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">订单服务业务逻辑思路:  </div><div class="line">1.参数校验  </div><div class="line">2.查询商品信息(此时信息有可能不在订单系统中,可能在商品微服务中,则调用商品服务查询)  </div><div class="line">3.计算总价  </div><div class="line">4.扣库存(调用商品服务)   </div><div class="line">5.订单入库   </div><div class="line"></div><div class="line">##### 5.2 编码实践    </div><div class="line">###### 5.2.1 创建应用 注册到注册中心</div><div class="line">略(按照:client客户端创建)  </div><div class="line"></div><div class="line">###### 5.2.2 dao</div><div class="line">订单服务业务逻辑思路:  </div><div class="line">1.参数校验  </div><div class="line">2.查询商品信息(此时信息有可能不在订单系统中,可能在商品微服务中,则调用商品服务查询)  </div><div class="line">3.计算总价  </div><div class="line">4.扣库存(调用商品服务)   </div><div class="line">5.订单入库  </div><div class="line"></div><div class="line">###### 5.2.3 service  </div><div class="line">1. 由于传递的参数包含:买家信息和订单信息,所以创建订单的service需要做一个数据转换 然后insert到对应买家和订单表里面,创建dto(Data Transfer Object)包,创建OrderDTO(买家和订单详情是一对多的关系,所以里面OrderDTO里是一个买家信息加许多商品信息)    </div><div class="line">2. OrderService里面创建订单的参数和返回为:OrderDTO  </div><div class="line">3. OrderServiceImpl里面实现创建订单:分为以下四步:1.查询商品 2.计算总价 3.扣除库存 4.订单入库。由于前3步都需要调用其他商品服务,所以我们写为:TODO  </div><div class="line">4. 创建OrderMaster时候,我们需要设置买家状态:orderStatus,payStatus我们用枚举实现如下:</div></pre></td></tr></table></figure>
<p>public enum OrderStatusEnum {<br>    NEW(0, “新订单”),<br>    FINISHED(1, “完结”),<br>    CANCEL(2, “取消”),<br>    ;<br>    private Integer code;<br>    private String message;<br>    OrderStatusEnum(Integer code, String message) {<br>        this.code = code;<br>        this.message = message;<br>    }<br>    public Integer getCode() {<br>        return code;<br>    }<br>    public String getMessage() {<br>        return message;<br>    }<br>}  </p>
<p>public enum PayStatusEnum {<br>    WAIT(0, “等待支付”),<br>    SUCCESS(1, “支付成功”),<br>    ;<br>    private Integer code;</p>
<pre><code>private String message;

PayStatusEnum(Integer code, String message) {
    this.code = code;
    this.message = message;
}

public Integer getCode() {
    return code;
}

public String getMessage() {
    return message;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. OrderId是主键,我们用简单的KeyUtil生成工具生成</div></pre></td></tr></table></figure></p>
<p>public class KeyUtil {<br>    /**</p>
<pre><code> * 生成唯一的主键
 * 格式: 时间+随机数
 */
public static synchronized  String  genUniqueKey(){
    Random random = new Random();
    Integer number = random.nextInt(900000)+100000;
    return System.currentTimeMillis()+String.valueOf(number);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. service逻辑如下:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/82.png)</div><div class="line"></div><div class="line"></div><div class="line">###### 5.2.4 controller</div><div class="line">1. controller里面需要实现的业务逻辑大部分都是在service中,此处只是多了个参数校验，所以分为以下几步:1.参数校验 2.查询商品信息(调用商品服务) 3.计算总价 4.扣库存(调用商品服务) 5.订单入库  </div><div class="line">2.  涉及很多参数时候,我们封装前端参数,此处叫:OrderForm,并在里面添加了参数校验,不用在controller方法里面(使用@NotEmpty)校验。OrderForm此处省略getter,setter也可以用lombok加上@Data注解。</div></pre></td></tr></table></figure></p>
<p>public class OrderForm {<br>    /**</p>
<pre><code> * 买家姓名
 */
@NotEmpty(message = &quot;姓名必填&quot;)
private String name;

/**
 * 买家手机号
 */
@NotEmpty(message = &quot;手机号必填&quot;)
private String phone;

/**
 * 买家地址
 */
@NotEmpty(message = &quot;地址必填&quot;)
private String address;

/**
 * 买家微信openid
 */
@NotEmpty(message = &quot;openid必填&quot;)
private String openid;

/**
 * 购物车
 */
@NotEmpty(message = &quot;购物车不能为空&quot;)
private String items;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 在create方法中添加@Valid注解  </div><div class="line"></div><div class="line"></div><div class="line">4. 如果参数校验有错误时候抛出异常(自定义异常)OrderException(Integer code, String message)，其中code,message不使用硬编码,定义一个枚举:ResultEnum</div></pre></td></tr></table></figure>
<p>public class OrderException extends RuntimeException {<br>    private Integer code;<br>    public OrderException(Integer code, String message){<br>      super(message);<br>      this.code = code;<br>    }<br>    public OrderException(ResultEnum resultEnum) {<br>        super(resultEnum.getMessage());<br>        this.code = resultEnum.getCode();<br>    }<br>}</p>
<p>@Getter<br>public enum ResultEnum {<br>    PARAM_ERROR(1, “参数错误”),<br>    CART_EMPTY(2, “购物车为空”)<br>    ;</p>
<pre><code>private Integer code;

private String message;

ResultEnum(Integer code, String message) {
    this.code = code;
    this.message = message;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">5. 在controller里面将校验过的参数：OrderForm转换成OrderDTO,此处转换封装成工具类处理(其中json转换成数据使用Gson)，转换失败时候抛出异常,打印日志      </div><div class="line"></div><div class="line">```  </div><div class="line">@Slf4j</div><div class="line">public class OrderForm2OrderDTOConverter &#123;</div><div class="line">    public static OrderDTO convert(OrderForm orderForm) &#123;</div><div class="line">        Gson gson = new Gson();</div><div class="line">        OrderDTO orderDTO = new OrderDTO();</div><div class="line">        orderDTO.setBuyerName(orderForm.getName());</div><div class="line">        orderDTO.setBuyerPhone(orderForm.getPhone());</div><div class="line">        orderDTO.setBuyerAddress(orderForm.getAddress());</div><div class="line">        orderDTO.setBuyerOpenid(orderForm.getOpenid());</div><div class="line"></div><div class="line">        List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();</div><div class="line">        try &#123;</div><div class="line">            orderDetailList = gson.fromJson(orderForm.getItems(),</div><div class="line">                    new TypeToken&lt;List&lt;OrderDetail&gt;&gt;() &#123;</div><div class="line">                    &#125;.getType());</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;【json转换】错误, string=&#123;&#125;&quot;, orderForm.getItems());</div><div class="line">            throw new OrderException(ResultEnum.PARAM_ERROR);</div><div class="line">        &#125;</div><div class="line">        orderDTO.setOrderDetailList(orderDetailList);</div><div class="line">        return orderDTO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>接口返回的结果data里面只有一个字段,所以不需要创建一个对象,一个封装一个map返回就行    </li>
</ol>
<pre><code>@RestController
@RequestMapping(&quot;/order&quot;)
@Slf4j
public class OrderController {

    @Autowired
    private OrderService orderService;

    /**
     * 1.参数校验
     * 2.查询商品信息(调用商品服务)
     * 3.计算总价
     * 4.扣库存(调用商品服务)
     * 5.订单入库
     */
    @PostMapping(&quot;/create&quot;)
    private Object create(@Valid OrderForm orderForm,
                          BindingResult bindingResult){
        //检验不通过抛出自定义异常
        if (bindingResult.hasErrors()){
            //https://www.cnblogs.com/weiapro/p/7633645.html
           log.error(&quot;【创建订单】参数不正确, orderForm={}&quot;, orderForm);
            throw new OrderException(ResultEnum.PARAM_ERROR.getCode(),
                    bindingResult.getFieldError().getDefaultMessage());
        }
        //orderForm-&gt;orderDTO
        OrderDTO orderDTO = OrderForm2OrderDTOConverter.convert(orderForm);
        if(CollectionUtils.isEmpty(orderDTO.getOrderDetailList())){
            log.error(&quot;【创建订单】购物车信息为空&quot;);
            throw new OrderException(ResultEnum.CART_EMPTY);
        }
        OrderDTO result = orderService.create(orderDTO);
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;orderId&quot;, result.getOrderId());
        return ResultVOUtil.success(map);
    }
}
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/83.png" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/13/SpringCloud-3-服务拆分/" class="archive-article-date">
  	<time datetime="2019-04-13T11:49:59.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-2-服务注册与发现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SpringCloud-2-服务注册与发现/">SpringCloud-2-服务注册与发现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-SpringCloud-Eureka"><a href="#1-SpringCloud-Eureka" class="headerlink" title="1.SpringCloud Eureka"></a>1.SpringCloud Eureka</h4><h5 id="1-1-简单微服务架构"><a href="#1-1-简单微服务架构" class="headerlink" title="1.1 简单微服务架构"></a>1.1 简单微服务架构</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/23.png" alt=""> </p>
<p>上图中的服务注册和发现在SpringCloud中用的就是:Eureka  </p>
<h5 id="1-2-简单介绍"><a href="#1-2-简单介绍" class="headerlink" title="1.2 简单介绍"></a>1.2 简单介绍</h5><ol>
<li>基于Netflix Eureka做了二次封装  </li>
<li>主要由两个组件组成: -Eureka Server(注册中心)  -Eureka Client(服务中心)  </li>
</ol>
<h4 id="2-Eureka-Server"><a href="#2-Eureka-Server" class="headerlink" title="2.Eureka Server"></a>2.Eureka Server</h4><h5 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h5><ol>
<li>注册中心好比老师手中名单 记录着所有同学名字  点名时候,根据手册名单</li>
<li>注册中心记录着所有应用的信息和状态(应用名,所在服务器,是否正常工作),在微服务架构中,我们把应用叫做服务 </li>
<li>由图所知:服务中心就是找到服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/24.png" alt="">  <h5 id="2-2-创建Eureka-Server应用"><a href="#2-2-创建Eureka-Server应用" class="headerlink" title="2.2 创建Eureka Server应用"></a>2.2 创建Eureka Server应用</h5><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/25.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/26.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/27.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/28.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/29.png" alt="">   </li>
</ol>
<p>项目创建后我们不着急启动,先看下pom.xml文件:<br>SpringBoot的版本和SpringCloud版本如下所示:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/30.png" alt=""><br>我们如何知道SpringBoot版本和SpringCloud的版本匹配呢?我们进入SpringCloud官网:<a href="https://spring.io/" target="_blank" rel="external">https://spring.io/</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/31.png" alt=""><br>将pom.xml中设置成统一匹配的:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/32.png" alt=""> </p>
<h5 id="2-3-启动Eureka-Server"><a href="#2-3-启动Eureka-Server" class="headerlink" title="2.3 启动Eureka Server"></a>2.3 启动Eureka Server</h5><p>1.启动时候报错:没有出现注册中心界面<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/33.png" alt=""><br>2.添加@EnableEurekaServer注解</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">     </div><div class="line">     @SpringBootApplication</div><div class="line">	 @EnableEurekaServer</div><div class="line">	 public class EurekaApplication &#123;</div><div class="line">		public static void main(String[] args) &#123;</div><div class="line">			SpringApplication.run(EurekaApplication.class, args);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	 &#125;</div><div class="line">    </div><div class="line">     ``</div><div class="line"></div><div class="line"></div><div class="line">重启发现出现注册中心的界面  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/34.png)  </div><div class="line"></div><div class="line"></div><div class="line">3.启动时候虽然可以访问,但是出现了下面的错误:</div></pre></td></tr></table></figure>

com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">这是因为此应用不仅是一个server端同时也是一个client端。他也需要找到一个注册中心,把自己注册上去。我们配置一下他注册的地址:就是往自己身上注册。  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/35.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/36.png)  </div><div class="line"></div><div class="line">点击service-url进入:EurekaClientConfigBean</div></pre></td></tr></table></figure>

public void setServiceUrl(Map&lt;String, String&gt; serviceUrl) {
    this.serviceUrl = serviceUrl;
}

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">serviceUrl是一个map的key为:defaultZone</div></pre></td></tr></table></figure>

eureka:
 client:
   service-url:
     defaultZone: http://localhost:8080/eureka/

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">重启项目时候:注册时候是心跳检测注册,刚开始会有错误,等一会就可以了,如下已经注册上:  </div><div class="line">  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/37.png)  </div><div class="line"></div><div class="line">由于注册的Application的名字为:UNKNOWN  我们修改此应用的名字,添加如下配置:</div></pre></td></tr></table></figure>

spring:
  application:
    name: eureka

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/38.png)   </div><div class="line"></div><div class="line">4.由于此应用本来就是一个注册中心,自己注册到自己不出现在注册实例中:添加如下配置:register-with-eureka: false</div></pre></td></tr></table></figure>

eureka:
 client:
  service-url:
    defaultZone: http://localhost:8080/eureka/
  register-with-eureka: false  

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/39.png)   </div><div class="line"></div><div class="line">5.由于我们后面很多应用都是8080端口,所以我们修改注册中心的地址为默认端口:8761</div></pre></td></tr></table></figure>

eureka:
 client:
   service-url:
     defaultZone: http://localhost:8761/eureka/
   register-with-eureka: false
spring:
  application:
    name: eureka
server:
    port: 8761  

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">#### 3.Eureka Client(服务注册)  </div><div class="line">##### 3.1 启用注册中心  </div><div class="line">注册中心为了方便不需要每次在idea中启动,我们应该打成jar包,然后通过命令在后台启用。进入eureka的根目录,执行:  </div><div class="line"></div><div class="line">    mvn clean package  </div><div class="line"></div><div class="line">生成后端启动：</div><div class="line">  </div><div class="line">    nohup java -jar eureka-0.0.1-SNAPSHOT.jar &amp;  </div><div class="line"></div><div class="line">##### 3.2 创建Eureka Client应用  </div><div class="line">1. 创建应用</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/25.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/40.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/41.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/42.png)  </div><div class="line"></div><div class="line">删除不需要的文件:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/43.png)  </div><div class="line"></div><div class="line">client端和server端的版本保持一致:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/44.png) </div><div class="line"></div><div class="line">2. 添加注册中心地址:</div><div class="line"></div><div class="line">    eureka:</div><div class="line">      client:</div><div class="line">        service-url:</div><div class="line">          defaultZone: http://localhost:8761/eureka/</div><div class="line">    spring:</div><div class="line">      application:</div><div class="line">        name: client</div><div class="line">     </div><div class="line">3. 开启服务注册  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/45.png) </div><div class="line"></div><div class="line"></div><div class="line">有时候启动报错:</div><div class="line"></div><div class="line">    Invocation of destroy method failed on bean with name &apos;scopedTarget.eurekaClient&apos;: org.springframework.beans.factory.BeanCreationNotAllowedException: Error creating bean with name &apos;eurekaInstanceConfigBean&apos;: Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)</div><div class="line"></div><div class="line">解决:添加web依赖</div><div class="line"></div><div class="line">       &lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line"></div><div class="line">4. 查看是否已经注册  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/46.png) </div><div class="line"></div><div class="line"></div><div class="line">5. 如果不停的启动client端,会在注册中心出现:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/47.png) </div><div class="line">client&lt;---&gt;server端是采用心跳的机制,server端会不听的检查client端是否存活上线,在一定时间会统计出client端的上线率,当低于某个比例时候 会报出以上警告,在开发环境我们可以把它关掉(在server端里面配置文件加上:)</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/48.png)  </div><div class="line"></div><div class="line">#### 4.Eureka高可用  </div><div class="line">##### 4.1 Eureka单节点 </div><div class="line">1. 上面的Eureka是单点的,如果挂了的话 所以client端服务都不可以运行了  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/49.png) </div><div class="line">##### 4.2 Eureka多节点之间互相注册,但是client注册到其中一个Eureka    </div><div class="line">1. 让Eureka Server开启两个,之间互相注册,虽然client只在server1上注册,但是会把client注册也会拷贝到server2注册  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/50.png)  </div><div class="line">2. 开启两个Eureka Server端口分别为:8761、8762   </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/51.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/52.png)  </div><div class="line">以端口来区分:Eureka1:8761   Eureka2:8762</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/53.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/54.png)  </div><div class="line">注释掉yml中原来端口:</div></pre></td></tr></table></figure>

    #server:
    #port: 8761
```
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/55.png" alt=""><br>启动  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/56.png" alt=""><br>启动</p>
<p>访问:<a href="http://localhost:8762" target="_blank" rel="external">http://localhost:8762</a>  我们可以看到之前注册到8761的服务也注册到8762上了,这是因为:8761和8762之间互相注册了。互相注册后,他们之上的信息有所交换。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/57.png" alt=""> </p>
<h5 id="4-3-Eureka1挂了-重启Eureka2和client"><a href="#4-3-Eureka1挂了-重启Eureka2和client" class="headerlink" title="4.3 Eureka1挂了 重启Eureka2和client"></a>4.3 Eureka1挂了 重启Eureka2和client</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/58.png" alt=""> </p>
<p>此时我们重启client和Eureka2时候,我们发现在Eureka2上没有发现client,这个时候我们就需要把client注册到Eureka1和Eureka2上才行。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/59.png" alt="">   </p>
<h5 id="4-4-Eureka包含3个以上"><a href="#4-4-Eureka包含3个以上" class="headerlink" title="4.4 Eureka包含3个以上"></a>4.4 Eureka包含3个以上</h5><p>有时候我们服务比较多,并且需要的注册中心也比较多,也就是Eureka Server比较多,我们该怎么做呢?<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/60.png" alt="">  </p>
<h4 id="5-Eureka总结"><a href="#5-Eureka总结" class="headerlink" title="5.Eureka总结"></a>5.Eureka总结</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/61.png" alt=""> </p>
<h4 id="6-分布式下服务注册的地位和原理"><a href="#6-分布式下服务注册的地位和原理" class="headerlink" title="6.分布式下服务注册的地位和原理"></a>6.分布式下服务注册的地位和原理</h4><h5 id="6-1-传统服务发现"><a href="#6-1-传统服务发现" class="headerlink" title="6.1 传统服务发现"></a>6.1 传统服务发现</h5><p>传统服务A要找到服务B,是通过在服务A中配置B的地址从而找到B,在分布式系统中,各个系统之间是不共享内存的，如下A服务如果要找到B服务就需要,并且B服务是分布式集群的,B中的服务器是不确定多少台,在云服务时代,服务器根据压力容量可能会动态改变,此时如果还是在A里面配置多个B节点注册中心地址不可取。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/62.png" alt=""></p>
<h5 id="6-2-注册中心服务发现"><a href="#6-2-注册中心服务发现" class="headerlink" title="6.2 注册中心服务发现"></a>6.2 注册中心服务发现</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/63.png" alt="">  </p>
<ol>
<li>类似于注册中心就是个代理,需要找谁就找谁</li>
<li><p>通过以上可以知道注册中心 是分布式服务中最重要的基础部分。  </p>
</li>
<li><p>A是如何通过”注册中心”找导服务B的呢?<br>客户端发起:A通过注册中心可以找到需要B,从中只需要找到一个B(通过轮训、hash等负载均衡机制等方式)<br>服务端发现:通过代理的方式<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/64.png" alt="">  </p>
</li>
</ol>
<h5 id="6-3-思考"><a href="#6-3-思考" class="headerlink" title="6.3 思考"></a>6.3 思考</h5><ol>
<li>SpringCloud是提供java应用程序之间的服务注册,那么如果有些服务是c/php/node.js写的服务,该怎样取进行服务发现和注册了，SpringCloud的Eureka使用客户端发现方式进行服务发现,SpringCloud是一个强大的我服务体系,但是是纯java的，山本大叔倡导轻量级的方式去实现微服务,所以采用了Http Restful API的方式,并且提供了Restful API接口让其他不同语言的服务区实现接口,达到服务注册。   </li>
<li>微服务具有异构特点:各个服务间可以用不同语言,每个服务可以根据需要选择不通的数据库  </li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/13/SpringCloud-2-服务注册与发现/" class="archive-article-date">
  	<time datetime="2019-04-13T02:46:38.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringClond-1-微服务介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SpringClond-1-微服务介绍/">SpringClond-1-微服务介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/13/SpringClond-1-微服务介绍/" class="archive-article-date">
  	<time datetime="2019-04-13T02:45:42.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-13</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-mysql优化-1-准备" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/23/mysql优化-1-准备/">mysql优化-1-准备</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们以电商项目为例来说明数据库优化方案  </p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h5><p>1.mysql实例<br>推荐使用MySQL5.7版本  </p>
<p>2.MySQL图形客户端程序<br>推荐使用SQLyog  </p>
<p>3.操作基础<br>linux命令和Shell脚本的基础知识 </p>
<h5 id="2-电商项目简介"><a href="#2-电商项目简介" class="headerlink" title="2.电商项目简介"></a>2.电商项目简介</h5><p>电商项目流程如下:用户登录后选购商品,然后把商品加入购物车,加入购物车时候查看商品库存,有商品的话提交订单,支付方式是货到付款则发货,不是的话,订单付款再发货。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/52.png" alt="">  </p>
<h5 id="3-电商项目模块简介"><a href="#3-电商项目模块简介" class="headerlink" title="3.电商项目模块简介"></a>3.电商项目模块简介</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/53.png" alt="">  </p>
<h5 id="4-数据库设计规范"><a href="#4-数据库设计规范" class="headerlink" title="4.数据库设计规范"></a>4.数据库设计规范</h5><h6 id="4-1-现实中数据库设计"><a href="#4-1-现实中数据库设计" class="headerlink" title="4.1 现实中数据库设计"></a>4.1 现实中数据库设计</h6><p>1.在通常情况下数据库设计是按照:先进行逻辑设计再进行物理设计。<br>2.现实工作中:逻辑设计和物理设计结合起来进行设计。<br>3.物理设计时候基本就是对:表名 字段名 字段类型进行设计。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/54.png" alt="">    </p>
<h6 id="4-2-数据库设计规范"><a href="#4-2-数据库设计规范" class="headerlink" title="4.2 数据库设计规范"></a>4.2 数据库设计规范</h6><p>如果公司中已经有了数据库设计规范,我们最好是按照此数据库设计规范进行设计。我们一般按照以下六个规范来进行数据库设计。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/55.png" alt="">   </p>
<h6 id="1-数据库命名规范"><a href="#1-数据库命名规范" class="headerlink" title="1.数据库命名规范"></a>1.数据库命名规范</h6><p>1.所有数据库对象名称必须使用小写字母并用下划线分隔。(由于:mysql在默认情况下是对大小写敏感的,在linux系统下,数据库和表就是linux系统下的一个文件,linux系统本身是对英文字母的大小敏感的,则以下数据库:DbName和dbname是两个不同的数据库名。数据库表:TABLE,Table和table是不同的表)<br>2.所有数据库对象名称禁止使用MySQL保留关键字(由于我们数据库关键字在sql执行时候有特定的含义,如果我们使用关键字将会是sql执行有误,比如使用from字段,则查询时候:select from from table),通过以下网址可以查看到mysql的关键字:<a href="http://dev.mysql.com/doc/refman/5.7/en/keywords.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.7/en/keywords.html</a><br>3.数据库对象的命名要见名识义,并且最好不要超过32个字符。<br>4.临时表必须以temp为前缀并以日期为后缀。<br>5.备份库,备份表必须以bak为前缀并以日期为后缀。<br>6.所有存储相同数据的列名和列类型必须一致。(由于:这虽然是一条命名规范,但是对数据库的查询性能是非常重要的,因为这些列通常都作为关联了来使用,如果两个关联列的数据类型不同时,并且有时根据此列进行数据库关联时候,他会进行数据类型的转换导致索引失效,查询效率大幅度降低)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/56.png" alt="">   </p>
<h6 id="2-数据库基本设计规范"><a href="#2-数据库基本设计规范" class="headerlink" title="2.数据库基本设计规范"></a>2.数据库基本设计规范</h6><p>1.所有表必须使用Innodb存储引擎<br>Mysql5.5使用之前Myisam(默认存储引擎)情况,默认数据库存储引擎必须使用Innodb存储引擎,除非有特殊用途(原因:1.mysql5.6版本之后,Innodb存储引擎成为了mysql的默认引擎,进行了很多优化 2.innodb存储引擎支持事务,行级锁,更好的恢复性,高并发下性能更好。)<br>2.数据库和表的字符集统一使用UTF-8(utf-8兼容性更好,几乎支持常用的所有字符,如果在表列中存储短信符号,那么使用utf-8的扩展字符集才可以,还可以避免字符集转换产生的一些乱码)–注意:Mysql中utf-8字符集汉字为3个自己,ASCII码占用1个字节<br>3.所有表和字段都需要添加注释(便于维护)<br>4.尽量控制单表数据量的大小,建议控制在500万以内(1.数据太大,查询效率有影响 2.修改表结构,备份,回复都会有很大问题 3.500万并不是MySQL数据库的限制 4.Mysql最多可以存储多少万条数据:没有规定 5.可以用历史数据归档,分库分表等手段来控制数据量的大小进而保证单表数据量在500万以内)<br>5.谨慎使用MySQL分区表(1. 误解:因为分区表在物理上表现为多个文件,在逻辑上表现为一个表,利用磁盘的io 提高查询性能,但是io的更好利用是有条件的,最好情况下分区表分区文件存放在不同分区文件上,如果把所有分区文件放到一起,实际上对io优化效果不是那么好,如果硬要选择分区:谨慎选择分区键,跨分区查询效率可能更低 2.建议采用物理分表的方式管理大数据)<br>6.尽量做到冷热数据分离,减少表的宽度/减少字段数(MySQL限制最多存储4096列,每一行数据大小不能超过65535)<br>7.禁止在表中建立预留字段(很多开发人员都容易违反,在表中预留很大的varchar类型的不确定字段,后续使用,实际上:1预留字段的命名很难做到见名识义 2.预留字段无法确认存储的数据类型,所以无法选择合适的类型 3.后期对预留字段类型的修改,也会对表进行锁定,mysql修改一个字段成本大于新增一个字段)<br>8.禁止在数据库中存储数据图片,文件等二进制数据(1.过多影响数据性能,往往这些数据都是很大的数据 2.将文件图片存储到文件服务器,数据库中值存储文件图片信息)<br>9.禁止在线上做数据库的压力测试<br>10.禁止从开发环境,测试环境直连生产环境数据库  </p>
<h6 id="3-数据库索引设计规范"><a href="#3-数据库索引设计规范" class="headerlink" title="3.数据库索引设计规范"></a>3.数据库索引设计规范</h6><p>索引对数据库的查询性能来说是非常重要的,但是索引也是双刃剑,使用不好反而会降低数据库的性能,不要滥用索引  </p>
<p>1.限制每张表上的索引数量,建议单张表索引不超过5个(一般来说索引数量和列数量成正比的,列越多索引越多,所以规范中不能使用较多的列数量)。<br>2.</p>
<h6 id="4-数据库字段设计规范"><a href="#4-数据库字段设计规范" class="headerlink" title="4.数据库字段设计规范"></a>4.数据库字段设计规范</h6><p>字段类型设计</p>
<h6 id="5-数据库SQL开发规范"><a href="#5-数据库SQL开发规范" class="headerlink" title="5.数据库SQL开发规范"></a>5.数据库SQL开发规范</h6><p>编写sql语句时候,所指定的规范  </p>
<h6 id="6-数据库操作行为规范"><a href="#6-数据库操作行为规范" class="headerlink" title="6.数据库操作行为规范"></a>6.数据库操作行为规范</h6><p>针对于数据库运维人员,减少数据库故障  </p>
<h6 id="7-MySql5-6使用validate-password-插件加强密码强度的安装及使用方法"><a href="#7-MySql5-6使用validate-password-插件加强密码强度的安装及使用方法" class="headerlink" title="7.MySql5.6使用validate password 插件加强密码强度的安装及使用方法"></a>7.MySql5.6使用validate password 插件加强密码强度的安装及使用方法</h6><p><a href="https://www.cnblogs.com/kevingrace/p/5752632.html" target="_blank" rel="external">https://www.cnblogs.com/kevingrace/p/5752632.html</a></p>
<p><a href="https://www.jb51.net/article/87773.htm" target="_blank" rel="external">https://www.jb51.net/article/87773.htm</a></p>
<p>密码3次被锁定,锁定时间是24小时<br><a href="https://blog.csdn.net/qq_25237663/article/details/47723913" target="_blank" rel="external">https://blog.csdn.net/qq_25237663/article/details/47723913</a></p>
<h6 id="8-linux运维查询磁盘和大文件"><a href="#8-linux运维查询磁盘和大文件" class="headerlink" title="8.linux运维查询磁盘和大文件"></a>8.linux运维查询磁盘和大文件</h6><p><a href="https://uule.iteye.com/blog/2149323" target="_blank" rel="external">https://uule.iteye.com/blog/2149323</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/01/23/mysql优化-1-准备/" class="archive-article-date">
  	<time datetime="2019-01-23T15:58:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-01-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-work-7-ipcc对接科大机器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/10/work-7-ipcc对接科大机器/">work-7-ipcc对接科大机器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>平台对接科大机器人时候,需要机器人经过合成和识别的步骤，其中ivr系统和科大机器人交互流程如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/22.png" alt=""> </p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h5><p>1.机器人识别时候,有两种场景。1.边播音时候时候边识别   2.客户说话说完之后再识别    </p>
<h6 id="1-查看ivr和CRS的动态流程"><a href="#1-查看ivr和CRS的动态流程" class="headerlink" title="1.查看ivr和CRS的动态流程"></a>1.查看ivr和CRS的动态流程</h6><p>2.一种是纯播音不识别 一种是播放过程中同时识别 如果客户说话 会停掉播音<br>有 看日志就知道了<br>看dyflow01的日志<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/23.png" alt=""><br>如果是100 就只是播音 不识别<br>如果是110 就是播音同时识别<br>如果是010 就是只识别 不放音<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/24.png" alt=""><br>你做测试的时候 可以每次重启一下dyflow 这样每通电话都可以产生一个日志<br>再对照日志看指令  很容易看的  </p>
<h6 id="2-wireshake抓包"><a href="#2-wireshake抓包" class="headerlink" title="2.wireshake抓包"></a>2.wireshake抓包</h6><p>将流程多过几次 每次都抓一下包<br>然后用wireshark看一下语音流有没有送过去<br>记几个指令就行<br>每个电话抓一次包<br>tcpdump -w 文件名<br>比如 tcpdump -w aaa.cap<br>然后将cap文件拷贝到本地用wireshark打开<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/25.png" alt=""><br>图形化就看这个<br>里面<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/26.png" alt=""><br>84是tts 86是asr<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/27.png" alt=""><br>通话期间的 选这几个按钮就能听到语音<br>说明我们送过去了<br>抓取sip包,去除rtp包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i eth0 port 14905 -w sip_20190515.cap</div></pre></td></tr></table></figure></p>
<h6 id="1-1-边播音时候时候边识别"><a href="#1-1-边播音时候时候边识别" class="headerlink" title="1.1 边播音时候时候边识别"></a>1.1 边播音时候时候边识别</h6><h6 id="1-2-客户说话说完之后再识别"><a href="#1-2-客户说话说完之后再识别" class="headerlink" title="1.2 客户说话说完之后再识别"></a>1.2 客户说话说完之后再识别</h6><h5 id="3-ipcc活动管理"><a href="#3-ipcc活动管理" class="headerlink" title="3.ipcc活动管理"></a>3.ipcc活动管理</h5><p>1.活动暂停(event_state=0)时候ipcc从缓存中移除event并设置状态为-1，此时活动就可以启用了(event_state=1) 此时ipcc会加载活动到内存中,所以我们需要改变活动数据时候,我们需要在event_state=-1时候进行修改,然后再启用活动。<br>2.活动加载到内存时候,会把活动的策略通过sql读取出来,我们在dbg_dbg01_xxxx.log中可以看到<br>3.活动在内存中名单少于5000条时候,会大概每个10s扫描一次活动下面的名单<br>4.基于2,3我们从我们在dbg_dbg01_xxxx.log中可以看到读取活动策略的sql就很少此,而读取活动的名单就很多次<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/35.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/36.png" alt=""></p>
<h5 id="4-ipcc将fsg两个日志级别调到6"><a href="#4-ipcc将fsg两个日志级别调到6" class="headerlink" title="4.ipcc将fsg两个日志级别调到6"></a>4.ipcc将fsg两个日志级别调到6</h5><p>在cc/cfg目录下:<br>1.查看<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/48.png" alt=""><br>2.修改fsg.cfg:vi fsg.cfg<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/50.png" alt=""><br>3.修改dyflow:vi dyflow.cfg<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/51.png" alt=""><br>3.启动<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/01/49.png" alt="">  </p>
<h5 id="5-mysql"><a href="#5-mysql" class="headerlink" title="5.mysql"></a>5.mysql</h5><p>mysql优化:<a href="https://blog.csdn.net/afsvsv/article/details/84998119" target="_blank" rel="external">https://blog.csdn.net/afsvsv/article/details/84998119</a></p>
<h5 id="6-平台任务中名单未拨打"><a href="#6-平台任务中名单未拨打" class="headerlink" title="6.平台任务中名单未拨打"></a>6.平台任务中名单未拨打</h5><p>问题:平台任务中名单未拨打<br>问题排查:<br>1.查看cti_cdr中拨打记录(查看此表是最直观的,如果此表有记录,但是用户未接到,可能是线路等问题),如果此处没有呼叫记录,继续下看。<br>2.查看notify进程:ps -ef | grep /cc/bin.<br>3.dbg_dbg01_1550971499.log日志中:<br>   a.任务加载正常:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT event_id, tenant_id, a.queue_id, a.creater,   a.max_line, a.caller, a.max_member_id, a.event_state,a.success_count,a.answer_count,a.failed_count,a.toacd_count, a.time_len,a.load_list_count,a.send_type,a.templet_id,a.event_level,a.drop_cause_tid FROM ocm_event a, cti_entinfo b WHERE a.tenant_id=b.id AND b.state=0  AND a.node_flow = &apos;300&apos; 	AND a.event_state IN(0, 1, 2, 5)       AND a.send_time &lt;= NOW()  AND NOW() &lt;= a.over_time       AND a.send_type IN (1,2,3,4)      ORDER BY a.event_id</div></pre></td></tr></table></figure>
</code></pre><p>   b.任务工作日正常(ocm_event_strategy):</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT c.workday_type, date_format(c.start_time, &apos;%Y-%m-%d %H:%i:%s&apos;) as st, date_format(c.end_time, &apos;%Y-%m-%d %H:%i:%s&apos;) as et FROM ocm_event a, ocm_event_strategy b ,ocm_workday c     WHERE a.event_id = 89 and a.event_id=b.event_id and b.strategy_id=c.workday_id  and  b.strategy_type=1 and c.is_work=0 and c.workday_type = 0      ORDER BY st</div></pre></td></tr></table></figure>
</code></pre><p>   c.任务时间段正常(ocm_calltime_strategy):</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT c.calltime_id, c.start_call_time, c.end_call_time  FROM ocm_event a, ocm_event_strategy b ,ocm_calltime_strategy c     WHERE a.event_id = 89 and a.event_id=b.event_id and b.strategy_id=c.calltime_id</div><div class="line">and  b.strategy_type=2 and c.is_work=0      ORDER BY c.start_call_time</div></pre></td></tr></table></figure>
</code></pre><p>   d.查看拨打的名单是否加载到内存(ocm_buslist ):</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT b.list_id,  b.customer_phone, b.cust_id,b.extend FROM ocm_buslist b      WHERE b.event_id = 89     AND b.list_id &gt; 0    ORDER BY b.list_id  LIMIT 10000</div></pre></td></tr></table></figure>
</code></pre><p>4.查看企业状态(cti_entinfo)是否为0-启用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM cti_entinfo WHERE id = 1269</div></pre></td></tr></table></figure></p>
<p>5.查看线路资源表(ocm_enti_exinfo)是否0-启用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM ocm_enti_exinfo WHERE entid = 1269</div></pre></td></tr></table></figure></p>
<p>6.如果上面都没有问题(ocm_buslist表数据已经加载了,任务表里面的memberid还没有更新等),就有可能是平台自身的问题,这些问题都不是简单的出现,而是经过多个批次数据呼叫时候可能出现。比如:maxline太小取整算法有问题。</p>
<h5 id="7-平台-转人工失败查看"><a href="#7-平台-转人工失败查看" class="headerlink" title="7.平台-转人工失败查看"></a>7.平台-转人工失败查看</h5><h6 id="1-确保坐席能够嵌入"><a href="#1-确保坐席能够嵌入" class="headerlink" title="1.确保坐席能够嵌入"></a>1.确保坐席能够嵌入</h6><p>坐席不能够签入:坐席没有添加到队列中:cti_queue中是否有队列  cti_work_queue中是否加入坐席到队列中  </p>
<h6 id="2-ccos系统外拨模块"><a href="#2-ccos系统外拨模块" class="headerlink" title="2.ccos系统外拨模块"></a>2.ccos系统外拨模块</h6><p>查看此批次和场景是否配置了选择了转人工,并选择了坐席队列<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/03/2.png" alt="">  </p>
<h6 id="3-cti-outcaller表查看"><a href="#3-cti-outcaller表查看" class="headerlink" title="3.cti_outcaller表查看"></a>3.cti_outcaller表查看</h6><p>点击坐席”上线”,如果坐席不能上线,查看以下表:cti_outcaller是否配置了此租户下的主叫:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/03/1.png" alt=""><br>如果没有配置,添加进去,然后重启一下acd服务,再试一下坐席是否可上线</p>
<h6 id="4-查看除改坐席之外坐席是否可以上线"><a href="#4-查看除改坐席之外坐席是否可以上线" class="headerlink" title="4.查看除改坐席之外坐席是否可以上线"></a>4.查看除改坐席之外坐席是否可以上线</h6><ol>
<li>有时候,同一个坐席工号100001在多台pc端签入时候,导致此坐席不能上线,这个时候,用下100002能否签入。  </li>
<li>有时候,如果我们的坐席不能签入,这个时候用软电话条demo试试<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/22.png" alt=""> </li>
</ol>
<h6 id="4-查看cc-logs下acd日志"><a href="#4-查看cc-logs下acd日志" class="headerlink" title="4.查看cc/logs下acd日志"></a>4.查看cc/logs下acd日志</h6><p>acd_acd01.log日志:<br>a.查看坐席转台:r:getworkinfo workno=[888811],callstate[1]<br>b.查看坐席所在队列id:SELECT  queueid FROM cti_work_queue  WHERE  workno = ‘888811’ AND entid = 1270</p>
<h5 id="8-平台修改科大crs地址"><a href="#8-平台修改科大crs地址" class="headerlink" title="8.平台修改科大crs地址"></a>8.平台修改科大crs地址</h5><h6 id="8-1-dyflow修改"><a href="#8-1-dyflow修改" class="headerlink" title="8.1 dyflow修改"></a>8.1 dyflow修改</h6><p>ipcc和crs系统对接时候,需要修改对接科大crs地址。在系统cfg目录下dyflow下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/03/3.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/03/4.png" alt=""><br>重启dyflow<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/03/5.png" alt=""> </p>
<h6 id="8-1-httpg修改"><a href="#8-1-httpg修改" class="headerlink" title="8.1 httpg修改"></a>8.1 httpg修改</h6><p>平台和crs是通过http协议进行交互,所有交互的都需要经过httpg模块的server<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/03/8.png" alt=""> </p>
<h5 id="9-平台修改tts-asr地址"><a href="#9-平台修改tts-asr地址" class="headerlink" title="9.平台修改tts,asr地址"></a>9.平台修改tts,asr地址</h5><ol>
<li>tts以及asr对接是freeswitch模块和其对接的,所以我们需要修改freeswitch配置里面的信息。  </li>
<li>修改tts和asr地址是在freeswitch模块修改<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/03/6.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/03/7.png" alt="">  </li>
<li>修改之后,我们需要让配置生效就需要重启freeswitch，fsg模块。<br>1.fs停止:进入:/usr/local/freeswitch/bin,执行如下指令:    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./freeswitch -stop</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/88.png" alt=""><br>2.fs启动:进入:/usr/local/freeswitch/bin,执行如下指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./freeswitch -nc -nonat</div></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/89.png" alt=""><br>3.然后再 到/cc/bin下 ./fsg.sh restart<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/90.png" alt=""></p>
<h5 id="9-ivr流程制作"><a href="#9-ivr流程制作" class="headerlink" title="9.ivr流程制作"></a>9.ivr流程制作</h5><h5 id="10-查看平台外呼的彩铃录音"><a href="#10-查看平台外呼的彩铃录音" class="headerlink" title="10.查看平台外呼的彩铃录音"></a>10.查看平台外呼的彩铃录音</h5><p>freeswitch中开启录音命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">da2 record 文件目录</div></pre></td></tr></table></figure></p>
<p>freeswitch中停止录音命令(开启录音不叫文件目录):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">da2 record</div></pre></td></tr></table></figure></p>
<p>1.进入/usr/local/freeswitch/bin目录下,客户端连接freeswitch  </p>
<pre><code>./fs_cli -P 8031 -p testtest  
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/1.png" alt=""></p>
<p>2.设置fs的日志级别为1   </p>
<pre><code>console loglevel 1  
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/2.png" alt=""></p>
<p>3.修改彩铃文件路径  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/3.png" alt="">  </p>
<p>4.拨打电话<br>5.在cc/log目录下下载生成的录音,并试听<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/4.png" alt="">  </p>
<h5 id="11-一人多号码"><a href="#11-一人多号码" class="headerlink" title="11.一人多号码"></a>11.一人多号码</h5><h6 id="11-1-主流程"><a href="#11-1-主流程" class="headerlink" title="11.1 主流程"></a>11.1 主流程</h6><ol>
<li>针对于一个客户多个号码的情况,客户需求:1.呼叫平台未接通,重呼一次后还没有结果,就通知java应用导入数据到ocm_buslist(外呼名单表) 进行呼叫客户下一个号码 2.平台呼叫通,机器人判断不是本人时候就通知java应用导入数据到ocm_buslist(外呼名单表)进行呼叫客户下一个号码  </li>
<li>主流程如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/5.png" alt="">  </li>
</ol>
<h6 id="11-2-平台一人多号码排查"><a href="#11-2-平台一人多号码排查" class="headerlink" title="11.2 平台一人多号码排查"></a>11.2 平台一人多号码排查</h6><h6 id="1-一般排查"><a href="#1-一般排查" class="headerlink" title="1.一般排查"></a>1.一般排查</h6><p>1.任务表(ocm_event):drop_cause_tid的入口就是ocm_after_call_module中id,如果任务没有配置,则默认drop_cause_tid为-1,以下3表就相当于ivr流程中：cti_flow,cti_action,cti_rootflow<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/6.png" alt=""><br>2.查看ocm_after_call_action对应的脚本是否是ivr中类型为http的action,并且对应的callback接口是否是<br>“主流程”中”临时数据导入”，如下实例:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/7.png" alt="">   </p>
<p>3.在外呼任务中导入名单呼叫:ocm_after_call_module脚本执行是不会记录到dyflow中的,所以我们不用查看dyflow相关日志,只需要查看callnotify相关日志。<br>a.从callnotify_callnotify01中查看的是外呼的数据 写入到cti_cdr表中<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/9.png" alt=""><br>b.由于平台通知java应用走的是ivr中action—-http   所以在httpg<em>httpg01</em>.log会有记录<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/8.png" alt=""> </p>
<p>4.如果在httpg<em>httpg01</em>.log中没有记录并且一人多号码时候,第一个号码没接听,但是没有调用拨打第二个号码,这个时候说嘛callnotify有问题,我们去callnotify01看日志:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/10.png" alt=""><br>发现脚本加载错误,我们去ocm_after_call_flow查看:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/11.png" alt=""><br>然后发现是ocm_after_call_action问题:</p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/12.png" alt=""></p>
<h6 id="2-深度排查"><a href="#2-深度排查" class="headerlink" title="2.深度排查"></a>2.深度排查</h6><p>1.查看notify.cfg中是否配置了httpg<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/75.png" alt=""><br>2.查看callnotify_callnotify01xx.log中是否报错”no rootflow”<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/76.png" alt="">  </p>
<p>3.ocm_event的tid = ocm_after_call_module 的rootactid=ocm_after_call_flow表的 actid和preactid = ocm_after_call_action的id<br>ocm_after_call_param加一条默认记录<br>以event_id = 174 entid = 1278为例:<br>ocm_event<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/77.png" alt=""><br>ocm_after_call_module<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/78.png" alt=""><br>ocm_after_call_flow<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/79.png" alt=""><br>ocm_after_call_action<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/80.png" alt=""><br>ocm_after_call_param<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/81.png" alt="">  </p>
<h6 id="3-一人多号码轮呼加上重呼-混合呼叫"><a href="#3-一人多号码轮呼加上重呼-混合呼叫" class="headerlink" title="3.一人多号码轮呼加上重呼(混合呼叫)"></a>3.一人多号码轮呼加上重呼(混合呼叫)</h6><p>一人多号码中,</p>
<h6 id="11-3-查看shell脚本是否执行成功"><a href="#11-3-查看shell脚本是否执行成功" class="headerlink" title="11.3 查看shell脚本是否执行成功"></a>11.3 查看shell脚本是否执行成功</h6><ol>
<li><p>通过接口创建批次(营销管理系统)时候,我们任务已经启动,但是平台没有呼叫,查看dyflow日志看到对应的脚本:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /cc/bin/iniwrite.sh -w /cc/cfg/dyflow.cfg dyflow loadscript 1</div></pre></td></tr></table></figure>
</li>
</ol>
<p>已经执行</p>
<ol>
<li><p>但是外呼任务加载的日志却没有执行:  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /cc/bin/iniwrite.sh -w /cc/cfg/notify.cfg callnotify reloadocm 1</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个时候就得看脚本callnotify是否执行  </p>
<ol>
<li><p>步骤<br>1.执行重启callnotify命令:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/15.png" alt=""><br>2.postman接口创建新批次:数据如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/17.png" alt="">    </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">   &#123;</div><div class="line"> &quot;accountId&quot;: &quot;1269&quot;,</div><div class="line"> &quot;comcode&quot;: &quot;3200&quot;,</div><div class="line"> &quot;dataArr&quot;: [&#123;</div><div class="line">  &quot;age&quot;: &quot;&quot;,</div><div class="line">  &quot;busNum&quot;: &quot;苏EXM512&quot;,</div><div class="line">  &quot;city&quot;: &quot;&quot;,</div><div class="line">  &quot;custId&quot;: &quot;9140772385&quot;,</div><div class="line">  &quot;id&quot;: &quot;PIID201932000039214470&quot;,</div><div class="line">  &quot;idcard&quot;: &quot;321283198409297449&quot;,</div><div class="line">  &quot;num&quot;: &quot;15188317019&quot;,</div><div class="line">  &quot;salesmanName&quot;: &quot;&quot;,</div><div class="line">  &quot;salesmanNum&quot;: &quot;&quot;,</div><div class="line">  &quot;sex&quot;: &quot;&quot;,</div><div class="line">  &quot;userName&quot;: &quot;叶鑫明&quot;</div><div class="line"> &#125;],</div><div class="line"> &quot;endDate&quot;: &quot;2020-04-13&quot;,</div><div class="line"> &quot;frequency&quot;: &quot;3&quot;,</div><div class="line"> &quot;key&quot;: &quot;978f774acce1d5d20883bbba38d9bc21&quot;,</div><div class="line"> &quot;outboundPeriods&quot;: [75],</div><div class="line"> &quot;startDate&quot;: &quot;2019-04-10&quot;,</div><div class="line"> &quot;taskName&quot;: &quot;2019-04-10_叶鑫明&quot;,</div><div class="line"> &quot;taskSceneId&quot;: &quot;92&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>3.查看是否有执行日志输出(以下是有执行日志输出):<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/16.png" alt=""></p>
<p>5.特殊情况<br>之前是营销系统通过接口创建批次 马上就可以呼叫  昨天一直不呼叫  只有重启任务才会呼叫   但是我刚刚通过营销系统创建了批次  发现bin终端打印出了上面的信息  但是批次不呼叫  批次也是默认开启的  </p>
<p>解决:看下callnotify_callnotify01_xxxxx.log的日志 有没有出现iniwrite  如果没有 就说明你没修改reloadocm<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/07.png" alt=""></p>
<p>如果在java应用执行后没有出现上面的日志:我们去/cc/bin目录下执行<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/08.png" alt=""><br>此时去callnotify_callnotify01_xxxxx.log查看日志会有inwrite  </p>
<p>今天我把notify.sh给stop了,然后执行java应用的Runtime调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ShellUtil.excute(&quot;source /cc/bin/iniwrite.sh -w /cc/cfg/notify.cfg callnotify reloadocm 1&quot;);//这条指令相当于手动去修改notify.cfg中的参数reloadocm=1</div></pre></td></tr></table></figure></p>
<p>后面发现在notify.cfg里面的reloadocm结果还是0,这个时候就不能呼叫刚创建的批次。</p>
<h5 id="12-外呼提示”系统忙”"><a href="#12-外呼提示”系统忙”" class="headerlink" title="12.外呼提示”系统忙”"></a>12.外呼提示”系统忙”</h5><p>外呼提示系统忙是因为家在的flow脚本有问题/或者脚本在呼叫客户之前没来得及加载,查看dyflow_dyflow01xxxx.log即可知道。如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/13.png" alt=""></p>
<p>在预测式外呼页面操作任务时候:先创建任务和对应的ivr流程脚本(cti_flow,cti_action),导入名单数据,然后我们通过启动任务时候,发现这个时候拨打的数据报错:”系统忙”,原因是因为此时执行脚本:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ShellUtil.excute(&quot;source /cc/bin/iniwrite.sh -w /cc/cfg/dyflow.cfg dyflow reloadocm 1&quot;);</div></pre></td></tr></table></figure>
</code></pre><p>还没有加载时候,就已经拨打了电话。<br>我们需要在任务创建时候就执行上面脚本。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/14.png" alt="">  </p>
<h5 id="13-修改流程超时时间sessiontimeout"><a href="#13-修改流程超时时间sessiontimeout" class="headerlink" title="13.修改流程超时时间sessiontimeout"></a>13.修改流程超时时间sessiontimeout</h5><ol>
<li>武汉数据呼叫时候,出现几千秒才会挂机的拨打,查看数据库时候,是如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/18.png" alt="">  </li>
<li>以上原因是超时未挂机,我们可以设置超时时间来在短时间内挂机(sessiontimeout)。<br>notify.cfg设置为:10s拨打电话 10s不接听后会自己挂机<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/19.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/20.png" alt=""><br>dyflow.cfg设置为:10s拨打电话 10s后接听后会自己挂机<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/21.png" alt="">    </li>
</ol>
<h5 id="14-平台升级"><a href="#14-平台升级" class="headerlink" title="14.平台升级"></a>14.平台升级</h5><p>呼叫平台升级时候,我们需要进入平台的lib目录  把测试环境下的lib里面的包 拷贝到 生产环境 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp root@内网ip:/cc/lib/libT*so*  .</div></pre></td></tr></table></figure></p>
<p>判断升级成功没:<br>重启后 灌入一条名单进去 导入名单成功的时候才会有日志 查下 callnotify01的日志  loadbeginid    找到这个字样 就升级对了  </p>
<p>019-04-28 17:54:17.700 TDbOpt.dbDoSql ok, h=[375015], sql=[select b.list_id,,loadbeginid[3464456],_loadmaxid[3465458] 但确实有3条是在里面的啊  </p>
<h5 id="15-平台测试环境下进行呼叫数据测试"><a href="#15-平台测试环境下进行呼叫数据测试" class="headerlink" title="15.平台测试环境下进行呼叫数据测试"></a>15.平台测试环境下进行呼叫数据测试</h5><p>平台外呼号码为:5开头的8位数字的号码   拨打时候是不会计费的  可当做测试数据使用<br>如:80000001   80000002  </p>
<h5 id="16-200问题"><a href="#16-200问题" class="headerlink" title="16.-200问题"></a>16.-200问题</h5><ol>
<li>-200  你将sessiontime设置短一点就有了</li>
<li>已接听,只看200或者-200或者0不行  还要判断connect is not null </li>
<li>所以我们有时候不接听电话，电话主动挂机超时,有可能出现下面问题。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/87.png" alt="">  </li>
<li>出现上面问题的原因如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/86.png" alt=""> </li>
</ol>
<h5 id="17-系统变量"><a href="#17-系统变量" class="headerlink" title="17.系统变量"></a>17.系统变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">setSessionParam(index, &quot;callid&quot;, sinfo.sid.substr(0, sinfo.sid.length() - 5), sinfo);</div><div class="line">setSessionParam(index, &quot;caller&quot;, sinfo.caller, sinfo);</div><div class="line">setSessionParam(index, &quot;called&quot;, sinfo.called, sinfo);</div><div class="line">setSessionParam(index, &quot;callop&quot;, sinfo.callop, sinfo);</div><div class="line">setSessionParam(index, &quot;dropcause&quot;, ::FunUtil::intToString(sinfo.dropcause), sinfo);</div><div class="line">setSessionParam(index, &quot;starttime&quot;, sinfo.iamtime, sinfo);</div><div class="line">setSessionParam(index, &quot;starttimesec&quot;, ::FunUtil::intToString(sinfo.iamtimestp), sinfo);</div><div class="line">setSessionParam(index, &quot;endtime&quot;,sinfo.reltime, sinfo);</div><div class="line">setSessionParam(index, &quot;anctime&quot;, sinfo.anctime, sinfo);</div><div class="line">setSessionParam(index, &quot;entid&quot;, ::FunUtil::intToString(sinfo.entid), sinfo);</div><div class="line">setSessionParam(index, &quot;notifyid&quot;, ::FunUtil::intToString(sinfo.vsTask.notifyid), sinfo);</div><div class="line">setSessionParam(index, &quot;memberid&quot;, ::FunUtil::intToString(sinfo.vsTask.memberid), sinfo);</div><div class="line">setSessionParam(index, &quot;userid&quot;, ::FunUtil::intToString(sinfo.vsTask.userid), sinfo);</div><div class="line">setSessionParam(index, &quot;extend&quot;, sinfo.vsTask.extinfo, sinfo);</div></pre></td></tr></table></figure>
<h5 id="18-平台搭建"><a href="#18-平台搭建" class="headerlink" title="18.平台搭建"></a>18.平台搭建</h5><ol>
<li><p>0.安装前准备<br>a.查看linux版本:(针对于不同版本,安装不同freeswitch)<br>cat /etc/redhat-release 查看CentOS版本<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/201.png" alt=""><br>b.安装数据库时候确保yum源可用<br>执行:yum install mysql 出现下面错误：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/202.png" alt=""><br>linux服务器的yum源配置:<a href="https://blog.csdn.net/qq_21277477/article/details/82220139" target="_blank" rel="external">https://blog.csdn.net/qq_21277477/article/details/82220139</a></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http://mirrors.aliyun.com/repo/Centos-7.repo</div><div class="line">//上传至/etc/yum.repo.d/目录下</div><div class="line">mv Centos-7.repo Centos-Base.repo</div></pre></td></tr></table></figure>
</li>
</ol>
<p>c.出现不能写文件时候执行如下操作:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/203.png" alt=""></p>
<p>搭建平台之前我们需要安装数据库:<br><a href="https://www.cnblogs.com/freely/p/8087885.html" target="_blank" rel="external">https://www.cnblogs.com/freely/p/8087885.html</a>  </p>
<p>我们有时候需要搭建新的平台环境,常见的方法是从其他环境上整理数据,然后拷贝数据到新的环境下。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zcvf cc.tar.gz /cc --exclude=/cc/log --exclude=/cc/data --exclude=/cc/freeswitch/bin/da_record  --exclude=/cc/bin/log  --exclude=/cc/apps  --exclude=/cc/tomcat-acdgate --exclude=/cc/tomcat-loglook</div></pre></td></tr></table></figure>
<ol>
<li><p>1、压缩文件:cc下面除了log、data两个别压，其他都压。data里面的 全程录音别压、压缩后文件如下(大概900M):<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/91.png" alt="">   </p>
</li>
<li><p>2、解压文件<br>tar -zxvf cc.tar.z  </p>
</li>
<li><p>3、添加环境变量并启用:编辑/etc/profile 在最后加入下面一行<br>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/cc/cclib     </p>
</li>
</ol>
<p>生效:<br>source /etc/profile </p>
<ol>
<li>4、软链接fs:<br>ln -s /cc/freeswitch /usr/local/freeswitch  </li>
</ol>
<ol>
<li>5、修改vars.xml internal.xml external.xml的地址，启动freeswitch验证fs启动错误提示（正常的话除了提示数据库yccc连接有问题，其它正常）<br>进入freeswitch/conf文件夹里面:<br>vars.xml里面配置的是:<br>修改本服务器提供的外部访问地址及域名:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/1.png" alt=""><br>进入freeswitch/conf/sip_profiles修改internal.xml external.xml<br>internal.xml修改外部提供的sip和rtp访问地址；<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/2.png" alt=""><br>external.xml修改rtp.sip地址:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/3.png" alt="">    </li>
</ol>
<p>修改freeswitch连接数据库:freeswitch/scripts/user.lua<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/4.png" alt="">   </p>
<p>修改ipcc呼叫数据源配置:<br>将acd.cfg、dyflow.cfg、notify.cfg,fsg.cfg、dialout.cfg文件里面数据库用户密码改一下<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/5.png" alt=""></p>
<ol>
<li><p>6、安装数据库(在数据库服务器上装、一定要安装配置日志，避免数据丢失)、odbc并配置、先配置数据库试试 （数据库导入脚本 数据库脚本找小叶要一份最新的）<br>mysql-odbc驱动安装:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install mysql-connector-odbc</div></pre></td></tr></table></figure>
</code></pre></li>
</ol>
<p>修改或创建文件:/etc/odbc.ini,内容如下:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">      [yccc]</div><div class="line">Description     = MySQL test database</div><div class="line">Trace       = Off</div><div class="line">TraceFile   = stderr</div><div class="line">Driver      = MySQL</div><div class="line">SERVER      = 127.0.0.1</div><div class="line">USER        = root</div><div class="line">PASSWORD    = 123456</div><div class="line">PORT        = 3306</div><div class="line">DATABASE    = callcenter</div><div class="line">charset = UTF8</div><div class="line">OPTION = 67108864</div><div class="line">Threading = 0</div></pre></td></tr></table></figure>
</code></pre><p>配置是否成功，执行以下指令:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">isql yccc</div></pre></td></tr></table></figure>
</code></pre><p>如果连接失败、查看一下地方:<br>连接失败首先查看下:isql -v yccc<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/204.png" alt=""><br>从其他服务器拷贝:<br>scp root@172.31.185.112:/usr/lib64/libmyodbc* .<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/205.png" alt=""><br>a./etc/odbc.ini(内网访问尽量用127.0.0.1、127不用寻找路由)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/28.png" alt=""><br>b./etc/odbcinst.ini<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/27.png" alt=""><br>c.连接成功的情况<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/29.png" alt=""></p>
<p>/etc/odbc.ini<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/25.png" alt=""></p>
<ol>
<li><p>7、安装gdb  yum install gdb （不是必须）  安装gc++: yum install gcc++</p>
</li>
<li><p>8、配置jdk 1.8环境 JAVA_HOME CLASSPATH等<br>1）执行：vi /etc/profile 在文件末尾添加<br>export JAVA_HOME=/cc/jdk1.8/jdk1.8.0_141<br>　　 export JRE_HOME=$JAVA_HOME/jre<br>　　 export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib<br>　　 export PATH=$JAVA_HOME/bin:$PATH</p>
<p>2）使配置生效：source /etc/profile<br>3）执行java -version 确认配置生效</p>
</li>
<li><p>9.修改ag.cfg里面的sidhead前缀、这个是用于表示区分集群每个节点数据、将ag重启一下、这样数据就不重复了 将来合库cdr不会有重复。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/26.png" alt=""> </p>
</li>
</ol>
<h6 id="9-dyflow启动失败解决方案"><a href="#9-dyflow启动失败解决方案" class="headerlink" title="9.dyflow启动失败解决方案:"></a>9.dyflow启动失败解决方案:</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/6.png" alt=""></p>
<ol>
<li>1.配置core<br>参照qa那个文档配置core<br>一、在/etc/profile中加入：<br>ulimit -c unlimited</li>
</ol>
<p>二、在/etc/rc.local中加入：<br>echo “/cc/log/coredump.%e.%p” &gt; /proc/sys/kernel/core_pattern  </p>
<ol>
<li>2.查看core<br>cc/log下，有没core开头的文件<br><a href="https://www.cnblogs.com/Anker/p/6079580.html" target="_blank" rel="external">linux下core dump</a></li>
</ol>
<h5 id="ICE实战"><a href="#ICE实战" class="headerlink" title="ICE实战"></a>ICE实战</h5><p><a href="https://www.cnblogs.com/SGSoft/archive/2007/05/02/734775.html" target="_blank" rel="external">https://www.cnblogs.com/SGSoft/archive/2007/05/02/734775.html</a><br><a href="https://blog.csdn.net/qiunian144084/article/details/80654443" target="_blank" rel="external">https://blog.csdn.net/qiunian144084/article/details/80654443</a><br><a href="https://blog.csdn.net/god_wot/article/details/50332997/" target="_blank" rel="external">https://blog.csdn.net/god_wot/article/details/50332997/</a><br><a href="https://blog.csdn.net/xuzheng_java/article/details/24459181" target="_blank" rel="external">https://blog.csdn.net/xuzheng_java/article/details/24459181</a><br><a href="http://www.blogjava.net/paulwong/archive/2015/11/13/428186.html" target="_blank" rel="external">http://www.blogjava.net/paulwong/archive/2015/11/13/428186.html</a><br><a href="https://wenku.baidu.com/view/f80f910bba1aa8114431d9e7.html" target="_blank" rel="external">https://wenku.baidu.com/view/f80f910bba1aa8114431d9e7.html</a>  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/01/10/work-7-ipcc对接科大机器/" class="archive-article-date">
  	<time datetime="2019-01-10T05:41:07.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-01-10</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/work/">work</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-work-6-jenkins搭建绑定git失败" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/31/work-6-jenkins搭建绑定git失败/">work-6-jenkins搭建绑定git失败</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>1.搭建jenkins环境时候,关联马原账号老是出错,以下是解决方法</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>参考:<a href="https://blog.csdn.net/zzpzheng/article/details/52132311" target="_blank" rel="external">https://blog.csdn.net/zzpzheng/article/details/52132311</a></p>
<p><a href="https://www.jianshu.com/p/5f671aca2b5a" target="_blank" rel="external">https://www.jianshu.com/p/5f671aca2b5a</a><br><a href="https://www.cnblogs.com/rslai/p/8135460.html" target="_blank" rel="external">https://www.cnblogs.com/rslai/p/8135460.html</a><br><a href="https://www.cnblogs.com/along21/p/9724036.html" target="_blank" rel="external">https://www.cnblogs.com/along21/p/9724036.html</a>  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2018/12/31/work-6-jenkins搭建绑定git失败/" class="archive-article-date">
  	<time datetime="2018-12-31T13:45:08.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-12-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/work/">work</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/52/">52</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/CTI/" style="font-size: 11.05px;">CTI</a> <a href="/tags/Cookie/" style="font-size: 10.53px;">Cookie</a> <a href="/tags/DevelopmentSkills/" style="font-size: 10px;">DevelopmentSkills</a> <a href="/tags/Easyui/" style="font-size: 10px;">Easyui</a> <a href="/tags/ElasticStack/" style="font-size: 16.32px;">ElasticStack</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IE问题/" style="font-size: 10px;">IE问题</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 12.11px;">JVM</a> <a href="/tags/JavaSE/" style="font-size: 15.26px;">JavaSE</a> <a href="/tags/Jeecg/" style="font-size: 11.58px;">Jeecg</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Myeclipse/" style="font-size: 14.21px;">Myeclipse</a> <a href="/tags/Netty/" style="font-size: 16.84px;">Netty</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 16.84px;">Oracle</a> <a href="/tags/Redis/" style="font-size: 12.11px;">Redis</a> <a href="/tags/Servlet/" style="font-size: 11.58px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 10.53px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/SpringBoot/" style="font-size: 19.47px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 12.11px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 11.05px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Vue/" style="font-size: 18.95px;">Vue</a> <a href="/tags/Vue-js-前端开发-快速入门与专业应用/" style="font-size: 17.37px;">Vue.js+前端开发+快速入门与专业应用</a> <a href="/tags/Weblogic/" style="font-size: 12.11px;">Weblogic</a> <a href="/tags/Websocket/" style="font-size: 10.53px;">Websocket</a> <a href="/tags/Work-Problem/" style="font-size: 10px;">Work-Problem</a> <a href="/tags/acdgate/" style="font-size: 10px;">acdgate</a> <a href="/tags/bg/" style="font-size: 10px;">bg</a> <a href="/tags/c/" style="font-size: 11.05px;">c</a> <a href="/tags/crawler/" style="font-size: 17.89px;">crawler</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/easyui/" style="font-size: 10px;">easyui</a> <a href="/tags/freeswitch/" style="font-size: 10px;">freeswitch</a> <a href="/tags/hibernate/" style="font-size: 10.53px;">hibernate</a> <a href="/tags/html-css/" style="font-size: 10.53px;">html+css</a> <a href="/tags/html-css/" style="font-size: 15.26px;">html-css</a> <a href="/tags/html-ss/" style="font-size: 10px;">html-ss</a> <a href="/tags/im/" style="font-size: 13.68px;">im</a> <a href="/tags/ipcc/" style="font-size: 10.53px;">ipcc</a> <a href="/tags/jQuery/" style="font-size: 12.11px;">jQuery</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/java-String/" style="font-size: 10px;">java String</a> <a href="/tags/javaSE/" style="font-size: 10.53px;">javaSE</a> <a href="/tags/javaWeb/" style="font-size: 10px;">javaWeb</a> <a href="/tags/javascript/" style="font-size: 11.05px;">javascript</a> <a href="/tags/java并发编程/" style="font-size: 11.58px;">java并发编程</a> <a href="/tags/java集合/" style="font-size: 10.53px;">java集合</a> <a href="/tags/junit测试/" style="font-size: 10px;">junit测试</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 16.84px;">linux</a> <a href="/tags/log4j/" style="font-size: 11.58px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/netty/" style="font-size: 11.58px;">netty</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodeJs/" style="font-size: 10px;">nodeJs</a> <a href="/tags/redis/" style="font-size: 12.63px;">redis</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/shiro/" style="font-size: 12.63px;">shiro</a> <a href="/tags/sockJs/" style="font-size: 10px;">sockJs</a> <a href="/tags/socket网络编程/" style="font-size: 10.53px;">socket网络编程</a> <a href="/tags/struts1/" style="font-size: 11.05px;">struts1</a> <a href="/tags/vue/" style="font-size: 10.53px;">vue</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weblogic/" style="font-size: 11.05px;">weblogic</a> <a href="/tags/websocket/" style="font-size: 15.79px;">websocket</a> <a href="/tags/work/" style="font-size: 14.74px;">work</a> <a href="/tags/zyzx/" style="font-size: 18.42px;">zyzx</a> <a href="/tags/代理/" style="font-size: 11.58px;">代理</a> <a href="/tags/前端/" style="font-size: 10.53px;">前端</a> <a href="/tags/动手写一个MVC/" style="font-size: 12.11px;">动手写一个MVC</a> <a href="/tags/反射/" style="font-size: 15.79px;">反射</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/微博/" style="font-size: 10px;">微博</a> <a href="/tags/文件读取/" style="font-size: 10px;">文件读取</a> <a href="/tags/泛型/" style="font-size: 13.16px;">泛型</a> <a href="/tags/注解/" style="font-size: 11.05px;">注解</a> <a href="/tags/类加载器/" style="font-size: 13.16px;">类加载器</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/自己写一个apache服务器/" style="font-size: 16.84px;">自己写一个apache服务器</a> <a href="/tags/转载/" style="font-size: 12.11px;">转载</a> <a href="/tags/集合/" style="font-size: 12.11px;">集合</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>