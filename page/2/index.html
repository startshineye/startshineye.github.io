<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/page/2/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-SpringCloud-4-应用通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/14/SpringCloud-4-应用通信/">SpringCloud-4-应用通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-HTTP-vs-RPC"><a href="#1-HTTP-vs-RPC" class="headerlink" title="1.HTTP vs RPC"></a>1.HTTP vs RPC</h4><ol>
<li>应用(微服务)间通讯方式主要有两种:HTTP和RPC</li>
<li>两种方式的主角:RPC–Dubbo  HTTP–SpringCloud  </li>
<li>Dubbo定位始终是一个RPC远程调用框架,而SpringCloud是微服务下的一站式解决方式</li>
<li>SpringCloud微服务下服务调用使用的是:HTTP Restful,HTTP Restful本身轻量、适应性强、可以很容易跨语言跨平台。</li>
<li>SpringCloud中服务间两种restful调用方式:1. RestTemplate 2.Feign  </li>
</ol>
<h4 id="2-RestTemplate的三种使用方式"><a href="#2-RestTemplate的三种使用方式" class="headerlink" title="2.RestTemplate的三种使用方式"></a>2.RestTemplate的三种使用方式</h4><ol>
<li>1.RestTemplate是一个HTTP客户端,类似于HttpClient,功能差不多,但是用法上更加简单。  <h4 id="2-1-RestTemplate例子"><a href="#2-1-RestTemplate例子" class="headerlink" title="2.1 RestTemplate例子"></a>2.1 RestTemplate例子</h4></li>
<li>1.使用 “订单服务-&gt;商品服务”为例</li>
<li>2.订单服务调用商品服务,我们把商品服务当做server端,订单服务当做client端</li>
<li>3.为了不影响之前的代码逻辑,我们新建单独的包为例子。  </li>
<li>4.product端新建ServerController</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author yxm</div><div class="line"> * @date 2019/4/20 0:16:16</div><div class="line"> */</div><div class="line">@RestController</div><div class="line">public class ServerController &#123;</div><div class="line">    </div><div class="line">    @GetMapping(&quot;/msg&quot;)</div><div class="line">   public String msg()&#123;</div><div class="line">       return &quot;this is product server mmsg&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line">5. 5.order服务中新建ClientController  </div><div class="line">RestTemplate第一种方式</div></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>@author yxm</li>
<li><p>@date 2019/4/20 0:18:18<br>*/<br>@RestController<br>@Slf4j<br>public class ClientController {</p>
<p> @GetMapping(“/getProductMsg”)<br> public String getProductMsg(){</p>
<pre><code>//1.RestTemplate第一种方式 
RestTemplate restTemplate = new RestTemplate();
String response = restTemplate.getForObject(&quot;http://localhost:8080/msg&quot;, String.class);
log.info(&quot;response{}&quot;,response);
return response;
</code></pre><p> }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">由于product服务已经启用了8080端口,我们用-D指令在order服务中用-Dserver.port=8081,不建议直接写到配置文件。  </div><div class="line">  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/84.png)</div><div class="line">  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png)</div><div class="line">  </div><div class="line">以上是第一种调用方式。缺点:1.url为固定写死的,上线时候部署多台服务器,有时候连部署到哪台服务器都不知道。2.对方可能启动了多个实例,如果写死到一台实现不了负载均衡,其他服务器就不能访问了。</div><div class="line"></div><div class="line">6. 6.RestTemplate第二种方式</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@RestController<br>@Slf4j<br>public class ClientController {</p>
<pre><code>@Autowired
private LoadBalancerClient loadBalancerClient;

@GetMapping(&quot;/getProductMsg&quot;)
public String getProductMsg(){

    //2.第二种方式:通过LoadBalancerClient获取服务名,ip和port
    /**
     * SpringCloud提供了LoadBalancerClient,将其注入到Spring中
     */
    RestTemplate restTemplate = new RestTemplate();
    ServiceInstance product = loadBalancerClient.choose(&quot;PRODUCT&quot;);
    String url = String.format(&quot;http://%s:%s&quot;, product.getHost(), product.getPort());
    String response = restTemplate.getForObject(url, String.class);
    log.info(&quot;response{}&quot;,response);
    return response;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">第二种方式每次都需要那么写(创建对象,获取ip,获取port,在调用获取),还是比较麻烦   </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png) </div><div class="line"></div><div class="line">7. 7.第三种方式</div></pre></td></tr></table></figure></p>
<p>@Component<br>public class RestTemplateConfig {<br>@Bean<br>@LoadBalanced<br>public RestTemplate restTemplate(){<br>    return new RestTemplate();<br>}<br>}</p>
<p>@RestController<br>@Slf4j<br>public class ClientController {<br>   @Autowired<br>   private RestTemplate restTemplate;</p>
<pre><code>@GetMapping(&quot;/getProductMsg&quot;)
public String getProductMsg(){
    //3.第三种方式:通过RestTemplate的配置加LoadBalancerClient注解
    String response = restTemplate.getForObject(&quot;http://PRODUCT/msg&quot;, String.class);
    log.info(&quot;response{}&quot;,response);
    return response;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/85.png) </div><div class="line"></div><div class="line"></div><div class="line">#### 3.负载均衡器Ribbion    </div><div class="line">1. 1.前面我们在说Eureka时候,谈到了服务端发现和客户端发现。Eureka属于客户端发现的方式,他的负载均衡是软负载,也就是客户端会向服务器(例如:EurekaServer)拉取已经注册的可用服务信息，然后根据负载均衡策略直接命中哪台服务器、发送请求。这整个过程都是在客户端完成的，并不需要服务端参数。SpringCloud中客户端负载均衡就是Ribbion  。他是基于NetflexRibbion实现的。通过SpringCloud的封装可以轻松的实现面向服务的restful模板请求自动转化成客户端负载均衡服务调用。</div><div class="line"></div><div class="line">一下组件都使用到了Ribbon:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/9.png) </div><div class="line"></div><div class="line">2. 2.SpringCloud在结合了Ribbon的负载均衡实现中,封装增加了HttpClient和OkHttp两种请求端实现,默认使用了Ribbon对Eureka服务发现的负载均衡client。</div><div class="line"></div><div class="line">3. 3.在上一节小结中,我们介绍了RestTemplate的三种实现方式。其中通过添加@LoadBalanced注解或者 直接写代码时候使用LoadBalancerClient,其实用到的就是Ribbon的组件</div><div class="line">4. 4.添加@LoadBalanced注解后,Ribbon会通过LoadBalancerClient自动的帮助你基于某种规则,比如:随机简单的轮训去连接目标服务,从而很容易使用Ribbon实现自定义的负载均衡算法。  </div><div class="line">5. 5.Ribbon实现负载均衡核心有3点:1.服务发现(也就是发现依赖服务的列表,也就是依据服务的名字,把该服务下的实例全都找出来)   2.服务选择规则(依据规则策略:如何从多个服务中选择一个有效的服务)  3.服务监听(监测失效服务做到高效剔除)  </div><div class="line">6. 6.主要组件是：ServerList、IRule、ServerListFilter。总体流程是:首先通过ServerList获取所有的可用服务列表。然后通过ServerListFilter过滤掉一部分地址，最后剩下的地址中通过IRule选择一个实例作为最终目标结果。</div><div class="line"></div><div class="line"></div><div class="line">#### 4 追踪源码自定义负载均衡策略</div><div class="line">略</div><div class="line">#### 5 Feign的使用</div><div class="line">##### 5.1 Feign的基本使用</div><div class="line">1. 1.本节使用Feign实现应用间通信。  </div><div class="line">2. 2.现在我们使用了Feign就不用使用restTemplate了,我们现在在ClientController中将restTemplate相关删除,并将RestTemplateConfig删除</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/10.png)</div><div class="line">3. 3.添加依赖:</div></pre></td></tr></table></figure></p>
<p><dependency><br>    <groupid>org.springframework.cloud</groupid><br>    <artifactid>spring-cloud-starter-feign</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/11.png)  </div><div class="line"></div><div class="line"></div><div class="line">4. 4.启动类中添加注解  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/12.png)  </div><div class="line">5. 5.定义好feign要调用的Server端接口  </div><div class="line">建立client包,定义一个ProductClient接口(里面的方法就是调用product服务的方法),此client代表order服务是一个相对于product的客户端服务。  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/13.png) </div><div class="line">product中ServerController里面调用的方法:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/14.png) </div><div class="line">6. 6.此接口定义完之后,在Controller里面定义,然后接口请求:http://localhost:8081/getProductMsg  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/15.png)  </div><div class="line"></div><div class="line">##### 5.2 Feign的总结  </div><div class="line">1. 声明式REST客户端(伪RPC)  </div><div class="line">2. 采用了基于接口的注解(定义一个接口,然后在其上加注解)  </div><div class="line">3. 内部使用了Ribbon作为负载均衡  </div><div class="line"></div><div class="line">#### 6 Feign获取商品列表  </div><div class="line">在Oder服务的OrderServiceImpl中的create里面1、2、3是我们还没有做的,这节我们需要通过Feign获取商品列表  </div><div class="line"></div><div class="line">##### 6.1 Product服务中添加获取商品列表  </div><div class="line"></div><div class="line">###### 1.Product--&gt;dao  </div><div class="line">  </div><div class="line">ProductInfoRepository:</div></pre></td></tr></table></figure></p>
<p>public interface ProductInfoRepository extends JpaRepository<productinfo,string>{<br> List<productinfo> findByProductStatus(Integer productStatus);<br> List<productinfo> findByProductIdIn(List<string> productIdList);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">###### 2.Product--&gt;service</div><div class="line">ProductService:</div></pre></td></tr></table></figure></string></productinfo></productinfo></productinfo,string></p>
<p>public interface ProductService {<br>    /**</p>
<pre><code> * 查询所有在架商品列表
 */
List&lt;ProductInfo&gt; findUpAll();
/**
 * 查询商品列表
 */
List&lt;ProductInfo&gt; findList(List&lt;String&gt; productIdList);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">ProductServiceImpl:</div></pre></td></tr></table></figure></p>
<p>@Service<br>public class ProductServiceImpl implements ProductService {<br>    @Autowired<br>    private ProductInfoRepository repository;<br>    @Override<br>    public List<productinfo> findUpAll() {<br>        return repository.findByProductStatus(ProductStatusEnum.UP.getCode());<br>    }<br>    @Override<br>    public List<productinfo> findList(List<string> productIdList) {<br>        return repository.findByProductIdIn(productIdList);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###### 3.Product--&gt;controller  </div><div class="line">ProductController:</div></pre></td></tr></table></figure></string></productinfo></productinfo></p>
<p>@RestController<br>@RequestMapping(“/product”)<br>public class ProductController {<br>    @Autowired<br>    private ProductService productService;<br>    @Autowired<br>    private ProductCategoryService productCategoryService;<br>    /**</p>
<pre><code> * 获取商品列表(给订单服务使用)
 * @param productIdList
 * @return
 */
@GetMapping(&quot;/listForOrder&quot;)
public List&lt;ProductInfo&gt; listForOrder(@RequestBody List&lt;String&gt; productIdList){
    return productService.findList(productIdList);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">##### 6.2 Order服务中调用商品列表  </div><div class="line">在client的ProductClient添加调用product的方法  </div><div class="line"></div><div class="line">###### 1.Order--&gt;ProductClient</div></pre></td></tr></table></figure></p>
<p>@FeignClient(name = “product”)<br>public interface ProductClient {<br>    @GetMapping(“/listForOrder”)<br>    List<productinfo> listForOrder(@RequestBody List<string> productIdList);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###### 2.Order--&gt;ClientController</div></pre></td></tr></table></figure></string></productinfo></p>
<p>@RestController<br>@Slf4j<br>public class ClientController {<br>    @Autowired<br>    private ProductClient productClient;<br>    @GetMapping(“/getProductMsg”)<br>    public String getProductMsg(){<br>        String msg = productClient.productMsg();<br>        log.info(“getProductMsg()”,msg);<br>        return msg;<br>    }<br>    @GetMapping(“/getProductList”)<br>    public String getProductList(){<br>        List<productinfo> productInfos = productClient.listForOrder(Arrays.asList(“157875196366160022”));<br>        return “ok”;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">###### 3.Order--&gt;请求测试</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/16.png)  </div><div class="line"></div><div class="line"></div><div class="line">#### 7.扣库存(Feign) </div><div class="line">我们已经获取了商品列表,现在开始在Product微服务实现扣库存    </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/05/17.png)  </div><div class="line">从创建订单接口我们知道,前端会传过来商品的信息和购买数量:我们在DTO中构造一个对象:CartDTO用来传送上面的对象  </div><div class="line"></div><div class="line">1. 1.Product--&gt;CartDTO对象  </div><div class="line">新建DTO包,新建CartDTO类:</div></pre></td></tr></table></figure></productinfo></p>
<p>public class CartDTO {<br>/**</p>
<ul>
<li>商品id<br><em>/<br>private String productId;<br>/*</em><ul>
<li>商品数量<br>*/<br>private Integer productQuantity;<br>public CartDTO(){<br>}<br>public CartDTO(String productId,Integer productQuantity){<br>this.productId = productId;<br>this.productQuantity = productQuantity;<br>}<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"></div><div class="line">2. 2.Product--&gt;Exception自定义异常</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>public class ProductException extends RuntimeException {<br>    private Integer code;<br>    public ProductException(Integer code,String message){<br>      super(message);<br>      this.code =code;<br>    }<br>    public ProductException(ResultEnum resultEnum){<br>           super(resultEnum.getMessage());<br>           this.code = resultEnum.getCode();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">3. 3.Product--&gt;返回枚举</div></pre></td></tr></table></figure></p>
<p>public enum ResultEnum {<br>    PRODUCT_NOT_EXIST(1,”商品不存在”),<br>    PRODUCT_STOCK_ERROE(2,”商品库存错误” );<br>    private Integer code;<br>    private String message;<br>    ResultEnum(Integer code, String message) {<br>        this.code = code;<br>        this.message = message;<br>    }<br>    public String getMessage() {<br>        return message;<br>    }<br>    public void setMessage(String message) {<br>        this.message = message;<br>    }<br>    public Integer getCode() {<br>        return code;<br>    }<br>    public void setCode(Integer code) {<br>        this.code = code;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. 4.Product--&gt;Service里面新建方法  </div><div class="line"></div><div class="line"></div><div class="line">```   </div><div class="line">@Override</div><div class="line">@Transactional(rollbackFor = Exception.class)</div><div class="line">public void decreaseStock(List&lt;CartDTO&gt; cartDTOList) &#123;</div><div class="line">/**</div><div class="line"> * 遍历:查看是否存在</div><div class="line"> */</div><div class="line">for (CartDTO cartDTO:cartDTOList)&#123;</div><div class="line">    Optional&lt;ProductInfo&gt; productInfoOptional = repository.findById(cartDTO.getProductId());</div><div class="line">    //商品不存在</div><div class="line">    if(!productInfoOptional.isPresent())&#123;</div><div class="line">     throw new ProductException(ResultEnum.PRODUCT_NOT_EXIST);</div><div class="line">    &#125;</div><div class="line">    //商品存在-库存错误</div><div class="line">    ProductInfo productInfo = productInfoOptional.get();</div><div class="line">    int result = productInfo.getProductStock() - cartDTO.getProductQuantity();</div><div class="line">    if(result&lt;0)&#123;</div><div class="line">        throw new ProductException(ResultEnum.PRODUCT_STOCK_ERROE);</div><div class="line">    &#125;</div><div class="line">    //保存</div><div class="line">    productInfo.setProductStock(result);</div><div class="line">    repository.save(productInfo);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>5.Product–&gt;controller</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@RequestMapping(&quot;/product&quot;)</div><div class="line">public class ProductController &#123;</div><div class="line">    @Autowired</div><div class="line">    private ProductService productService;</div><div class="line">    @PostMapping(&quot;/decreaseStock&quot;)</div><div class="line">    public void decreaseStock(@RequestBody List&lt;CartDTO&gt; cartDTOList)&#123;</div><div class="line">        productService.decreaseStock(cartDTOList);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>6.在Order服务中client里面的ProductClient添加:减库存方法  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@FeignClient(name = &quot;product&quot;)</div><div class="line">public interface ProductClient &#123;</div><div class="line">@GetMapping(&quot;/msg&quot;)</div><div class="line">String productMsg();</div><div class="line">@PostMapping(&quot;/product/decreaseStock&quot;)</div><div class="line">void decreaseStock(@RequestBody List&lt;CartDTO&gt; cartDTOList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>7.Order服务中:ClientController  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@Slf4j</div><div class="line">public class ClientController &#123;</div><div class="line">    @Autowired</div><div class="line">    private ProductClient productClient;</div><div class="line">    @GetMapping(&quot;/getProductMsg&quot;)</div><div class="line">    public String getProductMsg()&#123;</div><div class="line">        String msg = productClient.productMsg();</div><div class="line">        log.info(&quot;getProductMsg()&quot;,msg);</div><div class="line">        return msg;</div><div class="line">    &#125;</div><div class="line">    @GetMapping(&quot;/getProductList&quot;)</div><div class="line">    public String getProductList()&#123;</div><div class="line">        List&lt;ProductInfo&gt; productInfos = productClient.listForOrder(Arrays.asList(&quot;157875196366160022&quot;));</div><div class="line">        return productInfos.toString();</div><div class="line">    &#125;</div><div class="line">    @GetMapping(&quot;/productDecreaseStock&quot;)</div><div class="line">    public String productDecreaseStock()&#123;</div><div class="line">       productClient.decreaseStock(Arrays.asList(new CartDTO(&quot;157875196366160022&quot;,1)));</div><div class="line">       return &quot;ok&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>8.测试<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/19.png" alt=""><br>库存减少了<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/20.png" alt="">  </li>
</ol>
<h4 id="8-整合接口打通下单流程-Feign"><a href="#8-整合接口打通下单流程-Feign" class="headerlink" title="8.整合接口打通下单流程(Feign)"></a>8.整合接口打通下单流程(Feign)</h4><p>之前我们已经完善了,商品的查询,扣库存,那么我们这一节就要完成整套业务的打通。我们之前在Order服务中,创建订单时候,里面还有需要实现的如下几步:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/21.png" alt="">  </p>
<ol>
<li>1.现在我们补充完毕：  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line">public class OrderServiceImpl implements OrderService &#123;</div><div class="line">    @Autowired</div><div class="line">    private OrderMasterRepository orderMasterRepository;</div><div class="line">    @Autowired</div><div class="line">    private OrderDetailRepository orderDetailRepository;</div><div class="line">    @Autowired</div><div class="line">    private ProductClient productClient;</div><div class="line">    @Override</div><div class="line">    public OrderDTO create(OrderDTO orderDTO) &#123;</div><div class="line">        String orderId = KeyUtil.genUniqueKey();</div><div class="line">        //1.TODO 查询商品信息(调用商品服务)</div><div class="line">        List&lt;String&gt; productIdList = orderDTO.getOrderDetailList().stream().map(OrderDetail::getProductId).collect(Collectors.toList());</div><div class="line">        List&lt;ProductInfo&gt; productInfoList = productClient.listForOrder(productIdList);</div><div class="line">        //2.TODO 计算订单总价</div><div class="line">        //定义总价</div><div class="line">        BigDecimal orderAmout = new BigDecimal(BigInteger.ZERO);</div><div class="line">        for(OrderDetail orderDetail:orderDTO.getOrderDetailList())&#123;</div><div class="line">            //总价=(单价*数量)+总价</div><div class="line">            Integer productQuantity = orderDetail.getProductQuantity();</div><div class="line">            for(ProductInfo productInfo:productInfoList)&#123;</div><div class="line">                if(productInfo.getProductId().equals(orderDetail.getProductId()))&#123;</div><div class="line">                    orderAmout = productInfo.getProductPrice().multiply(new BigDecimal(productQuantity)).add(orderAmout);</div><div class="line">                   //订单详情赋值</div><div class="line">                    BeanUtils.copyProperties(productInfo,orderDetail);</div><div class="line">                    orderDetail.setOrderId(orderId);</div><div class="line">                    orderDetail.setDetailId(KeyUtil.genUniqueKey());</div><div class="line">                    //订单详情入库</div><div class="line">                    orderDetailRepository.save(orderDetail);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //3.TODO 扣除库存(调用商品服务)</div><div class="line">        List&lt;CartDTO&gt; cartDTOList = orderDTO.getOrderDetailList().stream()</div><div class="line">                .map(e -&gt; new CartDTO(e.getProductId(), e.getProductQuantity()))</div><div class="line">                .collect(Collectors.toList());</div><div class="line">        productClient.decreaseStock(cartDTOList);</div><div class="line">        //4. 订单入库</div><div class="line">        OrderMaster orderMaster = new OrderMaster();</div><div class="line">        //先设置主键 会copy到orderMaster</div><div class="line">        orderDTO.setOrderId(orderId);</div><div class="line">        BeanUtils.copyProperties(orderDTO,orderMaster);</div><div class="line">        orderMaster.setOrderAmount(orderAmout);</div><div class="line">        orderMaster.setOrderStatus(OrderStatusEnum.NEW.getCode());</div><div class="line">        orderMaster.setPayStatus(PayStatusEnum.WAIT.getCode());</div><div class="line">        orderMasterRepository.save(orderMaster);</div><div class="line">        return orderDTO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>2.测试<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/22.png" alt=""></li>
</ol>
<h4 id="9-项目改造成多模块"><a href="#9-项目改造成多模块" class="headerlink" title="9.项目改造成多模块"></a>9.项目改造成多模块</h4><p>多模块改造参考:<a href="https://blog.csdn.net/yangshangwei/article/details/88809468" target="_blank" rel="external">https://blog.csdn.net/yangshangwei/article/details/88809468</a>  </p>
<h5 id="9-1-项目缺陷"><a href="#9-1-项目缺陷" class="headerlink" title="9.1 项目缺陷"></a>9.1 项目缺陷</h5><p>虽然我们之前已经完成了下单并扣除库存，虽然通信是完成了,但是有些地方做的不好。有如下问题:<br>1.在Product微服务中,获取商品列表(给订单服务使用)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/23.png" alt=""><br>返回的ProductInfo是数据库实体:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/24.png" alt=""><br>基本上,我们不会把自己数据库映射的表对象暴露给外部的。<br>2.在订单服务和商品服务之间都有共有的对象:CartDTO,ProductInfo.重复定义。对象属于哪一个服务就在那一个服务中定义。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/25.png" alt=""><br>3.在Order(订单)服务里,定义了ProductClient接口使用Feign主键调用，我们在项目中可能一个服务就是很多人来做,各个服务费透明的,所以我们在Oder服务中不能把Product的服务代码请求路径等写到Order服务中.<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/26.png" alt=""> </p>
<h5 id="9-2-Product多模块拆分"><a href="#9-2-Product多模块拆分" class="headerlink" title="9.2 Product多模块拆分"></a>9.2 Product多模块拆分</h5><h6 id="9-2-1模块之间职责"><a href="#9-2-1模块之间职责" class="headerlink" title="9.2.1模块之间职责"></a>9.2.1模块之间职责</h6><p>针对解决以上情况,我们把项目分成3个模块:product-server、prodect-client、product-common  </p>
<ol>
<li>1.product-server:存放所有业务逻辑:包括,controller、service</li>
<li>2.prodect-client:对外暴露的接口,商品模块对外暴露的接口:商品列表和扣库存。  </li>
<li>3.product-common:公用的对象:既会被内部模块调用,也会被外部模块调用。<h6 id="9-2-2模块之间依赖关系"><a href="#9-2-2模块之间依赖关系" class="headerlink" title="9.2.2模块之间依赖关系"></a>9.2.2模块之间依赖关系</h6></li>
<li><p>1.product-common是公用的对象,所以product-server会依赖product-common,返回的商品对象prodect-client也会依赖product-common<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/27.png" alt=""> </p>
</li>
<li><p>2.product商品多模块划分可以参考:<a href="https://blog.csdn.net/qq_29479041/article/details/84230669" target="_blank" rel="external">https://blog.csdn.net/qq_29479041/article/details/84230669</a>  </p>
</li>
<li>3.在本地打包  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn -Dmaven.test.skip=true -U clean install</div></pre></td></tr></table></figure>
</li>
</ol>
<p>使用以上命令,会将对应模块打包并安装到本地maven仓库<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/28.png" alt="">  </p>
<h5 id="9-3-Order多模块拆分"><a href="#9-3-Order多模块拆分" class="headerlink" title="9.3 Order多模块拆分"></a>9.3 Order多模块拆分</h5><ol>
<li>1.以此类推,Order服务也分为3个模块,但是order-client目前是没有代码:其目前不需要给外提供服务  order-common目前也没有代码:目前没有需求  </li>
<li>2.在订单服务需要注意的是:订单服务调用商品服务,那么需要在订单服务里面的启动类中添加扫描到商品服务的路径:@EnableFeignClients(basePackages = “com.yxm.product.client”)</li>
<li>3.最外层pom文件引入product-client的jar包  </li>
<li>4.<dependencymanagement>是管理jar包版本,不会下载对应依赖</dependencymanagement></li>
</ol>
<h5 id="9-5-测试"><a href="#9-5-测试" class="headerlink" title="9.5 测试"></a>9.5 测试</h5><p>启动注册中心，通过product-server和order-server中的main函数启动俩微服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/29.png" alt="">  </p>
<p>下单<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/30.png" alt="">   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select * from order_master a where a.order_id = &apos;1558247336963513928&apos;</div><div class="line">select * from order_detail a  where a.order_id = &apos;1558247336963513928&apos;</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/31.png" alt="">   </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/32.png" alt="">  </p>
<p>源码:github地址:<a href="https://github.com/startshineye/SpringCloud_Shell/tree/develop_multimodulw">https://github.com/startshineye/SpringCloud_Shell/tree/develop_multimodulw</a>  </p>
<h4 id="10-同步或者异步"><a href="#10-同步或者异步" class="headerlink" title="10.同步或者异步"></a>10.同步或者异步</h4><ol>
<li>1.当前订单服务和商品服务,两个服务之间的通讯机制是同步的。订单会调用商品服务的扣库存接口。微服务中除了同步,有很多时候会集成到异步的场景下,通过队列和订阅主题,实现消息的 发布和订阅,一个微服务可以是消息的发布者,通过异步的方式发送到队列和订阅主题下,作为消费者的微服务,可以从队列或者主题中获取消息。通过消息中间件。把服务间的直接调用解耦。</li>
<li>比如以下图中:用户登录的时候,用户服务需要调用短信服务发短信。要给用户加积分,需要调用积分服务。还可能有其他服务，如果都采用同步的机制，服务间耦合过大,用户登录成功，需要向多个服务同步响应后才会成功，就会造成不好的用户体验。这个时候，我们通过消息队列可以实现很好的异步调用。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/33.png" alt="">  </li>
<li>3.再比如:订单服务在口库存前会调用查询商品服务,之后再调用减库存的接口来扣库存。我们对其改造:商品服务在更改库存的时候、发布库存变化的消息、订单服务来订阅这个消息、可以获取到商品的部分信息，比如:可购买的商品个数、商品id。订单服务在下单的时候不必同步的去查询数据确定商品的库存信息 而是查询自己服务中数据 然后在扣库存时候订单服务发布一个扣库存的消息、商品服务订阅这个消息。拿到消息后，减少本库存消息的库存量。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/34.png" alt=""> </li>
<li>4.消息中间件:目前常见的消息队列为:RabbitMQ、Kafka、ActiveMQ,我们现在使用RabbitMQ</li>
</ol>
<h4 id="11-RabbitMQ的安装"><a href="#11-RabbitMQ的安装" class="headerlink" title="11.RabbitMQ的安装"></a>11.RabbitMQ的安装</h4><p>进入下载网址:<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="external">https://www.rabbitmq.com/download.html</a><br>我们使用docker安装RabbitMQ<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/35.png" alt=""><br>我们使用带有管理界面的mq:3.8.0-beta.4-management<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/36.png" alt="">  </p>
<p><a href="https://blog.csdn.net/antma/article/details/81334932" target="_blank" rel="external">https://blog.csdn.net/antma/article/details/81334932</a><br><a href="https://www.jianshu.com/p/f3e49b495d74" target="_blank" rel="external">https://www.jianshu.com/p/f3e49b495d74</a>  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/14/SpringCloud-4-应用通信/" class="archive-article-date">
  	<time datetime="2019-04-13T16:57:11.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-3-服务拆分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SpringCloud-3-服务拆分/">SpringCloud-3-服务拆分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-微服务拆分的起点"><a href="#1-微服务拆分的起点" class="headerlink" title="1.微服务拆分的起点"></a>1.微服务拆分的起点</h4><h5 id="1-1如何拆分微服务"><a href="#1-1如何拆分微服务" class="headerlink" title="1.1如何拆分微服务?"></a>1.1如何拆分微服务?</h5><p>现在微服务概念炒得很热,关于如何拆分微服务,有以下几点。  </p>
<ol>
<li>1.先明白起点和终点<br>起点:既有架构的形态。<br>终点:好的架构不是设计出来的,而是进化而来的。  </li>
<li>典型架构  </li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/65.png" alt=""></p>
<h5 id="1-2-适合上微服务么"><a href="#1-2-适合上微服务么" class="headerlink" title="1.2 适合上微服务么?"></a>1.2 适合上微服务么?</h5><p>业务形态不适合的<br>1.系统中包含很多很多强事务场景的(因为微服务是分布式的,分布式强事务CAP最多也就能达到最终一致性)<br>2.业务相对稳定、迭代周期长<br>3.访问压力不大、可用性要求不高(中小型企业的OA)  </p>
<h4 id="2-康威定律和微服务"><a href="#2-康威定律和微服务" class="headerlink" title="2.康威定律和微服务"></a>2.康威定律和微服务</h4><h5 id="2-1-康威定律"><a href="#2-1-康威定律" class="headerlink" title="2.1 康威定律"></a>2.1 康威定律</h5><p>除了业务形态不适合的,其实还有其他条件,很可能导致不适合迁移到微服务中去,首先我们看一下微服务理论基础:康威定律。    </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/66.png" alt=""></p>
<p>一句话概括就是:沟通的问题会影响系统设计<br>所以微服务都是强调小团队开发,大的系统拆分成微服务时候,大的团队随机也会拆分成小的团队。 </p>
<h5 id="2-2-微服务和团队结构"><a href="#2-2-微服务和团队结构" class="headerlink" title="2.2 微服务和团队结构"></a>2.2 微服务和团队结构</h5><ol>
<li>微服务特点<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/67.png" alt=""></li>
<li>传统vs微服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/68.png" alt=""></li>
</ol>
<h4 id="3-点餐业务服务拆分分析"><a href="#3-点餐业务服务拆分分析" class="headerlink" title="3.点餐业务服务拆分分析"></a>3.点餐业务服务拆分分析</h4><p>点餐系统分为:买家端 和 卖家端  </p>
<h5 id="3-1-服务拆分"><a href="#3-1-服务拆分" class="headerlink" title="3.1 服务拆分"></a>3.1 服务拆分</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/69.png" alt=""><br>上面:服务两种方式拆分:<br>第一种(按照终端):买家端(手机端)的ui单独为一个服务放到nginx里面,卖家端(PC端)的ui单独为一个服务,两个服务同时向后端的通用服务请求数据<br>第二种(按照业务):将订单ui,商品ui,支付ui都放到一个边缘服务。</p>
<p>以上两种都不对,如果只是自己运营的的点餐应用:团队只有一个,并且业务变化也不大,没有微服务化的必要。如果是一个快速发展的IT公司点餐部门,业务快速发展，需求不断提出，所以需要拆分成微服务。</p>
<p>所以说:起点和团队结构,沟通方式都会决定微服务的设计。  </p>
<h5 id="3-2-服务拆分方法论"><a href="#3-2-服务拆分方法论" class="headerlink" title="3.2 服务拆分方法论"></a>3.2 服务拆分方法论</h5><p>下图出自&lt;&lt;可扩展的艺术&gt;&gt;书籍<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/70.png" alt=""></p>
<ol>
<li>X轴 水平复制:通过应用程序扩展,通过负载均衡运行多个父本一样的应用程序</li>
<li>Z轴 数据分区:将服务按数据分区、每个服务器负责一个数据子集、每个服务器运行的代码是一样的  </li>
<li>Y轴 功能解耦:不同职责模块分成不同服务</li>
</ol>
<p>通过以上模型,知道服务拆分的两个关键职责:功能和数据 </p>
<h6 id="3-2-1-如何拆”功能”"><a href="#3-2-1-如何拆”功能”" class="headerlink" title="3.2.1 如何拆”功能”"></a>3.2.1 如何拆”功能”</h6><ol>
<li>1.单一职责(每个服务负责业务功能的单独一部分)、松耦合(服务之间耦合度低,修改一个服务不用导致另一个服务修改)、高内聚(服务内部相关行为都聚集在一个服务内,而不是分散在不同服务中心)。</li>
<li>2.关注点分离:-按职责  -按通用性 -按粒度级别(微服务并不是越小越好,要合适)  </li>
</ol>
<h6 id="3-2-2-如何拆”数据”"><a href="#3-2-2-如何拆”数据”" class="headerlink" title="3.2.2 如何拆”数据”"></a>3.2.2 如何拆”数据”</h6><p>拆分功能和拆分数据是有先后顺序  </p>
<ol>
<li>1.先考虑业务功能、再考虑业务功能对应的数据  </li>
<li>2.无状态服务（状态:如果一个数据要被多个服务共享才能完成一个请求,那么这个数据就称为状态,进而依赖这个状态数据的服务称为有状态服务）<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/71.png" alt=""><br>如上所示把业务数据存放到有状态服务的数据库,缓存中实现前端微服务和后端微服务质检无状态服务,数据间没有太大耦合性。  </li>
</ol>
<p>如何拆数据:<br>1.每个微服务都有单独数据存储(微服务共有数据库,有可能其中一个数据库出现问题会影响其他微服务,一个服务要获取另一个服务的数据,不能直接连接库去请求,而是调用另一个服务接口去获取数据,服务之间有隔离)<br>2.依据服务特点选择不同结构的数据库类型(如果:数据基于搜索的,那么es合适,如果是非机构化数据,那么nosql的mongodb合适)<br>3.难点在确定边界  </p>
<h6 id="3-2-3-点餐业务服务拆分分析"><a href="#3-2-3-点餐业务服务拆分分析" class="headerlink" title="3.2.3 点餐业务服务拆分分析"></a>3.2.3 点餐业务服务拆分分析</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/72.png" alt=""><br>1.不要期望服务拆分一次就正确,微服务是不断演进的  </p>
<h4 id="4-商品服务"><a href="#4-商品服务" class="headerlink" title="4.商品服务"></a>4.商品服务</h4><h5 id="4-1-商品服务api和sql介绍"><a href="#4-1-商品服务api和sql介绍" class="headerlink" title="4.1 商品服务api和sql介绍"></a>4.1 商品服务api和sql介绍</h5><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /product/list</div></pre></td></tr></table></figure>
<p>参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">无</div></pre></td></tr></table></figure>
<p>返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;code&quot;: 0,</div><div class="line">    &quot;msg&quot;: &quot;成功&quot;,</div><div class="line">    &quot;data&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;热榜&quot;,</div><div class="line">            &quot;type&quot;: 1,</div><div class="line">            &quot;foods&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;id&quot;: &quot;123456&quot;,</div><div class="line">                    &quot;name&quot;: &quot;皮蛋粥&quot;,</div><div class="line">                    &quot;price&quot;: 1.2,</div><div class="line">                    &quot;description&quot;: &quot;好吃的皮蛋粥&quot;,</div><div class="line">                    &quot;icon&quot;: &quot;http://xxx.com&quot;,</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;好吃的&quot;,</div><div class="line">            &quot;type&quot;: 2,</div><div class="line">            &quot;foods&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;id&quot;: &quot;123457&quot;,</div><div class="line">                    &quot;name&quot;: &quot;慕斯蛋糕&quot;,</div><div class="line">                    &quot;price&quot;: 10.9,</div><div class="line">                    &quot;description&quot;: &quot;美味爽口&quot;,</div><div class="line">                    &quot;icon&quot;: &quot;http://xxx.com&quot;,</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">sql</div></pre></td></tr></table></figure>
<p>– 类目<br>CREATE TABLE <code>product_category</code> (<br>    <code>category_id</code> INT NOT NULL AUTO_INCREMENT,<br>    <code>category_name</code> VARCHAR(64) NOT NULL COMMENT ‘类目名字’,<br>    <code>category_type</code> INT NOT NULL COMMENT ‘类目编号’,<br>    <code>create_time</code> TIMESTAMP NOT NULL COMMENT ‘创建时间’,<br>    <code>update_time</code> TIMESTAMP NOT NULL COMMENT ‘修改时间’,<br>    PRIMARY KEY (<code>category_id</code>),<br>    UNIQUE KEY <code>uqe_category_type</code> (<code>category_type</code>)<br>);<br>– 商品<br>CREATE TABLE <code>product_info</code> (<br>    <code>product_id</code> VARCHAR(32) NOT NULL,<br>    <code>product_name</code> VARCHAR(64) NOT NULL COMMENT ‘商品名称’,<br>    <code>product_price</code> DECIMAL(8,2) NOT NULL COMMENT ‘单价’,<br>    <code>product_stock</code> INT NOT NULL COMMENT ‘库存’,<br>    <code>product_description</code> VARCHAR(64) COMMENT ‘描述’,<br>    <code>product_icon</code> VARCHAR(512) COMMENT ‘小图’,<br>    <code>product_status</code> TINYINT(3) DEFAULT ‘0’ COMMENT ‘商品状态,0正常1下架’,<br>    <code>category_type</code> INT NOT NULL COMMENT ‘类目编号’,<br>    <code>create_time</code> TIMESTAMP NOT NULL COMMENT ‘创建时间’,<br>    <code>update_time</code> TIMESTAMP NOT NULL COMMENT ‘修改时间’,<br>    PRIMARY KEY (<code>product_id</code>)<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 4.2 商品服务编码  </div><div class="line">###### 4.2.1 创建工程</div><div class="line">1. 创建一个Eureka客户端服务,并修改pom.xml文件 保持版本一致性。    </div><div class="line">2. 修改项目名称并注册到Eureka注册中心  </div><div class="line">3. 添加注解:@EnableDiscoveryClient</div><div class="line"></div><div class="line">###### 4.2.2 启动项目,查看Eureka Server是否有注册的服务  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/73.png)  </div><div class="line"> </div><div class="line">###### 4.2.3 书写业务</div><div class="line">1. 1.添加mysql驱动和jpa依赖</div><div class="line">2. application.yml中配置数据源  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/74.png)</div><div class="line"></div><div class="line"></div><div class="line">#### 5.订单服务 </div><div class="line">##### 5.1 业务逻辑分析    </div><div class="line">### 创建订单</div></pre></td></tr></table></figure></p>
<p>POST /order/create<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">参数</div></pre></td></tr></table></figure></p>
<p>name: “张三”<br>phone: “18868822111”<br>address: “总部”<br>openid: “ew3euwhd7sjw9diwkq” //用户的微信openid<br>items: [{<br>productId: “1423113435324”,<br>productQuantity: 2 //购买数量<br>}]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">返回</div></pre></td></tr></table></figure>
<p>{<br>  “code”: 0,<br>  “msg”: “成功”,<br>  “data”: {<br>      “orderId”: “147283992738221”<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">订单服务业务逻辑思路:  </div><div class="line">1.参数校验  </div><div class="line">2.查询商品信息(此时信息有可能不在订单系统中,可能在商品微服务中,则调用商品服务查询)  </div><div class="line">3.计算总价  </div><div class="line">4.扣库存(调用商品服务)   </div><div class="line">5.订单入库   </div><div class="line"></div><div class="line">##### 5.2 编码实践    </div><div class="line">###### 5.2.1 创建应用 注册到注册中心</div><div class="line">略(按照:client客户端创建)  </div><div class="line"></div><div class="line">###### 5.2.2 dao</div><div class="line">订单服务业务逻辑思路:  </div><div class="line">1.参数校验  </div><div class="line">2.查询商品信息(此时信息有可能不在订单系统中,可能在商品微服务中,则调用商品服务查询)  </div><div class="line">3.计算总价  </div><div class="line">4.扣库存(调用商品服务)   </div><div class="line">5.订单入库  </div><div class="line"></div><div class="line">###### 5.2.3 service  </div><div class="line">  </div><div class="line">1. 由于传递的参数包含:买家信息和订单信息,所以创建订单的service需要做一个数据转换 然后insert到对应买家和订单表里面,创建dto(Data Transfer Object)包,创建OrderDTO(买家和订单详情是一对多的关系,所以里面OrderDTO里是一个买家信息加许多商品信息)    </div><div class="line">2. OrderService里面创建订单的参数和返回为:OrderDTO  </div><div class="line">3. OrderServiceImpl里面实现创建订单:分为以下四步:1.查询商品 2.计算总价 3.扣除库存 4.订单入库。由于前3步都需要调用其他商品服务,所以我们写为:TODO  </div><div class="line">4. 创建OrderMaster时候,我们需要设置买家状态:orderStatus,payStatus我们用枚举实现如下:  </div><div class="line"></div><div class="line">   </div><div class="line">```  </div><div class="line">public enum OrderStatusEnum &#123;</div><div class="line">NEW(0, &quot;新订单&quot;),</div><div class="line">FINISHED(1, &quot;完结&quot;),</div><div class="line">CANCEL(2, &quot;取消&quot;),</div><div class="line">;</div><div class="line">private Integer code;</div><div class="line">private String message;</div><div class="line">OrderStatusEnum(Integer code, String message) &#123;</div><div class="line">    this.code = code;</div><div class="line">    this.message = message;</div><div class="line">&#125;</div><div class="line">public Integer getCode() &#123;</div><div class="line">    return code;</div><div class="line">&#125;</div><div class="line">public String getMessage() &#123;</div><div class="line">    return message;</div><div class="line">&#125;</div><div class="line">&#125;  </div><div class="line"></div><div class="line">public enum PayStatusEnum &#123;</div><div class="line">    WAIT(0, &quot;等待支付&quot;),</div><div class="line">    SUCCESS(1, &quot;支付成功&quot;),</div><div class="line">    ;</div><div class="line">    private Integer code;</div><div class="line"></div><div class="line">    private String message;</div><div class="line"></div><div class="line">    PayStatusEnum(Integer code, String message) &#123;</div><div class="line">        this.code = code;</div><div class="line">        this.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Integer getCode() &#123;</div><div class="line">        return code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getMessage() &#123;</div><div class="line">        return message;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```   </div><div class="line"></div><div class="line"></div><div class="line">5. OrderId是主键,我们用简单的KeyUtil生成工具生成</div></pre></td></tr></table></figure></p>
<p>public class KeyUtil {<br>    /**</p>
<pre><code> * 生成唯一的主键
 * 格式: 时间+随机数
 */
public static synchronized  String  genUniqueKey(){
    Random random = new Random();
    Integer number = random.nextInt(900000)+100000;
    return System.currentTimeMillis()+String.valueOf(number);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. service逻辑如下:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/82.png)</div><div class="line"></div><div class="line"></div><div class="line">###### 5.2.4 controller</div><div class="line">1. controller里面需要实现的业务逻辑大部分都是在service中,此处只是多了个参数校验，所以分为以下几步:1.参数校验 2.查询商品信息(调用商品服务) 3.计算总价 4.扣库存(调用商品服务) 5.订单入库  </div><div class="line">2.  涉及很多参数时候,我们封装前端参数,此处叫:OrderForm,并在里面添加了参数校验,不用在controller方法里面(使用@NotEmpty)校验。OrderForm此处省略getter,setter也可以用lombok加上@Data注解。</div></pre></td></tr></table></figure></p>
<p>public class OrderForm {<br>    /**</p>
<pre><code> * 买家姓名
 */
@NotEmpty(message = &quot;姓名必填&quot;)
private String name;

/**
 * 买家手机号
 */
@NotEmpty(message = &quot;手机号必填&quot;)
private String phone;

/**
 * 买家地址
 */
@NotEmpty(message = &quot;地址必填&quot;)
private String address;

/**
 * 买家微信openid
 */
@NotEmpty(message = &quot;openid必填&quot;)
private String openid;

/**
 * 购物车
 */
@NotEmpty(message = &quot;购物车不能为空&quot;)
private String items;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 在create方法中添加@Valid注解  </div><div class="line"></div><div class="line"></div><div class="line">4. 如果参数校验有错误时候抛出异常(自定义异常)OrderException(Integer code, String message)，其中code,message不使用硬编码,定义一个枚举:ResultEnum</div></pre></td></tr></table></figure>
<p>public class OrderException extends RuntimeException {<br>    private Integer code;<br>    public OrderException(Integer code, String message){<br>      super(message);<br>      this.code = code;<br>    }<br>    public OrderException(ResultEnum resultEnum) {<br>        super(resultEnum.getMessage());<br>        this.code = resultEnum.getCode();<br>    }<br>}</p>
<p>@Getter<br>public enum ResultEnum {<br>    PARAM_ERROR(1, “参数错误”),<br>    CART_EMPTY(2, “购物车为空”)<br>    ;</p>
<pre><code>private Integer code;

private String message;

ResultEnum(Integer code, String message) {
    this.code = code;
    this.message = message;
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">5. 在controller里面将校验过的参数：OrderForm转换成OrderDTO,此处转换封装成工具类处理(其中json转换成数据使用Gson)，转换失败时候抛出异常,打印日志      </div><div class="line"></div><div class="line">```  </div><div class="line">@Slf4j</div><div class="line">public class OrderForm2OrderDTOConverter &#123;</div><div class="line">    public static OrderDTO convert(OrderForm orderForm) &#123;</div><div class="line">        Gson gson = new Gson();</div><div class="line">        OrderDTO orderDTO = new OrderDTO();</div><div class="line">        orderDTO.setBuyerName(orderForm.getName());</div><div class="line">        orderDTO.setBuyerPhone(orderForm.getPhone());</div><div class="line">        orderDTO.setBuyerAddress(orderForm.getAddress());</div><div class="line">        orderDTO.setBuyerOpenid(orderForm.getOpenid());</div><div class="line"></div><div class="line">        List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();</div><div class="line">        try &#123;</div><div class="line">            orderDetailList = gson.fromJson(orderForm.getItems(),</div><div class="line">                    new TypeToken&lt;List&lt;OrderDetail&gt;&gt;() &#123;</div><div class="line">                    &#125;.getType());</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;【json转换】错误, string=&#123;&#125;&quot;, orderForm.getItems());</div><div class="line">            throw new OrderException(ResultEnum.PARAM_ERROR);</div><div class="line">        &#125;</div><div class="line">        orderDTO.setOrderDetailList(orderDetailList);</div><div class="line">        return orderDTO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>接口返回的结果data里面只有一个字段,所以不需要创建一个对象,一个封装一个map返回就行    </li>
</ol>
<pre><code>@RestController
@RequestMapping(&quot;/order&quot;)
@Slf4j
public class OrderController {

    @Autowired
    private OrderService orderService;

    /**
     * 1.参数校验
     * 2.查询商品信息(调用商品服务)
     * 3.计算总价
     * 4.扣库存(调用商品服务)
     * 5.订单入库
     */
    @PostMapping(&quot;/create&quot;)
    private Object create(@Valid OrderForm orderForm,
                          BindingResult bindingResult){
        //检验不通过抛出自定义异常
        if (bindingResult.hasErrors()){
            //https://www.cnblogs.com/weiapro/p/7633645.html
           log.error(&quot;【创建订单】参数不正确, orderForm={}&quot;, orderForm);
            throw new OrderException(ResultEnum.PARAM_ERROR.getCode(),
                    bindingResult.getFieldError().getDefaultMessage());
        }
        //orderForm-&gt;orderDTO
        OrderDTO orderDTO = OrderForm2OrderDTOConverter.convert(orderForm);
        if(CollectionUtils.isEmpty(orderDTO.getOrderDetailList())){
            log.error(&quot;【创建订单】购物车信息为空&quot;);
            throw new OrderException(ResultEnum.CART_EMPTY);
        }
        OrderDTO result = orderService.create(orderDTO);
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;orderId&quot;, result.getOrderId());
        return ResultVOUtil.success(map);
    }
}
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/83.png" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/13/SpringCloud-3-服务拆分/" class="archive-article-date">
  	<time datetime="2019-04-13T11:49:59.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-2-服务注册与发现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SpringCloud-2-服务注册与发现/">SpringCloud-2-服务注册与发现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-SpringCloud-Eureka"><a href="#1-SpringCloud-Eureka" class="headerlink" title="1.SpringCloud Eureka"></a>1.SpringCloud Eureka</h4><h5 id="1-1-简单微服务架构"><a href="#1-1-简单微服务架构" class="headerlink" title="1.1 简单微服务架构"></a>1.1 简单微服务架构</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/23.png" alt=""> </p>
<p>上图中的服务注册和发现在SpringCloud中用的就是:Eureka  </p>
<h5 id="1-2-简单介绍"><a href="#1-2-简单介绍" class="headerlink" title="1.2 简单介绍"></a>1.2 简单介绍</h5><ol>
<li>基于Netflix Eureka做了二次封装  </li>
<li>主要由两个组件组成: -Eureka Server(注册中心)  -Eureka Client(服务中心)  </li>
</ol>
<h4 id="2-Eureka-Server"><a href="#2-Eureka-Server" class="headerlink" title="2.Eureka Server"></a>2.Eureka Server</h4><h5 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h5><ol>
<li>注册中心好比老师手中名单 记录着所有同学名字  点名时候,根据手册名单</li>
<li>注册中心记录着所有应用的信息和状态(应用名,所在服务器,是否正常工作),在微服务架构中,我们把应用叫做服务 </li>
<li>由图所知:服务中心就是找到服务<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/24.png" alt="">  <h5 id="2-2-创建Eureka-Server应用"><a href="#2-2-创建Eureka-Server应用" class="headerlink" title="2.2 创建Eureka Server应用"></a>2.2 创建Eureka Server应用</h5><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/25.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/26.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/27.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/28.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/29.png" alt="">   </li>
</ol>
<p>项目创建后我们不着急启动,先看下pom.xml文件:<br>SpringBoot的版本和SpringCloud版本如下所示:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/30.png" alt=""><br>我们如何知道SpringBoot版本和SpringCloud的版本匹配呢?我们进入SpringCloud官网:<a href="https://spring.io/" target="_blank" rel="external">https://spring.io/</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/31.png" alt=""><br>将pom.xml中设置成统一匹配的:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/32.png" alt=""> </p>
<p>关于版本的具体问题,请参考：<a href="https://blog.csdn.net/sinat_33889619/article/details/89403796" target="_blank" rel="external">https://blog.csdn.net/sinat_33889619/article/details/89403796</a></p>
<h5 id="2-3-启动Eureka-Server"><a href="#2-3-启动Eureka-Server" class="headerlink" title="2.3 启动Eureka Server"></a>2.3 启动Eureka Server</h5><p>1.启动时候报错:没有出现注册中心界面<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/33.png" alt="">  </p>
<p>2.添加@EnableEurekaServer注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableEurekaServer</div><div class="line">public class EurekaApplication &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">	SpringApplication.run(EurekaApplication.class, args);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重启发现出现注册中心的界面:  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/34.png" alt="">  </p>
<p>3.启动时候虽然可以访问,但是出现了下面的错误:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</div></pre></td></tr></table></figure>
<p>这是因为此应用不仅是一个server端同时也是一个client端。他也需要找到一个注册中心,把自己注册上去。我们配置一下他注册的地址:就是往自己身上注册。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/35.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/36.png" alt="">  </p>
<p>点击service-url进入:EurekaClientConfigBean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void setServiceUrl(Map&lt;String, String&gt; serviceUrl) &#123;</div><div class="line"> this.serviceUrl = serviceUrl;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line">serviceUrl是一个map的key为:defaultZone</div></pre></td></tr></table></figure>
<p>eureka:<br>client:<br>service-url:<br>defaultZone: <a href="http://localhost:8080/eureka/" target="_blank" rel="external">http://localhost:8080/eureka/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">重启项目时候:注册时候是心跳检测注册,刚开始会有错误,等一会就可以了,如下已经注册上:  </div><div class="line">  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/37.png)  </div><div class="line"></div><div class="line">由于注册的Application的名字为:UNKNOWN  我们修改此应用的名字,添加如下配置:</div></pre></td></tr></table></figure></p>
<p>spring:<br> application:<br>  name: eureka<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/38.png)   </div><div class="line"></div><div class="line">4.由于此应用本来就是一个注册中心,自己注册到自己不出现在注册实例中:添加如下配置:register-with-eureka: false</div></pre></td></tr></table></figure></p>
<p>eureka:<br> client:<br>  service-url:<br>    defaultZone: <a href="http://localhost:8080/eureka/" target="_blank" rel="external">http://localhost:8080/eureka/</a><br>   register-with-eureka: false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/39.png)   </div><div class="line"></div><div class="line">5.由于我们后面很多应用都是8080端口,所以我们修改注册中心的地址为默认端口:8761</div></pre></td></tr></table></figure></p>
<p>eureka:<br>  client:<br>    service-url:<br>      defaultZone: <a href="http://localhost:8761/eureka/" target="_blank" rel="external">http://localhost:8761/eureka/</a><br>    register-with-eureka: false<br>spring:<br>  application:<br>    name: eureka<br>  server:<br>    port: 8761<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 3.Eureka Client(服务注册)    </div><div class="line">##### 3.1 启用注册中心    </div><div class="line">注册中心为了方便不需要每次在idea中启动,我们应该打成jar包,然后通过命令在后台启用。进入eureka的根目录,执行:</div></pre></td></tr></table></figure></p>
<p>mvn clean package<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">生成后端启动：</div></pre></td></tr></table></figure></p>
<p>nohup java -jar eureka-0.0.1-SNAPSHOT.jar &amp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">##### 3.2 创建Eureka Client应用  </div><div class="line">  </div><div class="line">1. 创建应用</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/25.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/40.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/41.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/42.png)  </div><div class="line"></div><div class="line">删除不需要的文件:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/43.png)  </div><div class="line"></div><div class="line">client端和server端的版本保持一致:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/44.png) </div><div class="line"></div><div class="line">2. 添加注册中心地址:</div></pre></td></tr></table></figure></p>
<p>eureka:<br>  client:<br>    service-url:<br>      defaultZone: <a href="http://localhost:8761/eureka/" target="_blank" rel="external">http://localhost:8761/eureka/</a><br>spring:<br>  application:<br>    name: client<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">3. 开启服务注册  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/45.png) </div><div class="line"></div><div class="line"></div><div class="line">有时候启动报错:</div></pre></td></tr></table></figure></p>
<p>Invocation of destroy method failed on bean with name ‘scopedTarget.eurekaClient’: org.springframework.beans.factory.BeanCreationNotAllowedException: Error creating bean with name ‘eurekaInstanceConfigBean’: Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">解决:添加web依赖</div></pre></td></tr></table></figure></p>
<p><dependency><br>    <groupid>org.springframework.boot</groupid><br>    <artifactid>spring-boot-starter-web</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">4. 查看是否已经注册  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/46.png) </div><div class="line"></div><div class="line"></div><div class="line">5. 如果不停的启动client端,会在注册中心出现:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/47.png) </div><div class="line">client&lt;---&gt;server端是采用心跳的机制,server端会不听的检查client端是否存活上线,在一定时间会统计出client端的上线率,当低于某个比例时候 会报出以上警告,在开发环境我们可以把它关掉(在server端里面配置文件加上:)</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/48.png)  </div><div class="line"></div><div class="line">#### 4.Eureka高可用  </div><div class="line">##### 4.1 Eureka单节点 </div><div class="line">1. 上面的Eureka是单点的,如果挂了的话 所以client端服务都不可以运行了  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/49.png) </div><div class="line">##### 4.2 Eureka多节点之间互相注册,但是client注册到其中一个Eureka    </div><div class="line">1. 让Eureka Server开启两个,之间互相注册,虽然client只在server1上注册,但是会把client注册也会拷贝到server2注册  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/50.png)  </div><div class="line">2. 开启两个Eureka Server端口分别为:8761、8762   </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/51.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/52.png)  </div><div class="line">以端口来区分:Eureka1:8761   Eureka2:8762</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/53.png)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/04/54.png)  </div><div class="line">注释掉yml中原来端口:</div></pre></td></tr></table></figure></p>
<p>//server:<br>//port: 8761<br>```</p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/55.png" alt=""><br>启动  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/56.png" alt=""><br>启动</p>
<p>访问:<a href="http://localhost:8762" target="_blank" rel="external">http://localhost:8762</a>  我们可以看到之前注册到8761的服务也注册到8762上了,这是因为:8761和8762之间互相注册了。互相注册后,他们之上的信息有所交换。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/57.png" alt=""> </p>
<h5 id="4-3-Eureka1挂了-重启Eureka2和client"><a href="#4-3-Eureka1挂了-重启Eureka2和client" class="headerlink" title="4.3 Eureka1挂了 重启Eureka2和client"></a>4.3 Eureka1挂了 重启Eureka2和client</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/58.png" alt=""> </p>
<p>此时我们重启client和Eureka2时候,我们发现在Eureka2上没有发现client,这个时候我们就需要把client注册到Eureka1和Eureka2上才行。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/59.png" alt="">   </p>
<h5 id="4-4-Eureka包含3个以上"><a href="#4-4-Eureka包含3个以上" class="headerlink" title="4.4 Eureka包含3个以上"></a>4.4 Eureka包含3个以上</h5><p>有时候我们服务比较多,并且需要的注册中心也比较多,也就是Eureka Server比较多,我们该怎么做呢?<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/60.png" alt="">  </p>
<h4 id="5-Eureka总结"><a href="#5-Eureka总结" class="headerlink" title="5.Eureka总结"></a>5.Eureka总结</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/61.png" alt=""> </p>
<h4 id="6-分布式下服务注册的地位和原理"><a href="#6-分布式下服务注册的地位和原理" class="headerlink" title="6.分布式下服务注册的地位和原理"></a>6.分布式下服务注册的地位和原理</h4><h5 id="6-1-传统服务发现"><a href="#6-1-传统服务发现" class="headerlink" title="6.1 传统服务发现"></a>6.1 传统服务发现</h5><p>传统服务A要找到服务B,是通过在服务A中配置B的地址从而找到B,在分布式系统中,各个系统之间是不共享内存的，如下A服务如果要找到B服务就需要,并且B服务是分布式集群的,B中的服务器是不确定多少台,在云服务时代,服务器根据压力容量可能会动态改变,此时如果还是在A里面配置多个B节点注册中心地址不可取。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/62.png" alt=""></p>
<h5 id="6-2-注册中心服务发现"><a href="#6-2-注册中心服务发现" class="headerlink" title="6.2 注册中心服务发现"></a>6.2 注册中心服务发现</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/63.png" alt="">  </p>
<ol>
<li>类似于注册中心就是个代理,需要找谁就找谁</li>
<li><p>通过以上可以知道注册中心 是分布式服务中最重要的基础部分。  </p>
</li>
<li><p>A是如何通过”注册中心”找导服务B的呢?<br>客户端发起:A通过注册中心可以找到需要B,从中只需要找到一个B(通过轮训、hash等负载均衡机制等方式)<br>服务端发现:通过代理的方式<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/04/64.png" alt="">  </p>
</li>
</ol>
<h5 id="6-3-思考"><a href="#6-3-思考" class="headerlink" title="6.3 思考"></a>6.3 思考</h5><ol>
<li>SpringCloud是提供java应用程序之间的服务注册,那么如果有些服务是c/php/node.js写的服务,该怎样取进行服务发现和注册了，SpringCloud的Eureka使用客户端发现方式进行服务发现,SpringCloud是一个强大的我服务体系,但是是纯java的，山本大叔倡导轻量级的方式去实现微服务,所以采用了Http Restful API的方式,并且提供了Restful API接口让其他不同语言的服务区实现接口,达到服务注册。   </li>
<li>微服务具有异构特点:各个服务间可以用不同语言,每个服务可以根据需要选择不通的数据库  </li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/13/SpringCloud-2-服务注册与发现/" class="archive-article-date">
  	<time datetime="2019-04-13T02:46:38.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-1-微服务介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SpringCloud-1-微服务介绍/">SpringClond-1-微服务介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><ol>
<li>如今微服务已经是一个趋势,越来越多的人倾向于使用SpringCloud搭建微服务,SpringCloud已经成为了主流趋势。  </li>
<li>要学习微服务的话,需要掌握如下学习曲线:学习微服务,首先需要学习SpringCloud,学习SpringCloud需要学习SpringBoot。微服务–&gt;SpringCloud–&gt;SpringBoot   </li>
</ol>
<h4 id="2-SpringCloud微服务架构实践"><a href="#2-SpringCloud微服务架构实践" class="headerlink" title="2.SpringCloud微服务架构实践"></a>2.SpringCloud微服务架构实践</h4><h5 id="2-1-微服务相关技术简介"><a href="#2-1-微服务相关技术简介" class="headerlink" title="2.1 微服务相关技术简介"></a>2.1 微服务相关技术简介</h5><p>究竟微服务、SpringCloud、SpringBoot之间有什么联系？并且:SpringFramework、SpringBoot、SpringCloud之间又有什么关系呢?我们看如下分析:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/1.png" alt="">  </p>
<ol>
<li>1.Spring框架作为j2ee的基石，一直在快速发展、是搭建j2ee的框架主要组成部分。  </li>
<li>2.SpringBoot在Spring的上层、基于Spring框架构建的一种延伸的简化框架。能够快速构建Spring应用。</li>
<li>3.SpringCloud又是在SpringBoot的上层，利用SpringBoot构建分布式应用。</li>
</ol>
<h5 id="2-2-技术储备"><a href="#2-2-技术储备" class="headerlink" title="2.2 技术储备"></a>2.2 技术储备</h5><ol>
<li>1.对SpringBoot的基础知识熟练掌握。  </li>
<li>2.对Linux和Docker的基本用法熟练掌握  </li>
</ol>
<h5 id="2-3-重点"><a href="#2-3-重点" class="headerlink" title="2.3 重点"></a>2.3 重点</h5><ol>
<li>1.SpringCloud构建微服务(我们以点餐项目为例构建基本的SpringCloud微服务)  </li>
<li>2.微服务改造探讨(大多数微服务并不是一开始就设计好的,而是业务发展到一定规模时候产生的,我们会介绍将传统服务改造成微服务)  </li>
<li>3.本文课程使用SpringBoot2.x，课程讲解内容如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/2.png" alt=""><br>主要讲解上面部分外,我们还会讲解:容器编排和服务追踪。<br>1.容器编排方面使用:docker+rancher组合。<br>2.服务追踪方面使用:SpringCloudSleuth+ZIPKIN组合。   </li>
</ol>
<h5 id="2-4-环境参数"><a href="#2-4-环境参数" class="headerlink" title="2.4 环境参数"></a>2.4 环境参数</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/3.png" alt="">  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/13/SpringCloud-1-微服务介绍/" class="archive-article-date">
  	<time datetime="2019-04-13T02:45:42.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/ElasticStack/" style="font-size: 10px;">ElasticStack</a> <a href="/tags/SpringCloud/" style="font-size: 20px;">SpringCloud</a> <a href="/tags/acdgate/" style="font-size: 10px;">acdgate</a> <a href="/tags/ipcc/" style="font-size: 10px;">ipcc</a> <a href="/tags/problem/" style="font-size: 10px;">problem</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>