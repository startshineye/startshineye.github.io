<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/page/2/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/07/常见问题/">常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-hexo编译错误"><a href="#1-hexo编译错误" class="headerlink" title="1. hexo编译错误"></a>1. hexo编译错误</h3><p>之前hexo博客使用{{没问题,但是重装机器系统之后,再次执行”hexo g”时候报如下错误:<br>问题及解决方案参考如下:<br><a href="https://github.com/hexojs/hexo/issues/2384">https://github.com/hexojs/hexo/issues/2384</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/12/07/常见问题/" class="archive-article-date">
  	<time datetime="2019-12-07T09:21:20.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-12-07</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem/">problem</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ipcc-3-日常运维" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/28/ipcc-3-日常运维/">ipcc-3-日常运维</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1.中间跳过的名单拨打处理<br>2.统计批次进度问题<br>3.重呼数据未拨打问题(重启后拨打)<br>4.查看某个租户是否配置了重呼轮呼策略<br>5.批次数据号码处理(加前缀去掉前缀) </p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="1-中间跳过的名单拨打处理"><a href="#1-中间跳过的名单拨打处理" class="headerlink" title="1.中间跳过的名单拨打处理"></a>1.中间跳过的名单拨打处理</h3><p>先查看未拨打批次:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT DISTINCT(ocm_buslist.event_id) FROM ocm_buslist ocm_buslist</div><div class="line">  LEFT JOIN cti_cdr cdr ON ocm_buslist.list_id = cdr.memberid LEFT JOIN ocm_event e ON e.event_id = ocm_buslist.event_id</div><div class="line">WHERE e.event_state IN(0,1,2) AND ocm_buslist.create_time&lt;&apos;2019-12-22 23:59:59&apos; AND cdr.id IS NULL ORDER BY ocm_buslist.list_id DESC</div></pre></td></tr></table></figure>
<h4 id="1-1-数据量小时候处理"><a href="#1-1-数据量小时候处理" class="headerlink" title="1.1 数据量小时候处理"></a>1.1 数据量小时候处理</h4><p>1.查询出未拨打的数据保存成.sql文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT ocm_buslist.* FROM ocm_buslist ocm_buslist</div><div class="line">  LEFT JOIN cti_cdr cdr ON ocm_buslist.list_id = cdr.memberid</div><div class="line">WHERE ocm_buslist.event_id = xxx  AND  cdr.id IS NULL ORDER BY ocm_buslist.list_id DESC</div></pre></td></tr></table></figure>
<p>2.查询批次(比较max_member_id和查询的list_id大小)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT event_name,max_member_id FROM ocm_event WHERE event_id = xxx;</div></pre></td></tr></table></figure>
<p>2.然后执行插入  </p>
<p>3.最后删除之前list_id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE FROM ocm_buslist WHERE event_id = xxx AND list_id IN(xxx1,xxx2);</div></pre></td></tr></table></figure></p>
<p>4.查询导入之后数据大小  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select count(*)  from ocm_buslist where list_id &gt; max_memberid</div></pre></td></tr></table></figure>
<h4 id="1-2-数据量大时候处理"><a href="#1-2-数据量大时候处理" class="headerlink" title="1.2 数据量大时候处理"></a>1.2 数据量大时候处理</h4><p>批次是按照大于ocm_event表中的max_member_id对比进行拨打,在名单表中小于max_member_id将不会拨打。如果出现跳过拨打的数据,我们需要按照如下步骤处理:注意:首先先要查看对应的名单是否已经拨打但是没有插入扫cti_cdr表,防止重复导入拨打。[<br>操作:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep 5314900 callnotify_callnotifysql01_1574*;</div></pre></td></tr></table></figure>
<p>]</p>
<ol>
<li>1.未拨打数据采集:[查询未拨打客户名单-&gt;将其导入到名单模板中重新导入]  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT ob.customer_name,ob.customer_phone,ob.car_no,ob.cust_id FROM ocm_buslist ob</div><div class="line">  LEFT JOIN cti_cdr cdr ON ob.list_id = cdr.memberid</div><div class="line">WHERE ob.event_id = xxx  AND  cdr.id IS NULL ORDER BY ob.list_id DESC</div></pre></td></tr></table></figure>
<ol>
<li>2.ocm_base_shbo处理:[删除未拨打的数据,删除之前先查询]<br>a.查询未拨打的数据:  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SELECT sb.* FROM ocm_base_shbo sb WHERE sb.event_id = xxx AND sb.cust_id IN (SELECT DISTINCT ob.cust_id FROM ocm_buslist ob</div><div class="line">  LEFT JOIN cti_cdr cdr ON ob.list_id = cdr.memberid</div><div class="line">WHERE ob.event_id = xxx  AND  cdr.id IS NULL);</div><div class="line">```  </div><div class="line"></div><div class="line">b.删除未拨打数据:</div></pre></td></tr></table></figure>
<p>DELETE FROM ocm_base_shbo  WHERE event_id = xxx AND cust_id IN (SELECT  ob.cust_id FROM ocm_buslist ob<br>  LEFT JOIN cti_cdr cdr ON ob.list_id = cdr.memberid<br>WHERE ob.event_id = xxx  AND  cdr.id IS NULL);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 3.ocm_buslist处理:[删除未拨打的数据,删除之前先查询]  </div><div class="line">a.查询未拨打数据</div></pre></td></tr></table></figure></p>
<p>select * FROM ocm_buslist WHERE event_id = xxx AND list_id NOT IN (SELECT DISTINCT memberid FROM cti_cdr WHERE notifyid = xxx);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">b.删除未拨打数据</div></pre></td></tr></table></figure></p>
<p>DELETE FROM ocm_buslist WHERE event_id = xxx AND list_id NOT IN (SELECT DISTINCT memberid FROM cti_cdr WHERE notifyid = xxx);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. 4.最后导入数据，修改批次统计:</div></pre></td></tr></table></figure></p>
<p>select * from ocm_event_statistics where event_id = xxx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">### 2.统计批次进度问题  </div><div class="line">批次进度统计主要是表:ocm_event_statistics,其中进度主要由3部分指标组成:  </div><div class="line">called_number(已拨打数量：从ocm_buslist中distinct cust_id)、filter_number(过滤掉的数量:从ocm_base_shbo表中count下:valid_flag=0的数据)、list_number(名单总数量:ocm_base_shbo中count(*))；如果ocm_buslist_timing表中含有数据的话即使ocm_buslist中数据拨打完了，也会是99%    </div><div class="line">   </div><div class="line">1. 查询批次整体进度情况</div></pre></td></tr></table></figure></p>
<p>SELECT * FROM ocm_event_statistics WHERE event_id = xxx;  //xxx批次id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1. 查看是否还有重呼数据</div></pre></td></tr></table></figure></p>
<p>SELECT * FROM ocm_buslist_timing WHERE event_id = xxx;  //xxx批次id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1. 查询导入到ocm_buslist中名单数量</div></pre></td></tr></table></figure></p>
<p>SELECT COUNT(DISTINCT cust_id) FROM ocm_buslist WHERE event_id = xxx;  //xxx批次id</p>
<p>SELECT COUNT(*) FROM ocm_base_shbo WHERE event_id = xxx AND valid_flag &gt;= 1; //xxx批次id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">1. 查询批次下总共数量:list_number</div></pre></td></tr></table></figure></p>
<p>SELECT COUNT(*) FROM ocm_base_shbo WHERE event_id = xxx;  //xxx批次id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1. 查看过滤掉的数据filter_number</div></pre></td></tr></table></figure></p>
<p>SELECT COUNT(*) FROM ocm_base_shbo WHERE event_id = xxx AND valid_flag = 0;  //xxx批次id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 3.重呼数据未拨打问题(重启后拨打)  </div><div class="line">有时候,我们的重呼数据一直可能存在于:ocm_buslist_timing表中而不会拨打,所以我们需要处理这些批次,重新启用停用(对于在执行时间段内的批次)。  </div><div class="line"></div><div class="line">1. 1.查看在当前时间前未重呼的批次</div></pre></td></tr></table></figure></p>
<p>SELECT event_id,event_state,event_name,send_time,over_time FROM ocm_event WHERE event_id IN (SELECT DISTINCT event_id FROM ocm_buslist_timing WHERE call_next_time<xxx); <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 4.查看某个租户是否配置了重呼轮呼策略</div></pre></td></tr></table></xxx);></p>
<p>SELECT enti.id,enti.entname,enti.state,oc.id,oc.parameter FROM cti_entinfo enti LEFT JOIN ocm_after_call_action oc ON enti.id = oc.entid<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 5.批次数据号码处理(加前缀去掉前缀)  </div><div class="line"></div><div class="line">1. 1.参考</div><div class="line">参考:https://blog.csdn.net/xiaosongbk/article/details/77199007</div><div class="line">update forumdata_userttt set userLink=right(userLink,length(userLink)-2) where id &gt;= 137;   </div><div class="line"></div><div class="line"></div><div class="line">2. 2.去除批次号码的前缀（前两位）</div></pre></td></tr></table></figure></p>
<p>UPDATE ocm_buslist SET customer_phone=RIGHT(customer_phone,LENGTH(customer_phone)-2) WHERE event_id = 1658 AND list_id&gt;6253939;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">3. 3.去除重呼表中93开头的号码前两位</div></pre></td></tr></table></figure></p>
<p>UPDATE ocm_buslist_timing SET customer_phone RIGHT(customer_phone,LENGTH(customer_phone)-2) WHERE customer_phone LIKE ‘93%’;<br>```</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/11/28/ipcc-3-日常运维/" class="archive-article-date">
  	<time datetime="2019-11-28T09:49:36.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-11-28</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ipcc/">ipcc</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-acdgate-1-websocket404" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/14/acdgate-1-websocket404/">acdgate-1-websocket404</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>将AcdGate发布到阿里云服务器之后,登录坐席一直报websocket连接不上的404，如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/68.png" alt=""></p>
<p>查看原因是:tomcat下webapps打包后的AcdGate里面WEB-INF里面的lib下面含有:websocket-api.jar包,并且在部署的Tomcat下的lib里面也有:websocket-api.jar包,导致冲突,解决办法删除其中一个里面的websocket-api.jar即可</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/09/14/acdgate-1-websocket404/" class="archive-article-date">
  	<time datetime="2019-09-14T05:49:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-09-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acdgate/">acdgate</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-work-11-nginx安装配置https" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/31/work-11-nginx安装配置https/">work-11-nginx安装配置https</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考1:<a href="https://www.cnblogs.com/wanghuaijun/p/5480554.html" target="_blank" rel="external">https://www.cnblogs.com/wanghuaijun/p/5480554.html</a><br>参考2:<a href="https://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="external">https://www.runoob.com/linux/nginx-install-setup.html</a>  </p>
<h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><p>软件需求:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/63.png" alt=""><br>下载地址:<br>链接：<a href="https://pan.baidu.com/s/1OTFCGaTXOEQ54cnMtv8JJw" target="_blank" rel="external">https://pan.baidu.com/s/1OTFCGaTXOEQ54cnMtv8JJw</a><br>提取码：z3h5 </p>
<h4 id="1-创建nginx用户"><a href="#1-创建nginx用户" class="headerlink" title="1.创建nginx用户"></a>1.创建nginx用户</h4><ol>
<li>1.groupadd -r nginx</li>
<li>2.useradd -r -g nginx -M nginx  </li>
</ol>
<h4 id="2-解压缩nginx的源码并安装"><a href="#2-解压缩nginx的源码并安装" class="headerlink" title="2.解压缩nginx的源码并安装"></a>2.解压缩nginx的源码并安装</h4><ol>
<li>1.nginx-1.10.2.tar.gz、pcre-8.33.tar.gz、zlib-1.2.8.tar.gz上传文件到tools目录  </li>
<li>2.解压:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/64.png" alt="">    </li>
<li><p>3.cd nginx-1.10.2 执行:configure  </p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./configure --user=nginx --group=nginx --prefix=/founder/tools/nginx --with-http_stub_status_module --with-http_ssl_module</div><div class="line">--with-http_realip_module --with-http_addition_module --with-pcre=/founder/tools/pcre-8.33 --with-zlib=/founder/tools/zlib-1.2.8</div></pre></td></tr></table></figure>
</li>
<li><p>4.编译  make &amp;&amp; make install<br>如果出现以下错误按照要求修改即可:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/01.png" alt="">   </p>
</li>
<li><p>5.查看nginx版本<br>进入前面configure中配置的prefix下,执行如下命令: </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./nginx/sbin/nginx -v</div></pre></td></tr></table></figure>
</li>
<li><p>6.启动nginx  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./nginx/sbin/nginx</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-配置https"><a href="#2-配置https" class="headerlink" title="2.配置https"></a>2.配置https</h3><h4 id="2-1-配置前需要准备"><a href="#2-1-配置前需要准备" class="headerlink" title="2.1 配置前需要准备"></a>2.1 配置前需要准备</h4><ol>
<li>1.配置前需要准备：域名、私钥文件、key文件、密码文件。如下图:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/03.png" alt="">  </li>
</ol>
<h5 id="2-2-开始配置"><a href="#2-2-开始配置" class="headerlink" title="2.2 开始配置"></a>2.2 开始配置</h5><ol>
<li>1.安装证书<br>将证书置于服务器中，一般放于<code>/nginx/sslcrt</code>下。  </li>
<li><p>2.修改配置文件<br>早期的配置文件是<code>/opt/nginx/conf/nginx.conf</code>，较新的项目是<code>/opt/nginx/conf.d/*.conf</code><br>找到需要添加https的服务所在的位置。进行如下配置：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/04.png" alt=""></p>
</li>
<li><p>3.重载nginx配置文件<br>/nginx/sbin/nginx -s reload</p>
</li>
</ol>
<h3 id="3-nginx常见错误"><a href="#3-nginx常见错误" class="headerlink" title="3.nginx常见错误"></a>3.nginx常见错误</h3><ol>
<li>1.解决nginx: [error] open() ＂/usr/local/nginx/logs/nginx.pid＂ failed错误<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/02.png" alt="">  </li>
</ol>
<h3 id="4-nginx其他命令"><a href="#4-nginx其他命令" class="headerlink" title="4.nginx其他命令"></a>4.nginx其他命令</h3><p>以下包含了 Nginx 常用的几个命令：</p>
<ol>
<li>1./usr/local/webserver/nginx/sbin/nginx -s reload            # 重新载入配置文件</li>
<li>2./usr/local/webserver/nginx/sbin/nginx -s reopen            # 重启 Nginx</li>
<li>3./usr/local/webserver/nginx/sbin/nginx -s stop              # 停止 Nginx</li>
</ol>
<h3 id="5-编译nginx平滑添加stream模块"><a href="#5-编译nginx平滑添加stream模块" class="headerlink" title="5.编译nginx平滑添加stream模块"></a>5.编译nginx平滑添加stream模块</h3><p>有时候我们如果直接不能连接服务器c,但是B服务器能够连接服务器c,所有我们通过在B服务器做代理直接连接c。<br><a href="http://www.mamicode.com/info-detail-2272209.html。" target="_blank" rel="external">http://www.mamicode.com/info-detail-2272209.html。</a></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">./configure --user=nginx --group=nginx --prefix=/founder/tools/nginx --with-http_stub_status_module --with-http_ssl_module</div><div class="line">--with-http_realip_module --with-http_addition_module --with-pcre=/founder/tools/pcre-8.33 --with-zlib=/founder/tools/zlib-1.2.8 --with-stream  </div><div class="line">--with-stream_ssl_module</div></pre></td></tr></table></figure>
</code></pre><p>nginx实现端口监听:  </p>
<p><a href="https://www.jianshu.com/p/c5097147ace3" target="_blank" rel="external">https://www.jianshu.com/p/c5097147ace3</a>  </p>
<h3 id="6-安装stream模块"><a href="#6-安装stream模块" class="headerlink" title="6.安装stream模块"></a>6.安装stream模块</h3><p>./configure –with-stream –prefix=/usr/local/nginx &amp;&amp; make &amp;&amp; make install</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/31/work-11-nginx安装配置https/" class="archive-article-date">
  	<time datetime="2019-07-31T06:59:33.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/work/">work</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ipcc-2-常见问题记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/ipcc-2-常见问题记录/">ipcc-2-常见问题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-ipcc对接第三方话务平台"><a href="#1-ipcc对接第三方话务平台" class="headerlink" title="1.ipcc对接第三方话务平台"></a>1.ipcc对接第三方话务平台</h4><h5 id="1-1抓包找不到对应ip数据包"><a href="#1-1抓包找不到对应ip数据包" class="headerlink" title="1.1抓包找不到对应ip数据包"></a>1.1抓包找不到对应ip数据包</h5><ol>
<li>1.分析:ipcc对接第三方话务平台的时候、我们抓包时候压根抓不到对应的ip网络交互、说明ipcc没能和第三方话务平台建立链接、说明freeswitch的sip对接地址注册有问题  </li>
<li>2.解决:a.查看对应的网关对接信息是否有问题,在freeswitch的/usr/local/freeswitch/conf/sip_profiles/external/gw5.xml配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/35.png" alt="">  </li>
<li>3.解决:b.查看freeswitch启动时候日志信息:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/36.png" alt=""><br>从上面看是gw5.xml网关对应的配置信息有误  </li>
<li>4.解决:c.打开fs的客户端fs_cli通过sofia status 查看网关注册状态<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/37.png" alt=""><br>从上面可以知道网关注册失败  </li>
</ol>
<p>综上:找相关人员再次获取相关信息。</p>
<h5 id="1-2-fs通过mrcp对接asr时候对接不上"><a href="#1-2-fs通过mrcp对接asr时候对接不上" class="headerlink" title="1.2.fs通过mrcp对接asr时候对接不上"></a>1.2.fs通过mrcp对接asr时候对接不上</h5><p>在测试环境下fs通过mrcp对接asr时候对接时候、启动fs和ipcc平台时候、发现和机器人交互时候总是感觉机器人获取不到用户说话的声音并且抓包时候也没有抓到包<br>解决: </p>
<ol>
<li>1.查看asr的配置信息并确认没问题<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/38.png" alt="">  </li>
<li>2.查看fs的启动日志:然后查看端口信息、发现端口被占用<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/39.png" alt=""><br>综上:杀掉端口对应进程、然后重启即可。</li>
</ol>
<h4 id="2-ipcc通话录音不存在"><a href="#2-ipcc通话录音不存在" class="headerlink" title="2.ipcc通话录音不存在"></a>2.ipcc通话录音不存在</h4><h5 id="2-1-现象"><a href="#2-1-现象" class="headerlink" title="2.1 现象"></a>2.1 现象</h5><p>gs在拨打电话测试时候,测试时候交互都很正常,但是在拨打完听录音时候出现:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/184.png" alt=""><br>HTTP Status 404-<br>/record/ivrrecord2/20190820/10/42/90043811800411.wav</p>
<h5 id="2-2-排查"><a href="#2-2-排查" class="headerlink" title="2.2 排查"></a>2.2 排查</h5><ol>
<li><p>1.查询服务器磁盘录音是否存在<br>-进入/cc/data/ivrrecord2/20190820/10目录下确实没有此文件<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/185.png" alt="">  </p>
</li>
<li><p>2.查看fsg日志<br>fsg是freeswitch和ag进行交互的枢纽,所以fsg日志里面会记录相关的日志信息,fsg的日志文件在/cc/bin/log下:log0819060907.log<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/186.png" alt=""><br>从上面我们知道fsg和freeswitch已经断开过连接,然后重新建立了连接。  </p>
</li>
</ol>
<p>我们在查看freeswitch.log知道:丢失了很多交互信息<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/187.png" alt="">  </p>
<ol>
<li>3.查看fsg.cfg的配置<br>从配置中我们知道连接的freeswitch是127.0.0.1,对应的录音文件是:/cc/data<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/188.png" alt=""><br>说明在连接本地freeswitch的时候,也出现了网络抖动问题。  </li>
</ol>
<h4 id="2-查看批次数据不拨打"><a href="#2-查看批次数据不拨打" class="headerlink" title="2.查看批次数据不拨打"></a>2.查看批次数据不拨打</h4><ol>
<li><p>1.首先我们需要查看批次暂停/启用是否生效<br>启停 之前给过你grep方法 搜一下<br>停用:grep “end taskid”<br>启用:init notifyid<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/3.png" alt="">  </p>
</li>
<li><p>2.查看具体原因:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">grep &quot;批次id&quot; callnotify_callnotify01_1575880253.log;</div><div class="line">```  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/4.png)  </div><div class="line"></div><div class="line">3. 3.查看是否有对应主叫</div></pre></td></tr></table></figure>
<p>grep “ocm_enti_exinfo_sub” dbg_dbgnotify01_xxx.log<br>```</p>
<p>再去到数据库执行,查找批次下的comcode是否有下对应是否有次主叫:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/5.png" alt=""> </p>
<p>有时候我们查询出后发现:主叫表里面有对应comcode的主叫,但是还是报:caller is empty这个时候我们就需要再去:dbgnotify查看日志。  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/29/ipcc-2-常见问题记录/" class="archive-article-date">
  	<time datetime="2019-07-29T08:29:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-29</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ipcc/">ipcc</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ElasticStack-1-前言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/24/ElasticStack-1-前言/">ElasticStack-1-前言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-为什么使用ElasticStack"><a href="#1-为什么使用ElasticStack" class="headerlink" title="1.为什么使用ElasticStack"></a>1.为什么使用ElasticStack</h4><p>我们知道的一般大数据分析工具有如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/57.png" alt=""><br>我们为什么还需要使用ElasticStack呢?<br>原因:  </p>
<ol>
<li>1.使用门槛低、开发周期短、上线快<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/58.png" alt="">  </li>
<li>2.性能好、查询快、实时展示结果<br>对T+1说不，以前我们查询数据结果，都是时隔一段时间或者一天再分析，现在我们需要”现在、立刻马上要数据”  </li>
<li><p>3.扩容方便、快速支撑增长迅猛的数据<br>刚开始也许只是GB数据、随着业务量变大、TB、PB级别的数据也不是问题。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/59.png" alt=""> </p>
<h4 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h4><h5 id="2-1-ElasticStack组成"><a href="#2-1-ElasticStack组成" class="headerlink" title="2.1 ElasticStack组成"></a>2.1 ElasticStack组成</h5><p>传统的ELK其实就是:Elasticsearch、Logstash、Kibana，自从加入了Beats后,进行升级，变成了Elastic Stack。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/60.png" alt="">   </p>
<h5 id="2-2-各个模块功能"><a href="#2-2-各个模块功能" class="headerlink" title="2.2 各个模块功能"></a>2.2 各个模块功能</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/61.png" alt="">  </p>
</li>
<li><p>1.Elasticsearch主要是做数据处理的  </p>
</li>
<li>2.Beats和    Logstash是做数据收集与处理，相当于早期的ETL<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/62.png" alt=""></li>
<li>3.Kibna数据搜索与可视化分析<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/63.png" alt=""></li>
</ol>
<h5 id="2-3-ElasticStack功能"><a href="#2-3-ElasticStack功能" class="headerlink" title="2.3 ElasticStack功能"></a>2.3 ElasticStack功能</h5><p>一定要内外兼修、不仅仅会使用API还得了解原理。  </p>
<ol>
<li>1.ElasticStack是一个完备的数据分析工具集合<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/64.png" alt=""></li>
<li>2.学习安排:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/65.png" alt="">  </li>
<li><p>3.Elasticsearch篇章讲解举例<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/66.png" alt="">  </p>
</li>
<li><p>4.实践项目<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/67.png" alt=""> </p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/24/ElasticStack-1-前言/" class="archive-article-date">
  	<time datetime="2019-06-24T14:40:53.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ElasticStack/">ElasticStack</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ipcc-1-ipcc整体架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/ipcc-1-ipcc整体架构/">ipcc-1-ipcc整体架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-ipcc总体架构模块"><a href="#1-ipcc总体架构模块" class="headerlink" title="1.ipcc总体架构模块"></a>1.ipcc总体架构模块</h3><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/37.png" alt=""> </p>
<h3 id="2-系统模块图"><a href="#2-系统模块图" class="headerlink" title="2.系统模块图"></a>2.系统模块图</h3><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/213.png" alt=""></p>
<h4 id="2-1-acd模块"><a href="#2-1-acd模块" class="headerlink" title="2.1 acd模块"></a>2.1 acd模块</h4><ol>
<li><p>1.acd模块<br>acd在平台中的位置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/214.png" alt="">  </p>
</li>
<li><p>2.配置坐席呼出<br><a href="https://blog.csdn.net/weixin_34242819/article/details/90492301" target="_blank" rel="external">https://blog.csdn.net/weixin_34242819/article/details/90492301</a><br>对于登录坐席工号进行呼出的情况,我们有如下步骤:1.坐席签入后能上线成功  2.坐席能够正确路由到运营商的sip电话进行呼叫  </p>
</li>
</ol>
<h5 id="2-1-1-坐席签入后能上线成功"><a href="#2-1-1-坐席签入后能上线成功" class="headerlink" title="2.1.1 坐席签入后能上线成功"></a>2.1.1 坐席签入后能上线成功</h5><h6 id="坐席上线"><a href="#坐席上线" class="headerlink" title="坐席上线"></a>坐席上线</h6><p>1.在cti_work表中找到分机,如:100003。<br>2.配置100003到cti_work_queue中去<br>3.在cti_outcaller中配置上线的主叫<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/64.png" alt=""><br>3.在cti_telno中配置分机路由:100003分机呼出使用内线字段、长度在1-6(因为:100003是6位数)、<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/215.png" alt=""><br>4.查看/cc/bin/log下面的日志:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/62.png" alt=""><br>发现话机没有注册,打开一看:是注册的服务错了<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/63.png" alt=""><br>5.如果出问题,查看Acdgate模块下Tomcat日志,在查看/cc/log/acd_acd01.log下的日志<br>acd_acd01.log里面r:开头的。   </p>
<h6 id="机器人锁定坐席转人工"><a href="#机器人锁定坐席转人工" class="headerlink" title="机器人锁定坐席转人工"></a>机器人锁定坐席转人工</h6><p>我们在排查之前可以关掉hmp,设置:hmpcheck=0<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/69.png" alt=""><br>1.在确保坐席能够上线情况下,先配置转人工的机器人场景:1013502011<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/65.png" alt=""><br>2.在批次场景里面创建人批次场景,然后创建对应批次,进行外呼<br>3.查看acd_acd01_xxxx.log下的日志:锁定坐席成功与否?—&gt;TRptque::getandlockagent<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/66.png" alt=""><br>4.外呼后查看日志:httpg_httpg01_xxxx.log<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/09/67.png" alt=""><br>查看机器人转人工文档说明书知道:”att_status”:”0”不在线，”att_status”:”1”在线<br>5.如果和ai交互时候,传递的参数不对的话,我们查看acd模块:<br>TRptque::getandlockagent res=[-1]表示没有获取到空闲坐席<br>6.如果转人工时候,坐席挂不断,说明是坐席表里面的相同workno有多条。  </p>
<p>6.正常交互如下:<br>acd:2019-09-15 09:48:03.453 TRptque::getandlockagent res=[0], workno=[100002] quueueid=[52] usid = [90046126300563]<br>httpg:ai获取空闲坐席:key:[{“userid”:”900461263”,”inaction”:0,”inparams”:{“call_id”:”900461263”,”call_sor_id”:”15188317019”,”call_dst_id”:”051289578445”,”att_status”:”1”}}].<br>ai转人工传递queueid:ok:0,resultbuf[{“ret”:0,”userid”:”900461263”,”outaction”:”11”,”outparams”:{“call_dst_id”:”051289578445”,”queue_id”:”52”,”call_id”:”900461263”,”inter_idx”:”8”,”call_sor_id”:”15188317019”}}].   </p>
<h5 id="2-1-2-正确路由到运营商的sip电话进行呼叫"><a href="#2-1-2-正确路由到运营商的sip电话进行呼叫" class="headerlink" title="2.1.2 正确路由到运营商的sip电话进行呼叫"></a>2.1.2 正确路由到运营商的sip电话进行呼叫</h5><p>1.acd.cfg配置(配置是不是开启did,did是优先级最高的,如果开启,呼叫客户的主叫号码将会是did号码-DID的中文意思是直接拨入，是运营商提出的概念，通过这个号码，运营商可以呼叫到voip系统内，freeswitch上实现外乎呼叫的方式为配置一个网关，指定运营商的接入号和密码，有呼叫这个号码时，运营商会把这个号码送给freeswitch。)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/216.png" alt=""><br>2.acd.cfg配置(设置使用的主叫号码:usefromcaller,如果想要使用cti_work里面的,需要配置为1)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/217.png" alt=""><br>3.配置坐席呼出的主叫显示:cti_outcaller<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/218.png" alt=""><br>4.使用web页面上的软电话条进行呼叫,然后查看呼叫的结果里面是不是我们配置的主叫<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/219.png" alt=""><br>从上面我们可以知道,坐席呼出时候是两通电话。</p>
<h4 id="2-2-fsg模块"><a href="#2-2-fsg模块" class="headerlink" title="2.2.fsg模块"></a>2.2.fsg模块</h4><p>FSG模块作为:AG(CTI)和FS进行交互模块,其作用就是一个接口调用服务。<br>对应的配置文件是:/cc/cfg/fsg.cfg<br>对应的日志文件是:/cc/log/fsg<em>**</em>.log和/cc/bin/log/log*.log<br>其日志记录了ipcc内部和外部中继网络交互的日志详情。  </p>
<h5 id="2-2-1-fsg模块修改日志"><a href="#2-2-1-fsg模块修改日志" class="headerlink" title="2.2.1.fsg模块修改日志"></a>2.2.1.fsg模块修改日志</h5><p>有时候,我们为了排查和外部对接的错误信息时候,可以通过两种方式:<br>1.修改fsg的日志级别为6<br>2.通过tcpdump -w xx.cap抓包<br>以下为修改fsg的日志级别为6的设置  </p>
<h6 id="2-2-1-1-删除原来的fsg相关日志文件"><a href="#2-2-1-1-删除原来的fsg相关日志文件" class="headerlink" title="2.2.1.1.删除原来的fsg相关日志文件"></a>2.2.1.1.删除原来的fsg相关日志文件</h6><ol>
<li>删除/cc/bin/log文件目录下的文件  </li>
<li>删除/cc/log/fsg*.log文件  <h6 id="2-2-1-2-修改日志级别配置文件fsg-cfg"><a href="#2-2-1-2-修改日志级别配置文件fsg-cfg" class="headerlink" title="2.2.1.2.修改日志级别配置文件fsg.cfg"></a>2.2.1.2.修改日志级别配置文件fsg.cfg</h6></li>
<li>修改fsg.cfg里面SET下的日志级别文件为6<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/18.png" alt=""><br>acd在平台起到用户转座席排队，座席分配，座席操作控制等和座席呼叫相关的功能。<h6 id="2-2-1-3-以写入文件的方式启动fsg-sh"><a href="#2-2-1-3-以写入文件的方式启动fsg-sh" class="headerlink" title="2.2.1.3.以写入文件的方式启动fsg.sh"></a>2.2.1.3.以写入文件的方式启动fsg.sh</h6>进入/cc/bin下输入</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fsg.sh restart &gt; /cc/bin/log/xxx.log</div></pre></td></tr></table></figure>
<h4 id="2-3-ag模块"><a href="#2-3-ag模块" class="headerlink" title="2.3 ag模块"></a>2.3 ag模块</h4><h5 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h5><p>AG在整个YC平台中起着集中管理的作用。AG模块就是我们常说的CTI模块。<br>AG起的作用有以下几点：<br>1、    管理多个适配节点的接入。<br>2、    统一对多个节点的电路进行全局编号。<br>3、    对电路进行分组管理。<br>4、    呼入电话路由相应的IVR流程进行处理。<br>5、    呼出电话路由到相应的电路组。<br>6、    管理呼叫电话分配媒体资源（播音，录音，会议，传真等媒体资源）</p>
<h5 id="2-3-2-呼叫问题排查-AG问题排查"><a href="#2-3-2-呼叫问题排查-AG问题排查" class="headerlink" title="2.3.2 呼叫问题排查(AG问题排查)"></a>2.3.2 呼叫问题排查(AG问题排查)</h5><p>理解T、HT、R、HR是理解ag模块的关键  </p>
<ol>
<li>1.按照流程来:T是收到  R是发送 HR是收到发送端的消息 HT是给T端返回信息  </li>
<li>2.对于AG来说:T端是ACD、Dyflow等;R端是fsg  </li>
<li>3.对于FSG来说: T端是ag  R是fsapi  </li>
<li>4.ACD等来说:T端是自己 R端是ag  </li>
</ol>
<p>我们查相关日志时候,先从ag模块(cti模块)查询起,然后一次找到T、R。<br>分析:看ag的日志—&gt;这种交互ag的日志是两边都有的–&gt;从ag里面开始分析—&gt;平台挂机0、200是用户挂的—&gt;从ag开始看确定消息在什么地方不对了 然后再分析fsg测 或者是ivr测的日志<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/10/37.png" alt="">  </p>
<h4 id="2-日志文件模块"><a href="#2-日志文件模块" class="headerlink" title="2.日志文件模块"></a>2.日志文件模块</h4><h5 id="2-1-查看和机器人交互日志"><a href="#2-1-查看和机器人交互日志" class="headerlink" title="2.1.查看和机器人交互日志"></a>2.1.查看和机器人交互日志</h5><p>和机器人交互日志都是通过ivr流程中http传数据,所以在httpg日志,需要看就提详细信息可以看dyflow日志</p>
<h5 id="2-2-查看任务加载-工作日-时间段-呼叫情况"><a href="#2-2-查看任务加载-工作日-时间段-呼叫情况" class="headerlink" title="2.2.查看任务加载,工作日,时间段,呼叫情况"></a>2.2.查看任务加载,工作日,时间段,呼叫情况</h5><ol>
<li>1.任务即是notify,但是任务在呼叫前任务加载,工作日,时间段都是在dbg_dbg01模块</li>
<li>2.查看任务呼叫情况:callnotify_callnotify01.log  </li>
<li>3.查看任务调用api模块:callnotify_callnotifyapi.log  </li>
<li>4.查看任务呼叫失败情况,没有数据插入到cti_cdr、ocm_result：查看callnotify_callnotifyfailsql.log  </li>
</ol>
<h4 id="3-ipcc对接其他server"><a href="#3-ipcc对接其他server" class="headerlink" title="3.ipcc对接其他server"></a>3.ipcc对接其他server</h4><p>参考:<a href="https://blog.csdn.net/gredn/article/details/40581871" target="_blank" rel="external">https://blog.csdn.net/gredn/article/details/40581871</a></p>
<h5 id="3-1-修改freeswitch配置"><a href="#3-1-修改freeswitch配置" class="headerlink" title="3.1 修改freeswitch配置"></a>3.1 修改freeswitch配置</h5><p>从平台架构我们知道,我们现在需要和外部第三方sipServer对接,首先需要打通各自的网络,然后就是配置相关的网管  </p>
<ol>
<li>1.进入freeswitch目录下freeswitch/conf/sip_profiles/external其中有外部网管模块。 拷贝存在的一个网关配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/62.png" alt="">  </li>
<li>2.修改gw3.xml中对接的外部sipServer地址和端口:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/63.png" alt=""> </li>
<li>3.重启freeswitch<br>进入freeswitch的bin目录停止fs:./freeswitch -stop<br>进入freeswitch的bin目录启动fs:./freeswitch -nc -nonat  </li>
</ol>
<h5 id="3-2-修改号码网管路由"><a href="#3-2-修改号码网管路由" class="headerlink" title="3.2 修改号码网管路由"></a>3.2 修改号码网管路由</h5><ol>
<li>1.修改cti_route表<br>打开数据库表cti_route配置主叫外显号码和网关对应的关系<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/64.png" alt=""> </li>
<li>2.重启fsg<br>进入/cc/bin目录下:执行:./fsg.sh restart  </li>
</ol>
<h5 id="3-3-使用抓包工具抓包"><a href="#3-3-使用抓包工具抓包" class="headerlink" title="3.3 使用抓包工具抓包"></a>3.3 使用抓包工具抓包</h5><p>对接完之后,如果电话不通,那么就需要使用wireshake进行网络抓包,分析包  </p>
<h4 id="4-ipcc对每个号码并发进行控制"><a href="#4-ipcc对每个号码并发进行控制" class="headerlink" title="4.ipcc对每个号码并发进行控制"></a>4.ipcc对每个号码并发进行控制</h4><p>在/cc/cfg/notify.cfg下的callnotify添加:examentline=1表明开启了号码并发设置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/6.png" alt="">  </p>
<h4 id="5-ipcc配置空号检测"><a href="#5-ipcc配置空号检测" class="headerlink" title="5.ipcc配置空号检测"></a>5.ipcc配置空号检测</h4><h5 id="5-1-安装空号检测"><a href="#5-1-安装空号检测" class="headerlink" title="5.1 安装空号检测"></a>5.1 安装空号检测</h5><ol>
<li>1.首先正常安装并启用空号检测da2(安装数据库、程序)  </li>
<li>2.如果空号检测部署在一台服务器上，我们呼叫平台部署在多台服务器上，我们如何配置呢?  </li>
<li>3.查看/usr/local/freeswitch/conf下面文件:da2.json<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/7.png" alt="">  </li>
<li>4.重启freeswitch:进入freeswitch的bin目录:执行:./freeswitch -stop 再执行:./freeswitch -nc -nonat  </li>
<li>5.打开freeswitch客户端:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./fs_cli -P 8031 -p testtest</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/8.png" alt=""> </p>
<ol>
<li>6.在fs控制台客户端输入:da2 show<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/9.png" alt=""><br>出现上面问题说明成功,如果一直不成功检查对应数据库表  </li>
</ol>
<h5 id="5-2-添加新的授权"><a href="#5-2-添加新的授权" class="headerlink" title="5.2 添加新的授权"></a>5.2 添加新的授权</h5><p>部署新的话务平台节点时候需要添加新的授权,修改两个表:user,bill;<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/11/83.png" alt="">   </p>
<h4 id="6-ipcc中cdr关于服务"><a href="#6-ipcc中cdr关于服务" class="headerlink" title="6.ipcc中cdr关于服务"></a>6.ipcc中cdr关于服务</h4><ol>
<li>1.服务水平只对呼入而言的 呼出不用管  calltype=100 and dir=1  </li>
<li>2.starttime  connecttime和endtime 是整个电话的开始 接起和结束时间</li>
<li>3.workstarttime 是电话进入acd的时间  workconnect是坐席接起电话的时间 workendtime是坐席服务结束的时间 acmtime 在呼入的时候是坐席开始振铃时间（注意  在呼出的时候是用户振铃时间）</li>
<li>4.acmtime是服务水平的统计标志</li>
<li>5.用户呼叫系统的全部电话（呼入我们目前都要进入ivr ）：calltype&lt;300 and dir = 1 </li>
<li>6.坐席呼出用户的电话  calltype=100 || calltype=113||calltype=114  and dir=0</li>
<li>7.自动外呼呼出的电话   notifyid is not null</li>
<li>8.里面 connecttime  workconnecttime字段很重要 判断是否接通的依据</li>
<li>9.建议：现在数据除了cdr表外 通话数据 坐席数据 其实已经通过ice推送给ccms了、ccms能不能做一些文件存储 然后通过一些外部工具进行数据分析、毕竟cdr是生产上的 不能频繁访问、 ZeroC ICE提供一种打补丁方式，名为IcePatch2。基本功能就是通过ICE通讯将服务器上的最近软件部署到各个客户端中，这间接的实现了文件传输功能，</li>
</ol>
<h4 id="7-ipcc中任务呼叫失败原因"><a href="#7-ipcc中任务呼叫失败原因" class="headerlink" title="7.ipcc中任务呼叫失败原因"></a>7.ipcc中任务呼叫失败原因</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/81.png" alt="">  </p>
<h4 id="8-ipcc中任务脚本通知"><a href="#8-ipcc中任务脚本通知" class="headerlink" title="8.ipcc中任务脚本通知"></a>8.ipcc中任务脚本通知</h4><p>通过shell脚本的iniwrite和ice不能并存,如果用ice需要把iniwrite改成iniwrite1或者其他<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/82.png" alt=""> </p>
<h4 id="9-ipcc中配置"><a href="#9-ipcc中配置" class="headerlink" title="9.ipcc中配置"></a>9.ipcc中配置</h4><p>ipcc各种配置请参考对应的doc文档。  </p>
<h3 id="2-空号检测模块搭建及录音库文件更新"><a href="#2-空号检测模块搭建及录音库文件更新" class="headerlink" title="2.空号检测模块搭建及录音库文件更新"></a>2.空号检测模块搭建及录音库文件更新</h3><p>注意:金服空号检测服务器由于私有云不能访问到外网,所以将空号检测license所在服务部署到了金服金融云。(金融云是连通公有云和私有云的桥梁)  </p>
<p>空号检测服务daserver是根据局端返回的录音文件:然后通过asr识别来返回信令结果:dropcause  </p>
<h4 id="2-1服务搭建"><a href="#2-1服务搭建" class="headerlink" title="2.1服务搭建"></a>2.1服务搭建</h4><ol>
<li>1.解压da.tar.gz数据库  </li>
<li>2.安装mysql<br>centos6<br>-yum install mysql-server<br>-service mysqld start<br>-chkconfig mysqld on   </li>
</ol>
<p>centos7<br>-yum install mariadb-server<br>-systemctl start mariadb.service<br>-systemctl enable mariadb.service   </p>
<ol>
<li><p>3.创建数据库da<br>mysqladmin -uroot -p create da  </p>
</li>
<li><p>4.导入数据到da<br>mysql -uroot -p da &lt; da.sql<br>生成的数据库和表如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/99.png" alt=""></p>
</li>
<li>5.执行machinecode获取机器码,发给cdevelop@qq.com申请授权码,写入 license.txt .<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/95.png" alt="">    </li>
<li><p>6.根据安装文档word版本,配置数据库和JSON  </p>
</li>
<li><p>7.启动daserver<br>临时启动: ./daserver<br>后台启动: nohup ./daserver &amp;  </p>
</li>
</ol>
<p>注意:启动出现 ./daserver: relocation error: ./libssl.so.10: symbol private_ossl_minimum_dh_bits, version libcrypto.so.10 not defined in file libcrypto.so.10 with link time reference<br>一般是系统已经有了其他版本的ssl,删除 本目录的 libssl.so.10 文件  </p>
<h4 id="2-2更新录音文件库"><a href="#2-2更新录音文件库" class="headerlink" title="2.2更新录音文件库"></a>2.2更新录音文件库</h4><p>电话在拨打过程中出现了运营商返回的错误信令:dropcause为480<br>通过查询da模块(空号检测模块)录制的录音知道:”您拨打的号码是非本地号码,请在拨打号码前加0” 我们知道空号检测模块的录音库中没有识别到此空号录音，所以我们需要更新录音库(使用da提供的win下的工具samplemgr,连接da所在license的库数据库da)，有时候我们是无法直接连接license所在的da数据，而只能连接测试数据库，所以我们需要在测试环境下操作，然后把对应的数据替换到生产库。  </p>
<h5 id="2-2-1更新da语音库"><a href="#2-2-1更新da语音库" class="headerlink" title="2.2.1更新da语音库"></a>2.2.1更新da语音库</h5><ol>
<li>1.打开samplemgr,连接对应的数据库<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/96.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/97.png" alt="">      </li>
<li><p>2.启动服务,输入key(key是da数据库中)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/100.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/98.png" alt=""><br>启动成功日志:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/101.png" alt="">  </p>
</li>
<li><p>3.添加录音库测试<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/102.png" alt=""><br>文件要求 8000hz 16位 单声道，文件名要是数字，比如 电话号码.wav 这样子。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/103.png" alt=""><br>后续步骤按照samplemgr里面的文档:添加样本例子.docx  </p>
</li>
</ol>
<h5 id="2-2-2-测试环境da数据导入到生产环境"><a href="#2-2-2-测试环境da数据导入到生产环境" class="headerlink" title="2.2.2 测试环境da数据导入到生产环境"></a>2.2.2 测试环境da数据导入到生产环境</h5><p>注意:1.由于da表结构中字段类型是:blob所以我们不能使用SQLyog或者Navicat工具直接将表数据导出，经测试直接导出的数据通过source导入到生产环境时候会由于乱码导入报错。而只能直接在测试环境所在服务是使用mysqldump指令导出数据。  </p>
<h6 id="1-测试环境da数据导出"><a href="#1-测试环境da数据导出" class="headerlink" title="1.测试环境da数据导出"></a>1.测试环境da数据导出</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/104.png" alt=""></p>
<ol>
<li>1.进入测试环境da数据库数据(以导出mfcc数据为例)<br>mysqldump -u <username> -p <dbname> &gt; /path/to/<em>*</em>.sql<br>我们直接输入:mysqldump -u root -p123456 da mfcc&gt;mfcc.sql 报错如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/105.png" alt=""><br>说明我们导出表数据时候不能直接输入密码。我们更换成如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/106.png" alt="">  <h6 id="2-生产环境da数据导入"><a href="#2-生产环境da数据导入" class="headerlink" title="2.生产环境da数据导入"></a>2.生产环境da数据导入</h6></dbname></username></li>
<li>1.连接生产环境数据库(注：如果连接不上时候加上-h 127.0.01参数)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/107.png" alt=""> </li>
<li>2.数据导入<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/108.png" alt="">  </li>
</ol>
<h6 id="3-启动da的license所在服务"><a href="#3-启动da的license所在服务" class="headerlink" title="3.启动da的license所在服务"></a>3.启动da的license所在服务</h6><p>从数据导入之后使用./daserver启用之后,大概到了下午4点11分左右,局端又返回许多480结果,然后查看da的录音<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/110.png" alt=""><br>听录音是没有识别到,于是进入freeswitch里面的log下的da.log打开后发现下午4点11分左右就不开始识别了:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/111.png" alt=""><br>查看daserver进程发现进程挂了,所以使用下面后太启动方式。  </p>
<ol>
<li>1.进入daserver所在目录下执行后台启动指令:<br>nohup ./daserver &amp;<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/08/109.png" alt="">  </li>
</ol>
<h4 id="10-定时备份日志"><a href="#10-定时备份日志" class="headerlink" title="10.定时备份日志"></a>10.定时备份日志</h4><ol>
<li><p>1.编写clearlog.sh  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /cc/log/bak</div><div class="line">find /cc/bin/log -mtime +1 -type f -name &quot;log*.log&quot; -exec mv &#123;&#125; /cc/log/bak/. \;</div><div class="line">tar zcvf fslog$(date +&quot;%Y%m%d%H%M&quot;)tar.gz log*.log </div><div class="line">rm -f log*.log</div><div class="line">find /cc/log -mtime +1 -type f -name &quot;*.log&quot; -exec mv &#123;&#125; /cc/log/bak/. \;</div><div class="line">tar zcvf log$(date +&quot;%Y%m%d%H%M&quot;).log.tar.gz *.log </div><div class="line">rm -f *.log</div></pre></td></tr></table></figure>
</li>
<li><p>2.添加到系统定时任务中去<br>a.在root下执行 crontab -e<br>b.将0 0 <em> </em> *  /cc/bin/cleanlog.sh &gt; /dev/null 2&gt;&amp;1 放进去 保存退出。</p>
</li>
<li><p>3.运维查询每天日志的最小、最大拨打时间  </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">SELECT MIN(starttime),MAX(starttime),SUBSTRING(starttime,1,10) FROM cti_cdr WHERE entid = 1308 GROUP BY SUBSTRING(starttime,1,10) ORDER BY starttime ASC;</div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 11.停止掉空号检测</div><div class="line">  </div><div class="line">1.进入:/cc/freeswitch/conf;不是删除da2.json  </div><div class="line">2.注释掉:load mod_da2  </div><div class="line">进入:/cc/freeswitch/conf/autoload_configs找到文件:modules.conf.xml</div><div class="line">然后注释掉:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/10/114.png)  </div><div class="line">3.fsg.cfg里面:注释掉:识别da2的注释掉</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/10/116.png)</div><div class="line"></div><div class="line">#### 12.fs中注释掉影响通话质量的元素  </div><div class="line">1.conf/vars.xml里面的以下几行注释掉:</div></pre></td></tr></table></figure>
<!--RECORD_SILENCE_THRESHOLD vad调节阀值,声音能量，配置太小旁边人说话会被当成说话800 -->
  <!--X-PRE-PROCESS cmd="set" data="RECORD_SILENCE_THRESHOLD=800"/->

  <!-- EOS_SILENCE_THRESHOLD 没说话的静音阈值200-->
  <!--X-PRE-PROCESS cmd="set" data="EOS_SILENCE_THRESHOLD=200"/-->
  <!--RECORD_FINAL_TIMEOUT_MS 停顿超时，说话结束-->
  <!--X-PRE-PROCESS cmd="set" data="RECORD_FINAL_TIMEOUT_MS=600"/-->
 <!--X-PRE-PROCESS cmd="set" data="RECORD_STEREO=true"/-->
<p>```</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/05/14/ipcc-1-ipcc整体架构/" class="archive-article-date">
  	<time datetime="2019-05-14T11:36:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-05-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ipcc/">ipcc</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-8-Zuul综合使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/18/SpringCloud-8-Zuul综合使用/">SpringCloud-8-Zuul综合使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>项目整体架构图如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/8.png" alt="">   </p>
<h4 id="8-1-Zuul-Pre和Post过滤器"><a href="#8-1-Zuul-Pre和Post过滤器" class="headerlink" title="8.1 Zuul:Pre和Post过滤器"></a>8.1 Zuul:Pre和Post过滤器</h4><ol>
<li>1.从以上架构图知道:所有的请求都会到Zuul,然后到ServicreA、然后到ServiceB、再到ServiceC、现在我们对整体服务做一个权限校验。假如没有zuul服务、那么ServicreA、ServicreB、ServicreC都得校验一次做的太多受不了。所以权限校验我们放在Zuul里面统一处理。</li>
<li>2.接下来我们演示如何对请求进行统一的校验,我们现在做一个所有经过Zuul的请求都要有一个token,并且内容不能为空,如果不带token参数的话,权限校验不通过。我们以:<a href="http://localhost:8084/myProduct/product/list?token=12121为例子.。我们只有在连接后面添加:token=？才允许校验通过。" target="_blank" rel="external">http://localhost:8084/myProduct/product/list?token=12121为例子.。我们只有在连接后面添加:token=？才允许校验通过。</a>  <h5 id="8-1-1-Zuul统一校验"><a href="#8-1-1-Zuul统一校验" class="headerlink" title="8.1.1 Zuul统一校验"></a>8.1.1 Zuul统一校验</h5>我们在api-gateway项目下面创建filter包,并新建一个TokenFilter类    </li>
<li>1.新建TokenFilter做PRE过滤<br>a.这里面我们做的是参数校验:所以filterType是:PRE_TYPE。<br>b.我们在run()方法里面实现具体的逻辑。    </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class TokenFilter extends ZuulFilter&#123;</div><div class="line">@Override</div><div class="line">public String filterType() &#123;</div><div class="line">    return PRE_TYPE;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public int filterOrder() &#123;</div><div class="line">    /**</div><div class="line">     * filter的顺序:对应的值越低优先级越高</div><div class="line">     * 我们把此Filter放在PRE_DECORATION_FILTER_ORDER前面</div><div class="line">     */</div><div class="line">    return PRE_DECORATION_FILTER_ORDER-1;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public boolean shouldFilter() &#123;</div><div class="line">    /**</div><div class="line">     * 开启过滤</div><div class="line">     */</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Object run() throws ZuulException &#123;</div><div class="line">    //1.获取当前上下文</div><div class="line">    RequestContext requestContext = RequestContext.getCurrentContext();</div><div class="line">    HttpServletRequest request = requestContext.getRequest();</div><div class="line">    //这里从url参数里面获取,也可以从cookie,header里获取</div><div class="line">    String token = request.getParameter(&quot;token&quot;);</div><div class="line">    if(StringUtils.isEmpty(token))&#123;</div><div class="line">        requestContext.setSendZuulResponse(false);</div><div class="line">        requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试:<a href="http://localhost:8084/myProduct/product/list" target="_blank" rel="external">http://localhost:8084/myProduct/product/list</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/4.png" alt=""> </p>
<p>携带token测试:<a href="http://localhost:8084/myProduct/product/list?token=112" target="_blank" rel="external">http://localhost:8084/myProduct/product/list?token=112</a><br>正常返回  </p>
<p>当然我们的判断逻辑可能不止token为空,也可以拿到token值之后从数据库读。  </p>
<ol>
<li>2.新建Post过滤器<br>我们也可以定义postfilter,在请求到结果之后,对请求的结果进行处理加工。 这里我们往请求返回的header里面写一些东西，新建AddResponseHeaderFilter类。<br>a.filterType-&gt;POST_TYPE<br>b.自定义post filter时候,我们选择使用:SEND_RESPONSE_FILTER_ORDER之前的filter     </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class AddResponseHeaderFilter extends ZuulFilter&#123;</div><div class="line">@Override</div><div class="line">public String filterType() &#123;</div><div class="line">    return POST_TYPE;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public int filterOrder() &#123;</div><div class="line">    /**</div><div class="line">    *我们自定义post filter时候我们filter的顺序放到SEND_RESPONSE_FILTER_ORDER之前。</div><div class="line">    **/</div><div class="line">    return SEND_RESPONSE_FILTER_ORDER - 1;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public boolean shouldFilter() &#123;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Object run() &#123;</div><div class="line">    RequestContext requestContext = RequestContext.getCurrentContext();</div><div class="line">    HttpServletResponse response = requestContext.getResponse();</div><div class="line">    /**</div><div class="line">    *请求成功之后,我们往header里面添加一些信息。  </div><div class="line">    **/</div><div class="line">    response.setHeader(&quot;X-Foo&quot;, UUID.randomUUID().toString());</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/6.png" alt=""> </p>
<h4 id="8-2-Zuul-限流"><a href="#8-2-Zuul-限流" class="headerlink" title="8.2 Zuul:限流"></a>8.2 Zuul:限流</h4><h5 id="8-2-1-限流基本理论"><a href="#8-2-1-限流基本理论" class="headerlink" title="8.2.1 限流基本理论"></a>8.2.1 限流基本理论</h5><ol>
<li>1.Zuul充当的是api网关的角色、每个请求都会经过它、在他上面做api限流保护、防止攻击。比如我们的api是发短信的、我们需要限制客户端请求速度、从而在一定程序上抵制短信大攻击、降低损失。</li>
<li><p>2.Zuul的限流是放在前置过滤器去做的、更具体来说、时机是在请求被转发之前调用。如果前置过滤器有多个操作、限流放到最靠前那个。比如:Zuul前置过滤器里面有限流、鉴权。那么限流应该早于鉴权。  </p>
</li>
<li><p>3.限流方案很多，这里以一种来说:令牌桶流。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/16.png" alt=""><br>a.中间桶(token bucket)：是存放令牌的、所以叫做令牌桶。<br>b.最上面会以固定的速率往令牌桶中添加令牌、如果已经放满了就丢掉。<br>c.外部请求过来、会从令牌桶中获取令牌、拿到令牌之后才可以继续往前走。如果拿不到令牌直接被拒绝。其实是和买房一样。 </p>
</li>
</ol>
<h5 id="8-2-2-限流代码实现"><a href="#8-2-2-限流代码实现" class="headerlink" title="8.2.2 限流代码实现"></a>8.2.2 限流代码实现</h5><p>限流也是一个Filter,我们以RateFilter<br>a.filterType–&gt;PRE_TYPE<br>b.filterOrder–&gt;优先级最高:优先级为最高:组件自带的优先级最高位-3 我们这边比他还高(SERVLET_DETECTION_FILTER_ORDER-1)  </p>
<h6 id="1-新建RateFilter类"><a href="#1-新建RateFilter类" class="headerlink" title="1.新建RateFilter类"></a>1.新建RateFilter类</h6><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/17.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/18.png" alt="">     </p>
<h4 id="8-3-Zuul-鉴权和添加用户服务"><a href="#8-3-Zuul-鉴权和添加用户服务" class="headerlink" title="8.3 Zuul:鉴权和添加用户服务"></a>8.3 Zuul:鉴权和添加用户服务</h4><h5 id="8-3-1-Zuul权限校验"><a href="#8-3-1-Zuul权限校验" class="headerlink" title="8.3.1 Zuul权限校验"></a>8.3.1 Zuul权限校验</h5><p>我们使用Zuul的权限校验实现下面3个功能。</p>
<ol>
<li>1./order/create 只能买家访问(创建订单)  </li>
<li>2./order/finish 只能卖家访问(完结订单) </li>
<li><p>3./product/list 都可以访问(商品列表)  </p>
</li>
<li><p>1.新建鉴权Filter(AuthFilter)<br>新建鉴权Filter、用来区分买家和卖家</p>
</li>
<li><p>2.实现逻辑<br>怎样区分买家和卖家呢?有些人想到cookie、既然想到了cookie那么必须买家和卖家登录了之后才能获取到信息。那么登录功能写到哪里了，就需要有一个用户服务。</p>
</li>
</ol>
<h5 id="8-3-2-添加用户服务"><a href="#8-3-2-添加用户服务" class="headerlink" title="8.3.2 添加用户服务"></a>8.3.2 添加用户服务</h5><ol>
<li>1.API接口登录区分<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/18.png" alt=""></li>
</ol>
<ol>
<li>2.数据库  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `user_info` (</div><div class="line">  `id` varchar(32) NOT NULL,</div><div class="line">  `username` varchar(32) DEFAULT &apos;&apos;,</div><div class="line">  `password` varchar(32) DEFAULT &apos;&apos;,</div><div class="line">  `openid` varchar(64) DEFAULT &apos;&apos; COMMENT &apos;微信openid&apos;,</div><div class="line">  `role` tinyint(1) NOT NULL COMMENT &apos;1买家2卖家&apos;,</div><div class="line">  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,</div><div class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;修改时间&apos;,</div><div class="line">  PRIMARY KEY (`id`)</div><div class="line">);</div><div class="line">```  </div><div class="line"></div><div class="line">userInfo中买家和卖家区分是根据:role字段。</div><div class="line"></div><div class="line">3. 3.创建应用  </div><div class="line">选择的依赖组件:</div><div class="line">1.配置:Cloud Config--&gt;Config Cient</div><div class="line">2.注册中心:Cloud Discovery--&gt;Eureka Discovery</div><div class="line">3.数据库:SQL--&gt;Mysql/JPA</div><div class="line">4.缓存:NoSQL--&gt;redis  </div><div class="line"></div><div class="line">4. 4.修改版本依赖</div><div class="line"></div><div class="line">5. 5.统一配置中心远端服务器创建user-dev.yml文件  </div><div class="line">我们只添加数据库连接信息和redis连接信息，其他信息在bootstrap.yml文件里面  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">6. 6.在config服务中访问:http://localhost:8083/user-dev.yml可以查看到对应文件</div><div class="line"></div><div class="line">7. 7.因为user服务后面肯定会对外提供接口的、所以我们将其改造成多模块  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/7.png)  </div><div class="line"></div><div class="line">8. 8.添加dataobject</div></pre></td></tr></table></figure>
<p>@Entity<br>public class UserInfo {<br>@Id<br>private String id;<br>private String username;<br>private String password;<br>private String openid;<br>private Integer role;<br>public String getId() {<br>    return id;<br>}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">9. 9.service和serviceImpl</div></pre></td></tr></table></figure></p>
<p>public interface UserService {<br>/**</p>
<ul>
<li>通过openid来查询用户信息</li>
<li>@param openid</li>
<li><p>@return<br>*/<br>UserInfo findByOpenid(String openid);<br>}<br>@Service<br>public class UserServiceImpl implements UserService {<br>@Autowired<br>private UserInfoRepository repository;<br>@Override<br>public UserInfo findByOpenid(String openid) {<br> return repository.findByOpenid(openid);<br>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">#### 8.3 Zuul:鉴权和添加用户服务  </div><div class="line">1. 1.拷贝ResultVOUtil、ResultEnum到user  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/8.png)    </div><div class="line">2. 2.书写买家登录:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/9.png)  </div><div class="line">3. 3.测试:  </div><div class="line">a.正确输入:![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/10.png)  </div><div class="line">b.错误输入:![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/11.png)  </div><div class="line">c.数据库角色修成成2:![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/12.png)    </div><div class="line"></div><div class="line">4. 4.往redis里面书写数据  </div><div class="line">买家登录时候先去redis里面找,如果有说明已经登录了,没有的话才设置cookie  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/13.png)  </div><div class="line"></div><div class="line">上面代码会出现一个问题,就是每次页面刷新,都会在redis里面写数据,导致很多脏数据产生,所以需要在卖家最前面添加判断。    </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/14.png)   </div><div class="line"> </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/15.png)    </div><div class="line"></div><div class="line">### 8.4 订单完结接口开发  </div><div class="line">我们在api-gateway的AuthFilter里面进行过滤校验时候:</div></pre></td></tr></table></figure>
<p>/**</p>
</li>
<li>1./order/create 只能买家访问</li>
<li>2./order/finish 只能卖家访问</li>
<li>3./product/list 都可以访问<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">分为以上3步,我们还差在Order服务中订单完结接口没有开发:&quot;/order/finish&quot;;我们现在实现此接。  </div><div class="line"></div><div class="line">### 8.5 权限校验完成  </div><div class="line"></div><div class="line">#### 8.5.1 权限基本操作  </div><div class="line"></div><div class="line">1. 1.先访问user(卖家登录:http://localhost:8085/login/seller?openid=xyz)    </div><div class="line">结果如下:    </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/16.png)  </div><div class="line">我们请求正常,并且也获取到cookie了,此时我们把cookie删掉.再次请求api-gateway(此时请求api-gateway的时候注释掉:TokenFilter中run认证)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/17.png)    </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/18.png)    </div><div class="line">以上返回的是成功,但是cookies中没有值,之前提过Zuul敏感头设置:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/19.png)    </div><div class="line"></div><div class="line">假如我们对所有服务都提供敏感头,都需要传递cookie,则:</div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/20.png)  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/21.png)    </div><div class="line">此时我们能够确保通过api-gateway是可以正常登录的。  </div><div class="line"></div><div class="line">2. 2.接下来我们书写AuthFilter中业务逻辑。  </div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/22.png)  </div><div class="line"></div><div class="line">下面我们通过接口去调用:  </div><div class="line"></div><div class="line">3. 3.我们通过postman创建订单(切记一定要加上order服务名)  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/23.png)  </div><div class="line">我们改掉:  </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/24.png)  </div><div class="line">我们再次请求时候回返回401：权限不足-&gt;所以我们需要先登录  </div><div class="line">注意:在postman中,每一个窗口是互相隔离的,我们在一个窗口中登录,在另一个窗口中也是不能请求过的。    </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/26.png)   </div><div class="line">所以我们自己需要写入一个cookie到postman中去    </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/25.png)  </div><div class="line"></div><div class="line">4. 4.上面我们使用if语句来判断不同授权用户,其实这种写法以后相当不好维护,如果用户很多,耦合进来判断,有一天假如对卖家放开不限制,那么只能删掉,如何改造呢?我们一般对卖家和买家各自做一个filter:</div><div class="line">a.拦截统一在shouldFilter方法中  </div><div class="line">b.拦截后处理统一在run方法中</div><div class="line"></div><div class="line">AuthBuyerFilter:      </div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2019/12/27.png) </div><div class="line"></div><div class="line">AuthSellerFilter也是类似。  </div><div class="line"></div><div class="line"></div><div class="line">#### 8.5.2 权限补充  </div><div class="line">  </div><div class="line">1. 1.大多数情况下,我们会把权限校验的uri存放到数据库中去,那是不是api-gateway直接去连接数据库进行判断呢?  </div><div class="line">这里牵涉到一个边界的问题,api-gateway要做的是网关,如果去连接user服务的数据库,显然是不合适的,那能不能去调用user服务呢?调用user服务是合理的,应该去调用,但是每次鉴权的时候去调用user服务,user服务那边又去调用数据库的话,这样对数据库压力很大,我们应该使用redis,api-gateway直接去redis里面获取用户权限，那么redis里面的数据怎样过来呢?可以像之前&quot;异步扣库存的方式-&gt;用户信息一变动,就发一个信息过来,网关这边监听消息,并记录到redis&quot;</div><div class="line"></div><div class="line">2. 2.微服务架构下对所有服务都得鉴权，每个服务都需要明确当前用户的权限,在Zuul的前置过滤器里面实现相关逻辑是一个值得考虑的方案,同时在微服务框架中,多个服务的无状态化一般会考虑两种技术方案:  </div><div class="line">a.分布式session(将用户认证信息存储在共享储存中,且通常用用户会话作为key来实现简单的分布式hash映射,当用户访问微服务时,用户数据可以从共享存储中获取,用户登录状态是不透明的,同时也是一个高可用且可扩展的解决方案)  </div><div class="line">b.OAuth2与Spring Security结合</div><div class="line"></div><div class="line">3. 3.我们这有一个细节:用户模块的utils代码一直在copy,相同的我们就拷贝过来,我们少了一个基础服务(如果公司是一个大型服务改造的话,基础服务比较容易,一目连然拆出来,但是是一个从头开发的项目,没有多大把握,类似我们现在,建议是将每个微服务的公用组件放到公用模块里面去,比如我们现在的user,order,product服务都有common模块,有了一定积累后,很自然的将这块代码剥离出来,作为公共组件,下沉,成为公共的一个服务)  </div><div class="line"></div><div class="line">4. 4.另外一点,在SpringCloud架构体系中的所有微服务都是通过Zuul对外提供统一访问入口,这个时候如果公司有两套系统,一套传统项目,一套微服务架构项目,让这两套项目在线上同时运行,Zuul会非常关键。  </div><div class="line"></div><div class="line">### 8.6 跨域  </div><div class="line">#### 8.6.1 跨域问题  </div><div class="line">1. 1.我们一般的大型项目都是前后端分离的,前端通过ajax发送请求,浏览器的ajax是有同源策略的,如果违反了同源策略就会有跨域问题,Zuul作为微服务的api网关,在它上面处理跨域也是一种选择。  </div><div class="line">2. 2.跨域其实可以看成是Spring的跨域,Spring跨域常用的一种方法是在:被调用的类或方法上增加@CrossOrigin注解来声明自己支持跨域访问,这种方式的缺点其实很明显,作用域在类或者方法上,微服务里面的应用就有很多个,一个应用里面的类和方法更加多  </div><div class="line">3. 3.解决跨域的另一种方法是:在Zuul里增加CorsFilter过滤器,此方案是添加到网关上,对内部应用代码没有任何改造。  </div><div class="line"></div><div class="line">#### 8.6.2 跨域改造 </div><div class="line"></div><div class="line">##### 1.单个接口跨域   </div><div class="line">1. 1.项目中跨域：我们在product服务里面的ProductController的list方法里面添加跨域注解:  </div><div class="line">allowCredentials = &quot;true&quot;-&gt;true允许cookie跨域</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@CrossOrigin(allowCredentials = “true”)<br>```</p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/29.png" alt="">  </p>
<h5 id="2-统一跨域设置"><a href="#2-统一跨域设置" class="headerlink" title="2.统一跨域设置"></a>2.统一跨域设置</h5><ol>
<li>1.在api-gateway上添加配置文件:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/12/30.png" alt="">  </li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/18/SpringCloud-8-Zuul综合使用/" class="archive-article-date">
  	<time datetime="2019-04-18T04:13:24.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-18</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-7-服务网管" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/17/SpringCloud-7-服务网管/">SpringCloud-7-服务网管</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-服务网关和Zuul"><a href="#1-服务网关和Zuul" class="headerlink" title="1.服务网关和Zuul"></a>1.服务网关和Zuul</h3><h4 id="1-1-为什么需要服务网关"><a href="#1-1-为什么需要服务网关" class="headerlink" title="1.1 为什么需要服务网关"></a>1.1 为什么需要服务网关</h4><p>假如没有网关服务,当前系统起了多个服务,比如：订单、广告、商品、支付、用户。等等…<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/38.png" alt=""> </p>
<p>那么客户端怎么调用呢?和每个服务一步步打交道、显然不现实。需要一个接收request请求的统一入口。充当这个角色的是服务网关。一旦有了服务网关,所有请求都通过他,所以我们需要了解他发挥什么作用,具备什么要素?<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/39.png" alt=""></p>
<h4 id="1-2-服务网关的作用"><a href="#1-2-服务网关的作用" class="headerlink" title="1.2 服务网关的作用"></a>1.2 服务网关的作用</h4><h5 id="1-稳定性、高可用"><a href="#1-稳定性、高可用" class="headerlink" title="1.稳定性、高可用"></a>1.稳定性、高可用</h5><p>保证24小时可用；网络瘫痪、系统全挂、不能提供外面的服务。 </p>
<h5 id="2-性能、并发性"><a href="#2-性能、并发性" class="headerlink" title="2.性能、并发性"></a>2.性能、并发性</h5><p>所有的请求都经过网关、所以网关的压力是巨大的、所以网关的性能也必须高。</p>
<h5 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3.安全性"></a>3.安全性</h5><p>要确保使用服务的安全、防止外部随意访问、比如金融行业、会进行通讯数据的加密措施。</p>
<h5 id="4-扩展性"><a href="#4-扩展性" class="headerlink" title="4.扩展性"></a>4.扩展性</h5><p>各种请求都经过网关服务、所以网关上大有文章可做、可进行扩展。<br>理论上、网关是处理各种非业务功能的绝佳场所。诸如:协议转发、防刷、流量管控、日志监控等。</p>
<h4 id="1-3-常用的网关方案"><a href="#1-3-常用的网关方案" class="headerlink" title="1.3 常用的网关方案"></a>1.3 常用的网关方案</h4><p>网关并非是微服务出来后的新鲜事物。业界成熟的网关服务有:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/40.png" alt=""><br>一代的Zuul在性能上确实没有优势、不能和nginx比较。当然，二代Zuul有较大的提升。</p>
<p>原始的点餐项目是如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/41.png" alt=""></p>
<ol>
<li>1.nginx在前,tomcat在后、nginx做了负载均衡和反向代理。现在我们可以让nginx发挥他负载均衡和反向代理的优势后面的tomcat可以换成Zuul  </li>
<li>2.项目改造过程中、合理利用原来的资源、发挥新加入事物的优势、因地制宜解决问题。<h4 id="1-4-Zuul的特点"><a href="#1-4-Zuul的特点" class="headerlink" title="1.4 Zuul的特点"></a>1.4 Zuul的特点</h4>Zuul相对nginx来说有所不足、但是作为SpringCloud完整微服务生态体系的前置网关服务是一个很不错的选择。有一种说法路由加过滤器等于Zuul<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/42.png" alt="">  </li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/43.png" alt=""><br>Zuul的组织架构图如下所示:<br>可以看到,过滤器之间是没有直接通信的,他们是通过Request Context进行数据通信的。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/44.png" alt="">  </p>
<p>Zuul的一次Http的生命周期:  </p>
<ol>
<li>1.Origin Server就是我们的业务服务。    </li>
<li>2.请求先过来之后会到pre filters这种类型的过滤器,比如我们的参数校验就可以在这里面来做。    </li>
<li>3.routing filters作用就是将http请求转发到Origin Server中去：如果重写http请求可以在这里面做。  </li>
<li>4.post filters 这个时候你已经拿到了返回的结果,这个时候如果你想对结果进行处理和加工,可以在这里面来做  </li>
<li>5.error Filters如果在前两个filter发生异常时候,就可以在error filter中进行全局异常处理。  </li>
</ol>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/45.png" alt=""> </p>
<h3 id="2-Zuul的使用"><a href="#2-Zuul的使用" class="headerlink" title="2.Zuul的使用"></a>2.Zuul的使用</h3><ol>
<li>1.新建项目api-gateway<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/46.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/47.png" alt=""> </li>
<li>2.选择依赖<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/48.png" alt="">   </li>
<li>3.删除不需要的文件<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/49.png" alt="">   </li>
<li>4.修改版本一致<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/50.png" alt=""></li>
<li>5.修改配置文件(从统一配置文件中获取配置信息)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/51.png" alt=""></li>
</ol>
<h4 id="2-1-路由转发"><a href="#2-1-路由转发" class="headerlink" title="2.1 路由转发"></a>2.1 路由转发</h4><p>我们现在实现Zuul的路由转发功能,我们在api-gateway项目的启动类上添加:@EnableZuulProxy。我们现在要实现product服务下请求里面的/product/list</p>
<ol>
<li><p>1.启动我们的product服务(8081端口),然后访问:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/52.png" alt="">  </p>
</li>
<li><p>2.通过Zuul服务(8084端口)路由转发请求:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/53.png" alt=""><br>只要注册到Eureka上的服务都可以通过:ip:port/服务名/url  </p>
</li>
</ol>
<ol>
<li><p>3.自定义Zuul路由转发地址<br>以上我们是通过默认的路由转发、默认的地址是:ip:port/服务名/url。但是有时候我们不想把服务名暴露出来 而是想用自己定义的路由地址。此时就需要配置Zuul了。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/55.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/54.png" alt="">  </p>
</li>
<li><p>4.查询Zuul的所有routes,我们可以通过Zuul对应的服务api-gateway启动地址:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/117.png" alt="">  </p>
</li>
</ol>
<ol>
<li>5.我们如果想要拦截某些请求<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/1.png" alt=""> </li>
</ol>
<h4 id="2-3-Cookie和动态路由"><a href="#2-3-Cookie和动态路由" class="headerlink" title="2.3 Cookie和动态路由"></a>2.3 Cookie和动态路由</h4><h5 id="2-3-1-Cookie"><a href="#2-3-1-Cookie" class="headerlink" title="2.3.1 Cookie"></a>2.3.1 Cookie</h5><p>我们在开发搭建web项目的时候,经常要使用cookie,需要把cookie返回到后端。在这里使用了Zuul组件、默认情况下Cookie是无法传递过去的。如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/3.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/2.png" alt=""><br>我们从Zuul的配置中可以设置cookie的开启和关闭<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/4.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/5.png" alt="">  </p>
<h5 id="2-3-2-动态路由"><a href="#2-3-2-动态路由" class="headerlink" title="2.3.2 动态路由"></a>2.3.2 动态路由</h5><p>我们能不能改了路由配置之后自动生效了,就是动态路由。如果需要达到动态路由效果。我们只需要将api-gateway的配置放到config配置中心中去。我们如何做到config统一配置中配置改变了我们的api-gateway服务也动态改变了代码。我们添加Zuul的配置类。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/6.png" alt="">  </p>
<h4 id="2-4-路由和高可用小结"><a href="#2-4-路由和高可用小结" class="headerlink" title="2.4 路由和高可用小结"></a>2.4 路由和高可用小结</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/07/7.png" alt="">  </p>
<h5 id="2-4-1-典型应用场景"><a href="#2-4-1-典型应用场景" class="headerlink" title="2.4.1 典型应用场景"></a>2.4.1 典型应用场景</h5><ol>
<li><p>1.Zuul的前置过滤器(Pre)<br>a.限流   b.鉴权    c.参数校验调整   d.请求转发  </p>
</li>
<li><p>2.Zuul的后置过滤器(Post)<br>人过留名<br>a.统计  b.日志  </p>
</li>
</ol>
<h5 id="2-4-2-高可用"><a href="#2-4-2-高可用" class="headerlink" title="2.4.2 高可用"></a>2.4.2 高可用</h5><p>所有的请求都需要经过Zuul、所以生产环境中、我们需要部署多台Zuul,以避免单点故障。Zuul的高可用是必须的。  </p>
<ol>
<li>1.多个Zuul节点注册到Eureka Server(将多个节点注册到Eureka Server就可以实现高可用)  </li>
<li>2.Nginx和Zuul “混搭”(使用nginx对外暴露一个url,nginx把请求转发到多个zuul服务上、这样可以做到彼此的取长补短)。</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/17/SpringCloud-7-服务网管/" class="archive-article-date">
  	<time datetime="2019-04-17T03:01:28.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-17</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringCloud-6-消息和异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/SpringCloud-6-消息和异步/">SpringCloud-6-消息和异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-异步和消息"><a href="#1-异步和消息" class="headerlink" title="1.异步和消息"></a>1.异步和消息</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><ol>
<li>1.之前我们使用的方式是同步方式。</li>
<li>2.异步优点:a.客户端请求不会阻塞进程、服务端的相应可以是非及时的。  </li>
<li>3.http常见是支持同步、但是http也是支持异步的。</li>
</ol>
<h4 id="2-异步的常见形态"><a href="#2-异步的常见形态" class="headerlink" title="2.异步的常见形态"></a>2.异步的常见形态</h4><ol>
<li>1.通知</li>
<li>2.请求/异步响应:客户端发送请求到服务端,服务端异步响应,客户端不会阻塞,服务端默认不会立马响应。    </li>
<li><p>3.消息</p>
<h4 id="3-MQ应用场景"><a href="#3-MQ应用场景" class="headerlink" title="3.MQ应用场景"></a>3.MQ应用场景</h4><p>MQ是分布式应用系统最常用的组件。典型应用场景有如下:</p>
</li>
<li><p>1.异步处理:用户注册之后,通过短信服务、积分服务去做他们相应的操作,这样就能提高用户体验。  </p>
</li>
<li>2.流量消峰:一般用于秒杀场景,秒杀过程中一般由于流量较大,会导致应用会挂掉、要解决这个问题。把请求放在消息队列中,如果超过消息队列的长度将抛弃此请求,返回错误信息。 </li>
<li>3.日志处理：这个典型的组件就是kafka，kafka最初的设计就是用于日志处理,大数据里面用的特别多。通过日志采集、定时写入kafka队列，然后kafka队列定时接收 储存 和转发。</li>
<li>应用解耦：比如用户下单后,订单服务需要通知商品服务、之前是订单服务通过调用商品服务的接口,这样订单服务和商品服务是耦合的。使用mq,用户下单后，订单服务完成持续化处理、将消息写入消息队列、返回用户订单下单成功、商品服务来订阅这个消息采用拉或者推形式获取下单信息、商品服务获取到下单信息后进行商品的扣库存等操作。这样达到应解耦。  </li>
</ol>
<h3 id="2-RabbitMQ的基本使用"><a href="#2-RabbitMQ的基本使用" class="headerlink" title="2.RabbitMQ的基本使用"></a>2.RabbitMQ的基本使用</h3><p>我们Order服务使用RabbitMQ实现订单和商品服务解耦。  </p>
<ol>
<li>1.添加热rabbitmq依赖-在order服务中server子模块添加以下依赖:  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ol>
<li><p>2.添加配置到github远程仓库<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/94.png" alt="">  </p>
</li>
<li><p>3.创建MQ消息接收方<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/95.png" alt="">  </p>
</li>
<li><p>4.创建mq发送方进行测试<br>我们在测试test文件目录下创建测试类:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/97.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/96.png" alt=""> </p>
</li>
</ol>
<p>测试出现了上面问题,原因是因为没有myQueue队列<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/05/98.png" alt=""><br>此时正常启动。  </p>
<p>这个时候一切正常。  </p>
<ol>
<li>5.以上是我们自己在RabbitMQ中创建的队列。我们是否可以自动创建队列,然后再调用队列接口。  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@RabbitListener(queuesToDeclare = @Queue(&quot;myQueue1&quot;)) //自动创建队列myQueue1</div></pre></td></tr></table></figure>
<ol>
<li>6.自动创建并且和队列绑定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@RabbitListener(bindings =@QueueBinding(value =@Queue(&quot;myQueue&quot;),exchange =@Exchange(&quot;myExchange&quot;)))</div></pre></td></tr></table></figure>
<h4 id="2-2-什么情况下需要用到exchange"><a href="#2-2-什么情况下需要用到exchange" class="headerlink" title="2.2 什么情况下需要用到exchange"></a>2.2 什么情况下需要用到exchange</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/1.png" alt="">  </p>
<p>我们现在是一个小小点餐系统,但是如果后面,我们什么都卖,又卖水果,又卖数码,同时对这两种商品下单,商品变多了,人也多了，订单服务是单独的人来维护,数码供应商、水果供应商都是由单独的人来维护。订单服务要根据不同的商品类型发出不同的MQ消息。相对应的、数码供应商只关注数码订单、水果及其他订单不关注。此时就牵涉到消息的分组。 演示如下:<br>1.我们接收方模拟两个接收服务(a.数码服务 b.水果服务)<br>exchange因为都是订单,我们我们叫做myOrder<br>想要分组归类,我们用key<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/2.png" alt="">  </p>
<p>2.我们发送方 (类似订单服务)如下:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/3.png" alt="">  </p>
<h3 id="3-SpringCloudStream的使用"><a href="#3-SpringCloudStream的使用" class="headerlink" title="3.SpringCloudStream的使用"></a>3.SpringCloudStream的使用</h3><p>可以参数博客:<a href="https://www.cnblogs.com/zhixiang-org-cn/p/10093367.html" target="_blank" rel="external">https://www.cnblogs.com/zhixiang-org-cn/p/10093367.html</a> </p>
<h4 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1.基本介绍"></a>3.1.基本介绍</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/4.png" alt="">    </p>
<ol>
<li>1.应用模型:应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream 中Binder 交互，通过我们配置来绑定，而 Spring Cloud Stream 的 Binder 负责与中间件交互。所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。  </li>
<li><p>2.抽象绑定器(The Binder Abstraction):Spring Cloud Stream实现Kafkat和RabbitMQ的Binder实现，也包括了一个TestSupportBinder，用于测试。你也可以写根据API去写自己的Binder.Spring Cloud Stream 同样使用了Spring boot的自动配置，并且抽象的Binder使Spring Cloud Stream的应用获得更好的灵活性，比如：我们可以在application.yml或application.properties中指定参数进行配置使用Kafka或者RabbitMQ，而无需修改我们的代码。  </p>
</li>
<li><p>3.Binder(SpringCloudStream)是应用程序(Application)和消息中间件(Middleware)之间的粘合剂，使用 SpringCloudStream最大的好处莫过于对消息中间件的进一步封装。可以做到代码层面对消息中间件的无感知,设置于动态的切换中间件,但是也有局限:目前SpringCloudStream仅支持2种Binder：一种是RabbitMQ、另一种是Kafka  </p>
</li>
</ol>
<h4 id="3-2-使用SpringCloudStream"><a href="#3-2-使用SpringCloudStream" class="headerlink" title="3.2.使用SpringCloudStream"></a>3.2.使用SpringCloudStream</h4><p>为了详细了解SpringCloudStream的话,可以详细了解下:<a href="https://www.cnblogs.com/leeSmall/p/8900518.html这篇博文。" target="_blank" rel="external">https://www.cnblogs.com/leeSmall/p/8900518.html这篇博文。</a>  </p>
<h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h5><p>在order-server.xml中添加如下依赖:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h5 id="2-添加mq的配置"><a href="#2-添加mq的配置" class="headerlink" title="2.添加mq的配置"></a>2.添加mq的配置</h5><p>之前我们已经配置过了,这里可以省略  </p>
<h5 id="3-使用stream发送和接收消息"><a href="#3-使用stream发送和接收消息" class="headerlink" title="3.使用stream发送和接收消息"></a>3.使用stream发送和接收消息</h5><ol>
<li>1.定义接口:提供输入输出接口  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface StreamClient &#123;</div><div class="line">@Input(&quot;myMessage&quot;)</div><div class="line">SubscribableChannel input();</div><div class="line">@Input(&quot;myMessage&quot;)</div><div class="line">MessageChannel output();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>2.添加stream接收端  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">@EnableBinding(StreamClient.class)</div><div class="line">@Slf4j</div><div class="line">public class StreamReceiver &#123;</div><div class="line">@StreamListener(&quot;myMessage&quot;)</div><div class="line">public void process(Object message)&#123;</div><div class="line">  log.info(&quot;StreamReceiver:&#123;&#125;&quot;,message);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>3.添加stream发送端  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">public class SendMessageController &#123;</div><div class="line">@Autowired</div><div class="line">private StreamClient streamClient;</div><div class="line">@GetMapping(&quot;/sendMessage&quot;)</div><div class="line">public void process()&#123;</div><div class="line">    String message = &quot;now &quot; + new Date();</div><div class="line">    streamClient.output().send(MessageBuilder.withPayload(message).build());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>4.测试<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/5.png" alt=""><br>有时候我们后端启用2个order服务,然后重启后 客户端发送消息,发现2个都接收到了,那么我们如何多集群情况下,只有一个实例接收消息呢?<br>stream里面有个分组,我们配置一下就可以了 那就是使用分组。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/10.png" alt="">  </li>
</ol>
<h5 id="3-使用stream传递对象"><a href="#3-使用stream传递对象" class="headerlink" title="3.使用stream传递对象"></a>3.使用stream传递对象</h5><p>之前我们在用例中stream传递的是String、实际工作中stream更重要的是传递对象。<br>生产者:发送OrderDetail对象<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/11.png" alt="">    </p>
<p>消息接受者:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/12.png" alt="">  </p>
<p>下面我们看一下:mq里面接收的是什么格式数据呢?<br>我们在上面看不到消息了,原因是消息已经被消费完了,所以我们需要把接收端,消费消息的停掉。让mq端有消息的累计。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/13.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/14.png" alt="">   </p>
<p>上面我们可以看到消息是:OrderDTO对象,如果我们需要在MQ中获取的消息是json格式:则在stream的配置中添加：content-type: application/json<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/16.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/15.png" alt="">    </p>
<p>有时候我们的消费者：StreamReceiver消费完消息之后,我们需要给发送者一个通知,传统的做法是在业务逻辑里面后面做处理。<br>现在我们加上注解即可:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/17.png" alt="">  </p>
<p>总结:使用Stream可以降低对消息中间件的复杂度,让开发者更多的关注业务开发。  </p>
<h3 id="4-商品和订单服务中使用MQ"><a href="#4-商品和订单服务中使用MQ" class="headerlink" title="4.商品和订单服务中使用MQ"></a>4.商品和订单服务中使用MQ</h3><h4 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h4><p>我们结合点餐业务来使用mq<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/18.png" alt="">  </p>
<ol>
<li>1.之前我们按照上面图提示到:一旦有库存的变化(商品)、都会发布一个消息、订单拿到这个消息之后,会把库存的消息记录到自己的服务里面(这里我们把他记录到redis里面)</li>
<li>2.导致库存的变化有很多种:a.第一次商品上线的时候,会填写库存,这个时候库存就变化了。b.还有就是货物快卖完的时候需要补货。相当于加库存。我们以扣库存为例,使用消息队列进行通信。</li>
</ol>
<h4 id="4-2-product服务接入到配置中心"><a href="#4-2-product服务接入到配置中心" class="headerlink" title="4.2 product服务接入到配置中心"></a>4.2 product服务接入到配置中心</h4><ol>
<li>1.添加配置中心的依赖<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/19.png" alt="">  </li>
<li><p>2.修改appliaction.yml文件为:bootstrap.yml文件,并修改其中的配置<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/21.png" alt=""> </p>
</li>
<li><p>3.在github上建立对应的product-dev.yml文件,并将共有的信息拷贝到里面去<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/20.png" alt=""> </p>
</li>
<li>4.在config服务中看是否可以访问到此配置文件。  </li>
<li>5.启动时候正常启动:说明我们已经把product服务接入到配置中心了。  </li>
</ol>
<h4 id="4-3-product服务在扣库存时候发送队列消息"><a href="#4-3-product服务在扣库存时候发送队列消息" class="headerlink" title="4.3 product服务在扣库存时候发送队列消息"></a>4.3 product服务在扣库存时候发送队列消息</h4><ol>
<li><p>1.添加springBoot里面的amqp依赖<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/22.png" alt=""> </p>
</li>
<li><p>2.在统一配置中心中添加mq的连接信息<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/23.png" alt="">  </p>
</li>
</ol>
<h4 id="4-4-product服务在扣库存地方操作消息队列"><a href="#4-4-product服务在扣库存地方操作消息队列" class="headerlink" title="4.4 product服务在扣库存地方操作消息队列"></a>4.4 product服务在扣库存地方操作消息队列</h4><p>我们在扣库存的service中添加扣库存(decreaseStock)后消息通知:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/24.png" alt="">  </p>
<p>然后我们使用postman测试:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/25.png" alt=""><br>数据库里面的库存从33变成32,数据库扣除成功了<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/26.png" alt=""><br>但是我们登录mq的管理后端却发现没有对应的amqpTemplate的productInfo队列，<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/27.png" alt=""><br>为什么没有这个队列呢?原因是因为我们压根就没有创建队列，只有在接收方添加注解:@RabbitListener注解才会自动创建，我们 上面只有发送方,所以我们先手动创建下:然后点几次发送,后面发现我们在消息队列中有了相应的消息:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/28.png" alt=""></p>
<p>以上就完成了消息的发送,现在消息已经从商品服务发送到消息队列里面了,接下来我们要在订单服务接收消息。<br>在Order服务的message包下面添加接收消息:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/29.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/30.png" alt="">  </p>
<p>我们先删除之前的productInfo队列,然后重启服务会发现会自动创建队列<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/31.png" alt=""> </p>
<h4 id="4-5-Order服务获取到扣库存信息存储到redis"><a href="#4-5-Order服务获取到扣库存信息存储到redis" class="headerlink" title="4.5 Order服务获取到扣库存信息存储到redis"></a>4.5 Order服务获取到扣库存信息存储到redis</h4><p>我们order服务获取到了product服务发送的信息,现在需要把这些信息存储到redis中<br>redis可以使用docker安装、也可以使用自己免安装的版本  </p>
<ol>
<li>1.项目中引入依赖(order-server中pom.xml)  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ol>
<li>2.配置redis里面的参数,在统一配置中心添加  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  redis:</div><div class="line">    host: localhost</div><div class="line">    port: 6379</div></pre></td></tr></table></figure>
<ol>
<li><p>3.书写存储到redis(使用StringRedisTemplate)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/32.png" alt=""> </p>
</li>
<li><p>4.postman测试<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/33.png" alt=""> </p>
</li>
</ol>
<h4 id="4-6-残留的问题"><a href="#4-6-残留的问题" class="headerlink" title="4.6 残留的问题"></a>4.6 残留的问题</h4><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/34.png" alt="">  </p>
<ol>
<li>1.从上面我们知道:扣库存是遍历了商品,然后操作数据库,再然后就是发送mq消息,假如decreaseStockInputList长度大于1,我们第一件商品扣库存之后、发送消息到mq,但是第二件商品报了异常,由于有事务,数据库会回滚,但是mq里面的消息不会回滚,所有有脏数据。</li>
<li>2.我们修改下,我们在数据库扣完库存之后再发mq消息<br>Product服务修改:  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void decreaseStock(List&lt;DecreaseStockInput&gt; decreaseStockInputList) &#123;</div><div class="line">    //1.获取到扣库存列表</div><div class="line">    List&lt;ProductInfo&gt; productInfoList = decreaseStockProcess(decreaseStockInputList);</div><div class="line">    //2.转换成ProductInfoOutput列表</div><div class="line">    List&lt;ProductInfoOutput&gt; productInfoOutputList = productInfoList.stream().map(e -&gt; &#123;</div><div class="line">        ProductInfoOutput output = new ProductInfoOutput();</div><div class="line">        BeanUtils.copyProperties(e, output);</div><div class="line">        return output;</div><div class="line">    &#125;).collect(Collectors.toList());</div><div class="line">    //3.发送mq消息</div><div class="line">    amqpTemplate.convertAndSend(&quot;productInfo&quot;, JsonUtil.toJson(productInfoOutputList));</div><div class="line">&#125;</div><div class="line">@Transactional(rollbackFor = Exception.class)</div><div class="line">public List&lt;ProductInfo&gt;  decreaseStockProcess(List&lt;DecreaseStockInput&gt; decreaseStockInputList) &#123;</div><div class="line">    /**</div><div class="line">     * 遍历:查看是否存在</div><div class="line">     */</div><div class="line">    List&lt;ProductInfo&gt; productInfoList = new ArrayList&lt;&gt;();</div><div class="line">    for (DecreaseStockInput cartDTO:decreaseStockInputList)&#123;</div><div class="line">        Optional&lt;ProductInfo&gt; productInfoOptional = repository.findById(cartDTO.getProductId());</div><div class="line">        //商品不存在</div><div class="line">        if(!productInfoOptional.isPresent())&#123;</div><div class="line">            throw new ProductException(ResultEnum.PRODUCT_NOT_EXIST);</div><div class="line">        &#125;</div><div class="line">        //商品存在-库存错误</div><div class="line">        ProductInfo productInfo = productInfoOptional.get();</div><div class="line">        int result = productInfo.getProductStock() - cartDTO.getProductQuantity();</div><div class="line">        if(result&lt;0)&#123;</div><div class="line">            throw new ProductException(ResultEnum.PRODUCT_STOCK_ERROE);</div><div class="line">        &#125;</div><div class="line">        //保存</div><div class="line">        productInfo.setProductStock(result);</div><div class="line">        repository.save(productInfo);</div><div class="line">        productInfoList.add(productInfo);</div><div class="line">    &#125;</div><div class="line">    return productInfoList;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Order服务修改:<br>JsonUtil添加如下方法:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2019/06/35.png" alt="">  </p>
<h3 id="5-异步和库存分析"><a href="#5-异步和库存分析" class="headerlink" title="5.异步和库存分析"></a>5.异步和库存分析</h3><p>项目改造成异步后,数据一致性等问题是经常遇到的,很多时候在单体服务中,依靠本地事务,我们很容易保证数据的一致性。但是一旦切换到分布式异步情况下就很可能出现数据不一致的情况。比如这里的发消息,数据库回滚数据是自动的。消息多发了要怎么办？这个就需要重新仔细考虑,稍不留神机会出错。下面我们以下面通路进一步看下更多考虑的点。<br>参考一下链接:<a href="https://cloud.tencent.com/developer/article/1344252" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1344252</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/04/16/SpringCloud-6-消息和异步/" class="archive-article-date">
  	<time datetime="2019-04-16T01:12:08.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-04-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/ElasticStack/" style="font-size: 10px;">ElasticStack</a> <a href="/tags/SpringCloud/" style="font-size: 20px;">SpringCloud</a> <a href="/tags/SpringCloudAlibaba/" style="font-size: 10px;">SpringCloudAlibaba</a> <a href="/tags/acdgate/" style="font-size: 10px;">acdgate</a> <a href="/tags/ipcc/" style="font-size: 16.67px;">ipcc</a> <a href="/tags/problem/" style="font-size: 10px;">problem</a> <a href="/tags/work/" style="font-size: 13.33px;">work</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>