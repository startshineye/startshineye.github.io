<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/page/10/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-vue-31-bower简单使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/vue-31-bower简单使用/">vue(31)-bower简单使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>Bower:客户端技术的软件包管理器(前端包管理器)</p>
<h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><p>可用于搜索、安装和卸载如JavaScript、HTML、CSS之类的网络资源。其他一些建立在Bower基础之上的开发工具，如YeoMan和Grunt。  </p>
<h5 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h5><p>想要使用bower需要:<br>1.安装node环境:node.js<br>2.安装Git:bower从远程git仓库获取代码包  </p>
<h5 id="3-安装bower"><a href="#3-安装bower" class="headerlink" title="3.安装bower"></a>3.安装bower</h5><p>安装:npm install bower -g (其中-g命令表示全局安装)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/32.png" alt=""><br>验证安装与否:bower -version<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/33.png" alt=""></p>
<h5 id="4-开始使用"><a href="#4-开始使用" class="headerlink" title="4.开始使用"></a>4.开始使用</h5><h5 id="4-1-查看bower所有命令及其含义"><a href="#4-1-查看bower所有命令及其含义" class="headerlink" title="4.1 查看bower所有命令及其含义"></a>4.1 查看bower所有命令及其含义</h5><p>bower help<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/34.png" alt=""> </p>
<h5 id="5-包的安装-bower-install-包名"><a href="#5-包的安装-bower-install-包名" class="headerlink" title="5.包的安装 bower install 包名"></a>5.包的安装 bower install 包名</h5><p>下面以安装jquery为例；<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/35.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/36.png" alt=""></p>
<h5 id="6-包的信息-bower-info-包名"><a href="#6-包的信息-bower-info-包名" class="headerlink" title="6.包的信息 bower info 包名"></a>6.包的信息 bower info 包名</h5><p>会看到jquery的bower.json的信息，和可用的版本信息<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/37.png" alt="">  </p>
<h5 id="7-包的卸载-bower-uninstall-包名"><a href="#7-包的卸载-bower-uninstall-包名" class="headerlink" title="7.包的卸载 bower uninstall 包名"></a>7.包的卸载 bower uninstall 包名</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/38.png" alt=""><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/39.png" alt=""><br>可以看到清空了</p>
<h5 id="8-下载特定版本"><a href="#8-下载特定版本" class="headerlink" title="8.下载特定版本"></a>8.下载特定版本</h5><p>bower install 包名@版本号</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/24/vue-31-bower简单使用/" class="archive-article-date">
  	<time datetime="2017-09-24T04:11:57.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-30-npm介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/vue-30-npm介绍/">vue(30)-nmp介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： </p>
<ol>
<li>从NPM服务器下载别人编写的第三方包到本地使用  </li>
<li>从NPM服务器下载并安装别人编写的命令行程序到本地使用</li>
<li>将自己编写的包或命令行程序上传到NPM服务器供别人使用</li>
</ol>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-测试安装成功与否"><a href="#1-测试安装成功与否" class="headerlink" title="1.测试安装成功与否"></a>1.测试安装成功与否</h5><p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/24/vue-30-npm介绍/" class="archive-article-date">
  	<time datetime="2017-09-24T03:53:02.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-30-nmp介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/vue-30-nmp介绍/">vue(30)-npm介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： </p>
<ol>
<li>从NPM服务器下载别人编写的第三方包到本地使用  </li>
<li>从NPM服务器下载并安装别人编写的命令行程序到本地使用</li>
<li>将自己编写的包或命令行程序上传到NPM服务器供别人使用</li>
</ol>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-测试安装成功与否"><a href="#1-测试安装成功与否" class="headerlink" title="1.测试安装成功与否"></a>1.测试安装成功与否</h5><p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/31.png" alt="">  </p>
<p>如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：  </p>
<pre><code>$ sudo npm install npm -g
/usr/local/bin/npm -&gt; /usr/local/lib/node_modules/npm/bin/npm-cli.js
npm@2.14.2 /usr/local/lib/node_modules/npm
</code></pre><p>如果是 Window 系统使用以下命令即可： </p>
<pre><code>//一般命令
npm install npm -g
//使用淘宝镜像命令
cnpm install npm -g
</code></pre><h5 id="2-使用npm命令安装模块"><a href="#2-使用npm命令安装模块" class="headerlink" title="2.使用npm命令安装模块"></a>2.使用npm命令安装模块</h5><p>$ npm install <module name="">  </module></p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/32.png" alt=""><br>查看安装成功与否<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/33.png" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/24/vue-30-nmp介绍/" class="archive-article-date">
  	<time datetime="2017-09-24T03:53:02.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-29-vue-loader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/vue-29-vue-loader/">vue(29)-vue-loader</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>至此,我们的vue的基本知识已经说完了,但是开发工作中大部分vue都不是这样用的,而是使用vue-loader  </p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h5><ol>
<li><p>vue-loader:其实我们还听说过其他loader:比如:css-loader,url-loader,html-loader…</p>
</li>
<li><p>还有我们经常熟悉的webpack,webpack现如今是比较火的,很多开源的框架都是基于他来做的  </p>
</li>
<li><p>webpack:模块加载器,一切东西都是模块  </p>
</li>
<li><p>vue-loader是基于webppack    </p>
</li>
<li><p>我们一般都比较熟悉例如:.js,.html,.css…文件，但是很少交过.vue文件,.vue文件浏览器是读不懂的,如果我们需要让浏览器读懂,所以我们需要使用vue-loader文件  </p>
</li>
<li><p>.vue文件是需要是使用vue-loader,vue-loader通过webpack编译成浏览器能懂的文件.  </p>
</li>
</ol>
<ol>
<li><p>.vue文件一般存放内容:  </p>
<p> <template>html</template>   <style>css</style>   <script>js(平常代码,ES6代码)</script><br> //ES6代码需要通过babel-loader编译成ES5代码  </p>
</li>
</ol>
<h5 id="2-搭建vue-loader"><a href="#2-搭建vue-loader" class="headerlink" title="2.搭建vue-loader"></a>2.搭建vue-loader</h5><h6 id="2-1vue-loader需要的文件准备"><a href="#2-1vue-loader需要的文件准备" class="headerlink" title="2.1vue-loader需要的文件准备"></a>2.1vue-loader需要的文件准备</h6><p>vue-loader文件是基于webpack,所以需要一个webpack.config.js文件<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/40.png" alt="">  </p>
<p>package.json 用npm init –yes 生成<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/41.png" alt=""><br>其他手动生成  </p>
<h6 id="2-2-简单配置"><a href="#2-2-简单配置" class="headerlink" title="2.2 简单配置"></a>2.2 简单配置</h6><p>vue-loader开发模式和单独通过<script> src开发是不一样的  </p>
<p>比如在index.html中写入:</p>
<pre><code>&lt;app&gt;&lt;/app&gt;
</code></pre><p>app是一个组件,但是app怎么就能展示了,肯定是需要入口的。就是main.js,但是可自定义很多.js文件,那么怎样知道哪个.js是入口文件呢?则是通过webpack里面的配置.</p>
<p>webpack简单配置如下:<br>     //module.exports声明导出模块<br>     module.exports={<br>         entry:’./main.js’,//声明入口文件<br>         output:{//出口<br>            path:_dirname,//当前路径<br>           filename:’build.js’//将App.vue里面内容统一打包成一个模块<br>          }<br>     }</p>
<p>打包 成的build.js需要在index.html里面引入:  </p>
<pre><code>&lt;!--引入打包文件--&gt;
&lt;script src=&quot;build.js&quot;&gt;&lt;/script&gt;
</code></pre><h6 id="3-main-js修改"><a href="#3-main-js修改" class="headerlink" title="3.main.js修改"></a>3.main.js修改</h6><p>引入App:</p>
<pre><code>import App from &apos;./App.vue&apos; 
</code></pre><p>import是ES6里面的引入方式<br>ES6：模块化开发<br>   导出模块:<br>     export default{}<br>   引入模块:<br>     import 模块名 from 地址</p>
<h6 id="4-webpack准备"><a href="#4-webpack准备" class="headerlink" title="4.webpack准备"></a>4.webpack准备</h6><p>1.下载<br>  cnpm install webpack  -&gt;不带服务器版本<br>  cnpm install webpack-dev-server  -&gt;带服务器版本<br>  cnpm install webpack –sava-dev  -&gt;将下载的版本依赖添加到json文件 </p>
<p>2.运行  </p>
<p>npm run dev</p>
<p>以上webpack已经下载,webpack的config配置文件也已经有了,正常情况下运行是在gitbash里面直接运行:<br>webpack-dev-server  </p>
<p>热部署:<br>webpack-dev-server –inline –hot –port<br>每次这样写会累死,所以我们需要在package.json里面配置:</p>
<pre><code>{
  &quot;name&quot;: &quot;vue-loader-demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --port 8002&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre><p>然后运行:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/46.png" alt=""></p>
<p>在App.vue中加入:  </p>
<pre><code>&lt;template&gt;
&lt;h1&gt;welcome to vue-loader&lt;/h1&gt;
&lt;/template&gt;

&lt;script&gt;

&lt;/script&gt;

&lt;style&gt;

&lt;/style&gt;
</code></pre><p>从中可以知道叫我们访问:localhost:80002<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/47.png" alt=""></p>
<p>说明我们所需要的模块不仅仅需要:webpack还需要解析App.vue</p>
<p>App.vue   -&gt;想要变成正常代码    使用vue-loader  </p>
<h6 id="5-vue-loader准备"><a href="#5-vue-loader准备" class="headerlink" title="5.vue-loader准备"></a>5.vue-loader准备</h6><p>App.vue   -&gt;想要变成正常代码    需要使用vue-loader  </p>
<p>首先为了解析需要在webpack.config.js里面配置,其实webpack.config.js里面重要的不是entry,output,而是配module中的loader</p>
<pre><code>{test:/\.vue$/,loader:&apos;vue&apos;}// \.是转义 vue$/以vue结尾,loader用vue-loader，可以省略为vue 多个用&apos;!&apos;连接 比如:vue!css
</code></pre></script></p>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/24/vue-29-vue-loader/" class="archive-article-date">
  	<time datetime="2017-09-24T02:48:58.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-28-vue-router" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/19/vue-28-vue-router/">vue(28)-vue-router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol>
<li>vue是MVVP框架,vue是SPA应用(单页面应用)</li>
<li>vue-router:路由:根据不同url地址,出现不同效果</li>
<li>使用vue-router需要下载:vue-router.js </li>
<li>路由是基于:0.7.13   </li>
</ol>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>1.单应用页面为:主页 home 新闻页 news<br>2.对于<a></a>属性href在vue时候是不可用了,vue-router提供了v-link<br>3.v-link={path:url}<br>4.点击v-link所在标签时候,跳转显示的页面用<router-view></router-view><br>5.转转的连接：v-link 展示内容<router-view></router-view><br>6.必须要一个根组件:以上home和news本身也是一个组件</p>
<h5 id="1-简单入门"><a href="#1-简单入门" class="headerlink" title="1.简单入门"></a>1.简单入门</h5><p>需求：准备两个组件 主页 新闻 点击主页 新闻时候跳转到对应的主页和新闻的view(单页面应用)  </p>
<p>view:  </p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
&lt;!--点击部分 --&gt;
&lt;ul&gt;
    &lt;li&gt;
        &lt;a v-link=&quot;{path:&apos;/home&apos;}&quot;&gt;主页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a v-link=&quot;{path:&apos;/news&apos;}&quot;&gt;新闻&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;!--展示视图--&gt;
&lt;div&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>model:</p>
<pre><code>//1.准备根组件
   var App = Vue.extend();
 //2.Home,News组件
 var Home = Vue.extend({
     template:&quot;&lt;h3&gt;我是主页&lt;/h3&gt;&quot;
 });
 var  News = Vue.extend({
     template:&quot;&lt;h3&gt;我是新闻&lt;/h3&gt;&quot;
 });
 //3.准备路由
 var router = new VueRouter();
 //4.关联
 router.map({
     &apos;home&apos;:{
         component:Home
     },
     &apos;news&apos;:{
         component:News
     }
 });
 //5.启动路由
 router.start(App,&apos;#box&apos;);//绑定到哪个根路由(App)的哪个容器(box)
</code></pre><p>测试:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/17.gif" alt=""></p>
<h5 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2.跳转"></a>2.跳转</h5><p>当我们一打开上面的文件时候,页面初始化时并没有跳转(页面没有任何跳转)<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/26.png" alt="">  </p>
<p>跳转:router.redirect({<br>    ‘/‘:’/home’,<br>    ‘/aaa’:’/news’<br> });</p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/27.png" alt="">  </p>
<h5 id="3-路由嵌套-多级"><a href="#3-路由嵌套-多级" class="headerlink" title="3.路由嵌套(多级)"></a>3.路由嵌套(多级)</h5><h6 id="3-1-主页嵌套"><a href="#3-1-主页嵌套" class="headerlink" title="3.1 主页嵌套"></a>3.1 主页嵌套</h6><p>需求:实现以下需求<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/30.png" alt=""></p>
<p>1.为了简洁,我们将’home’变成模板<br>2.我们点击模板之后,会加入一个class<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/28.png" alt="">    </p>
<p>加入样式:  </p>
<pre><code>&lt;style&gt;
    .v-link-active{
        font-size: 20px;
        color: #985f0d;
    }
&lt;/style&gt;
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/29.png" alt="">  </p>
<p>3.在模板下加入<a></a>  </p>
<p>4.在home下面的模板下的路由的路径需要是:”/home/login”,”/home/reg”  </p>
<pre><code>&lt;template id=&quot;home&quot;&gt;
    &lt;h3&gt;我是主页&lt;/h3&gt;
    &lt;div&gt;
        &lt;a v-link=&quot;{path:&apos;/home/login&apos;}&quot;&gt;登录&lt;/a&gt;
        &lt;a v-link=&quot;{path:&apos;/home/reg&apos;}&quot;&gt;注册&lt;/a&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;   
</code></pre><p>5.由于登录注册的路由都是基于home的所以路由关联也是写在相应的下面:subRoutes  </p>
<pre><code>router.map({
        &apos;home&apos;:{
            component:Home,
            subRoutes:{
                &apos;login&apos;:{
                    component:{
                        template:&apos;&lt;strong&gt;我是登录信息&lt;/strong&gt;&apos;
                    }
                },
                &apos;reg&apos;:{
                    component:{
                        template:&apos;&lt;strong&gt;我是注册信息&lt;/strong&gt;&apos;
                    }
                }
            }
        }
    });
</code></pre><p>代码:  </p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;../js/vue-router.js&quot;&gt;&lt;/script&gt;
&lt;style&gt;
    .v-link-active{
        font-size: 20px;
        color: #985f0d;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;box&quot;&gt;
&lt;!--点击部分 --&gt;
&lt;ul&gt;
    &lt;li&gt;
        &lt;a v-link=&quot;{path:&apos;/home&apos;}&quot;&gt;主页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a v-link=&quot;{path:&apos;/news&apos;}&quot;&gt;新闻&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;!--展示视图--&gt;
&lt;div&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;template id=&quot;home&quot;&gt;
&lt;h3&gt;我是主页&lt;/h3&gt;
&lt;!--其下路由应该在其模板之下--&gt;
&lt;div&gt;
    &lt;a v-link=&quot;{path:&apos;/home/login&apos;}&quot;&gt;登录&lt;/a&gt;
    &lt;a v-link=&quot;{path:&apos;/home/reg&apos;}&quot;&gt;注册&lt;/a&gt;
&lt;/div&gt;
&lt;!--显示其下的路由--&gt;
&lt;div&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;template id=&quot;news&quot;&gt;
  &lt;h3&gt;我是新闻&lt;/h3&gt;
&lt;/template&gt;
&lt;/body&gt;
&lt;script&gt;
  //1.准备根组件
    var App = Vue.extend();
  //2.Home,News组件
  var Home = Vue.extend({
      template:&quot;#home&quot;
  });
  var  News = Vue.extend({
      template:&quot;#news&quot;
  });
  //3.准备路由
  var router = new VueRouter();
  //4.关联
  router.map({
      &apos;home&apos;:{
          component:Home,
          subRoutes:{
              &apos;login&apos;:{
                  component:{
                      template:&quot;&lt;h3&gt;我是登录&lt;/h3&gt;&quot;
                  }
              },
              &apos;reg&apos;:{
                  component:{
                      template:&apos;&lt;h3&gt;我是注册&lt;/h3&gt;&apos;
                  }
              }
          }
      },
      &apos;news&apos;:{
          component:News
      }
  });
  //5.启动路由
  router.start(App,&apos;#box&apos;);//绑定到哪个根路由(App)的哪个容器(box)

  //6.跳转
  router.redirect({
      &apos;/&apos;:&apos;home&apos;
  })
&lt;/script&gt;
&lt;/html&gt;
</code></pre><p>输出:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/18.gif" alt="">  </p>
<h6 id="3-2-新闻嵌套"><a href="#3-2-新闻嵌套" class="headerlink" title="3.2 新闻嵌套"></a>3.2 新闻嵌套</h6><pre><code>{{$route.params | json}} -&gt; 当前参数
{{$route.path}} -&gt;当前路径
{{$route.query | json}} -数据
</code></pre><p>代码:</p>
<pre><code>head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;../js/vue-router.js&quot;&gt;&lt;/script&gt;
&lt;style&gt;
    .v-link-active{
        font-size: 20px;
        color: #985f0d;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;box&quot;&gt;
&lt;!--点击部分 --&gt;
&lt;ul&gt;
    &lt;li&gt;
        &lt;a v-link=&quot;{path:&apos;/home&apos;}&quot;&gt;主页&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a v-link=&quot;{path:&apos;/news&apos;}&quot;&gt;新闻&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;!--展示视图--&gt;
&lt;div&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;template id=&quot;home&quot;&gt;
&lt;h3&gt;我是主页&lt;/h3&gt;
&lt;!--其下路由应该在其模板之下--&gt;
&lt;div&gt;
    &lt;a v-link=&quot;{path:&apos;/home/login&apos;}&quot;&gt;登录&lt;/a&gt;
    &lt;a v-link=&quot;{path:&apos;/home/reg&apos;}&quot;&gt;注册&lt;/a&gt;
&lt;/div&gt;
&lt;!--显示其下的路由--&gt;
&lt;div&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;template id=&quot;news&quot;&gt;
&lt;h3&gt;我是新闻&lt;/h3&gt;
&lt;div&gt;
    &lt;a v-link=&quot;{path:&apos;/news/detail/001&apos;}&quot;&gt;新闻001&lt;/a&gt;
    &lt;a v-link=&quot;{path:&apos;/news/detail/002&apos;}&quot;&gt;新闻002&lt;/a&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;template id=&quot;detail&quot;&gt;
&lt;!--id参数输出 json过滤--&gt;
{{$route.params | json}}&lt;br&gt;
{{$route.path}}
&lt;/template&gt;
&lt;/body&gt;
&lt;script&gt;
  //1.准备根组件
    var App = Vue.extend();
  //2.Home,News组件
  var Home = Vue.extend({
      template:&quot;#home&quot;
  });
  var  News = Vue.extend({
      template:&quot;#news&quot;
  });

 var Detail =  Vue.extend({
     template:&quot;#detail&quot;
  });
  //3.准备路由
  var router = new VueRouter();
  //4.关联
  router.map({
      &apos;home&apos;:{
          component:Home,
          subRoutes:{
              &apos;login&apos;:{
                  component:{
                      template:&quot;&lt;h3&gt;我是登录&lt;/h3&gt;&quot;
                  }
              },
              &apos;reg&apos;:{
                  component:{
                      template:&apos;&lt;h3&gt;我是注册&lt;/h3&gt;&apos;
                  }
              }
          }
      },
      &apos;news&apos;:{
          component:News,
          subRoutes:{
              &apos;/detail/:id&apos;:{
                  component:Detail
              }
          }
      }
  });
  //5.启动路由
  router.start(App,&apos;#box&apos;);//绑定到哪个根路由(App)的哪个容器(box)

  //6.跳转
  router.redirect({
      &apos;/&apos;:&apos;home&apos;
  })
 &lt;/script&gt;
&lt;/html&gt;
</code></pre><p>输出:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/19.gif" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/19/vue-28-vue-router/" class="archive-article-date">
  	<time datetime="2017-09-19T14:43:22.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-19</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringBoot-34-Spring自带缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/17/SpringBoot-34-Spring自带缓存/">SpringBoot(34)-Spring自带缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><a href="http://412887952-qq-com.iteye.com/blog/2294945" target="_blank" rel="external">转载自</a><br>Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如EHCache 或者 OSCache、Redis等），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>Spring 的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 EHCache 集成。  </p>
<h5 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h5><p>1.通过少量的配置 annotation 注释即可使得既有代码支持缓存<br>2.支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存<br>3.支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition<br>4.支持 AspectJ，并通过其实现任何方法的缓存支持<br>5.支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性  </p>
<h5 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2.实现方式"></a>2.实现方式</h5><p>以前我们是在service层通过先判断缓存中是否存在缓存数据，如果存在直接返回数据，如果不存在从数据库中进行查询数据的方式，那么我们会发现这种方式的代码耦合型太高了。如果你之前的代码就是这么设计的，那么你可以考虑使用Spring Cache优化你的代码，你的代码将会变得优雅很多。  </p>
<p>实现方式主要在方法上加上注解，可以注解的注解类有：<br>@Cacheable：负责将方法的返回值加入到缓存中<br>@CacheEvict：负责清除缓存  </p>
<p>Cacheable 支持如下几个参数：<br>value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name<br>key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL<br>condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL  </p>
<pre><code> //将缓存保存进andCache，并使用参数中的userId加上一个字符串(这里使用方法名称)作为缓存的key   
 @Cacheable(value=&quot;andCache&quot;,key=&quot;#userId + &apos;findById&apos;&quot;)  
public SystemUser findById(String userId) {  
SystemUser user = (SystemUser) dao.findById(SystemUser.class, userId);        
 return user ;         
}  
//将缓存保存进andCache，并当参数userId的长度小于32时才保存进缓存，默认使用参数值及类型作为缓存的key  
@Cacheable(value=&quot;andCache&quot;,condition=&quot;#userId.length &lt; 32&quot;)  
public boolean isReserved(String userId) {  
 System.out.println(&quot;hello andCache&quot;+userId);  
 return false;  
}  
</code></pre><p>@CacheEvict 支持如下几个参数：<br>value：缓存位置名称，不能为空，同上<br>key：缓存的key，默认为空，同上<br>condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL<br>allEntries：true表示清除value中的全部缓存，默认为false  </p>
<pre><code>//清除掉指定key的缓存  
 @CacheEvict(value=&quot;andCache&quot;,key=&quot;#user.userId + &apos;findById&apos;&quot;)  
public void modifyUserRole(SystemUser user) {  
         System.out.println(&quot;hello andCache delete&quot;+user.getUserId());  
 }  
//清除掉全部缓存  
@CacheEvict(value=&quot;andCache&quot;,allEntries=true)  
 public void setReservedUsers() {  
  System.out.println(&quot;hello andCache deleteall&quot;);  
}  
</code></pre><p>一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值，<br>比如我这里针对用户的操作，使用(userId+方法名称)的方式设定key值，当然，你也可以找到更适合自己的方式去设定</p>
<p>@CachePut 注释，这个注释可以确保方法被执行，同时方法的返回值也被记录到缓存中，实现缓存与数据库的同步更新，理解为update语句。  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/17/SpringBoot-34-Spring自带缓存/" class="archive-article-date">
  	<time datetime="2017-09-17T03:07:22.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-17</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringBoot-33-SpringBoot集成Redis实现缓存机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/16/SpringBoot-33-SpringBoot集成Redis实现缓存机制/">SpringBoot(33)-SpringBoot集成Redis实现缓存机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>缓存机制在应用中是经常用的机制,Redis是常用的缓存</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>本文章牵涉到的技术点：Spring Data JPA、Redis、Spring MVC,Spirng Cache<br>实例步骤:<br>1.新建Java Maven Project<br>2.在pom.xml中添加相应的依赖包<br>3.编写Spring Boot启动类<br>4.配置application.properties<br>5.编写RedisCacheConfig配置类<br>6.编写RedisInfo测试实体类<br>7.编写RedisInfoRepository持久化类<br>8.编写RedisInfoService类<br>9.编写RedisInfoController类<br>10.测试代码是否正常运行了<br>11.自定义缓存key</p>
<h5 id="1-新建Java-Maven-Project"><a href="#1-新建Java-Maven-Project" class="headerlink" title="1.新建Java Maven Project"></a>1.新建Java Maven Project</h5><p>新建spring-boot-redis项目   </p>
<h5 id="2-在pom-xml中添加相应的依赖包"><a href="#2-在pom-xml中添加相应的依赖包" class="headerlink" title="2.在pom.xml中添加相应的依赖包"></a>2.在pom.xml中添加相应的依赖包</h5><p>maven中添加依赖:spring-boot父节点,spring-boot web支持,缓存服务spring-context-support,redis支持,JPA操作数据库,mysql数据驱动  </p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

&lt;groupId&gt;com.yxm&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-redis&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;jar&lt;/packaging&gt;

&lt;name&gt;spring-boot-redis&lt;/name&gt;
&lt;url&gt;http://maven.apache.org&lt;/url&gt;

&lt;!-- spring-boot父节点 --&gt;
&lt;parent&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
 &lt;version&gt;1.4.1.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;properties&gt;
&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;java-version&gt;1.8&lt;/java-version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;

&lt;!-- spring-boot web支持 --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- 缓存服务spring-context-support --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- redis支持 --&gt;
&lt;dependency&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- JPA操作数据库 --&gt;
&lt;dependency&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- mysql数据驱动 --&gt;
&lt;dependency&gt;  
 &lt;groupId&gt;mysql&lt;/groupId&gt;  
 &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  
&lt;/dependency&gt; 

&lt;!-- junit --&gt; 
&lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;  
        &lt;scope&gt;test&lt;/scope&gt;  
&lt;/dependency&gt; 
&lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><h5 id="3-编写Spring-Boot启动类"><a href="#3-编写Spring-Boot启动类" class="headerlink" title="3.编写Spring Boot启动类"></a>3.编写Spring Boot启动类</h5><pre><code>@SpringBootApplication
public class App 
{
public static void main( String[] args )
{
   SpringApplication.run(App.class, args);
}
}
</code></pre><h5 id="4-配置application-properties"><a href="#4-配置application-properties" class="headerlink" title="4.配置application.properties"></a>4.配置application.properties</h5><p>配置三个资源，第一就是数据库基本信息；第二就是redis配置；第三就是JPA的配置  </p>
<pre><code>spring.datasource.url = jdbc:mysql://localhost:3306/test
spring.datasource.username = root
spring.datasource.password = root
spring.datasource.driverClassName = com.mysql.jdbc.Driver
spring.datasource.max-active=20
spring.datasource.max-idle=8
spring.datasource.min-idle=8
spring.datasource.initial-size=10

spring.redis.database=0
spring.redis.host=127.0.0.1  
spring.redis.port=6379
spring.redis.pool.max-idle=8
spring.redis.pool.min-idle=0
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=-1
spring.jpa.database = MYSQL
spring.jpa.hibernate.ddl-auto = update
spring.jpa.hibernate.naming-strategy = org.hibernate.cfg.ImprovedNamingStrategy
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect
</code></pre><h5 id="5-编写RedisCacheConfig配置类"><a href="#5-编写RedisCacheConfig配置类" class="headerlink" title="5.编写RedisCacheConfig配置类"></a>5.编写RedisCacheConfig配置类</h5><p>缓存主要有几个要实现的类：其一就是CacheManager缓存管理器；其二就是具体操作实现类；其三就是CacheManager工厂类（这个可以使用配置文件配置的进行注入，也可以通过编码的方式进行实现）；其四就是缓存key生产策略（当然Spring自带生成策略，但是在Redis客户端进行查看的话是系列化的key,对于我们肉眼来说就是感觉是乱码了，这里我们先使用自带的缓存策略）。</p>
<pre><code>package com.yxm.config;
import java.lang.reflect.Method;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
/** 
 * redis 缓存配置; 
 * 
 * 注意：RedisCacheConfig这里也可以不用继承：CachingConfigurerSupport，也就是直接一个普通的Class就好了； 
 * 
 * 这里主要我们之后要重新实现 key的生成策略，只要这里修改KeyGenerator，其它位置不用修改就生效了。 
 * 
 * 普通使用普通类的方式的话，那么在使用@Cacheable的时候还需要指定KeyGenerator的名称;这样编码的时候比较麻烦。 
 * 
 * @author 
 * @version v.0.1 
 */  
@Configuration
@EnableCaching//启用缓存，这个注解很重要
public class RedisCacheConfig extends CachingConfigurerSupport{
/** 
 * 自定义key. 
 * 此方法将会根据类名+方法名+所有参数的值生成唯一的一个key,即使@Cacheable中的value属性一样，key也会不一样。 
 */  
@Override  
public KeyGenerator keyGenerator() {  
   System.out.println(&quot;RedisCacheConfig.keyGenerator()&quot;);  
   return new KeyGenerator() {
    public Object generate(Object o, Method method, Object... objects) {
        // This will generate a unique key of the class name, the method name  
        //and all method parameters appended.  
        StringBuilder sb = new StringBuilder();  
        sb.append(o.getClass().getName());  
        sb.append(method.getName());  
        for (Object obj : objects) {  
            sb.append(obj.toString());  
        }  
        System.out.println(&quot;keyGenerator=&quot; + sb.toString());  
        return sb.toString();  
    }  
   };  
}  
/**
 * 缓存管理器
 * @param redisTemplate
 * @return
 */
@Bean
public CacheManager cacheManager(RedisTemplate&lt;?, ?&gt; redisTemplate){
     CacheManager cacheManager = new RedisCacheManager(redisTemplate);
     return cacheManager;
}
/** 
 * redis模板操作类,类似于jdbcTemplate的一个类; 
 * 
 * 虽然CacheManager也能获取到Cache对象，但是操作起来没有那么灵活； 
 * 
 * 这里在扩展下：RedisTemplate这个类不见得很好操作，我们可以在进行扩展一个我们 
 * 
 * 自己的缓存类，比如：RedisStorage类; 
 * 
 * @param factory : 通过Spring进行注入，参数在application.properties进行配置； 
 * @return 
 */  
@Bean
public RedisTemplate&lt;String,String&gt; redisTemplate(RedisConnectionFactory factory){
     RedisTemplate&lt;String, String&gt; redisTemplate = new RedisTemplate&lt;String, String&gt;();  
     redisTemplate.setConnectionFactory(factory);  
     //key序列化方式;（不然会出现乱码;）,但是如果方法上有Long等非String类型的话，会报类型转换错误；  
     //所以在没有自己定义key生成策略的时候，以下这个代码建议不要这么写，可以不配置或者自己实现ObjectRedisSerializer  
     //或者JdkSerializationRedisSerializer序列化方式;  
     RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();//Long类型不可以会出现异常信息;  
     redisTemplate.setKeySerializer(redisSerializer);  
     redisTemplate.setHashKeySerializer(redisSerializer);
     return redisTemplate; 
  }    
}
</code></pre><p>RedisCacheConfig这里也可以不用继承：CachingConfigurerSupport，也就是直接一个普通的Class就好了；这里主要我们之后要重新实现 key的生成策略，只要这里修改KeyGenerator，其它位置不用修改就生效了。普通使用普通类的方式的话，那么在使用@Cacheable的时候还需要指定KeyGenerator的名称;这样编码的时候比较麻烦。</p>
<h5 id="6-编写RedisInfo测试实体类"><a href="#6-编写RedisInfo测试实体类" class="headerlink" title="6.编写RedisInfo测试实体类"></a>6.编写RedisInfo测试实体类</h5><pre><code>import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
@Entity
public class RedisInfo implements Serializable{
private static final long serialVersionUID = 1L;
@Id @GeneratedValue
private Long id;
private String name;
private String pwd;

public Long getId() {
    return id;
}

public void setId(Long id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public String getPwd() {
    return pwd;
}

public void setPwd(String pwd) {
    this.pwd = pwd;
}
@Override
public String toString() {
    return &quot;RedisInfo [id=&quot; + id + &quot;, name=&quot; + name + &quot;, pwd=&quot; + pwd + &quot;]&quot;;
}
}
</code></pre><h5 id="7-编写RedisInfoRepository持久化类"><a href="#7-编写RedisInfoRepository持久化类" class="headerlink" title="7.编写RedisInfoRepository持久化类"></a>7.编写RedisInfoRepository持久化类</h5><pre><code>package com.yxm.web.dao;
import org.springframework.data.repository.CrudRepository;
import com.yxm.web.entity.RedisInfo;
public interface RedisInfoRepository extends CrudRepository&lt;RedisInfo, Long&gt;{
} 
</code></pre><h5 id="8-编写RedisInfoService类"><a href="#8-编写RedisInfoService类" class="headerlink" title="8.编写RedisInfoService类"></a>8.编写RedisInfoService类</h5><p>使用Spring @Cacheable注解方式和RedisTemplate对象进行操作:<br>service:  </p>
<pre><code>package com.yxm.web.service;
import com.yxm.web.entity.RedisInfo;
public interface RedisInfoService {
  public RedisInfo findById(long id);
  public void deleteCache(long id);
   void test();
  }
</code></pre><p>serviceImpl:  </p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;
import com.yxm.web.dao.RedisInfoRepository;
import com.yxm.web.entity.RedisInfo;
import com.yxm.web.service.RedisInfoService;
@Service
public class RedisInfoServiceImpl implements RedisInfoService{
@Autowired
private RedisInfoRepository repository;
@Autowired
private RedisTemplate&lt;String,String&gt; redisTemplate;
@Cacheable(value=&quot;redisInfo&quot;)//缓存,这里没有指定key
public RedisInfo findById(long id) {
    System.out.println(&quot;------从数据库里面获取-------&quot;+id);
    return repository.findOne(id);
}
@CacheEvict(value=&quot;redisInfo&quot;) 
public void deleteCache(long id) {
    System.out.println(&quot;--------d从缓存中删除----------&quot;);
}
public void test() {
    ValueOperations&lt;String,String&gt; valueOperations = redisTemplate.opsForValue();  
    valueOperations.set(&quot;redisKey&quot;, &quot;random=&quot;+Math.random());  
    System.out.println(valueOperations.get(&quot;redisKey&quot;));
 }
}
</code></pre><h5 id="9-编写RedisInfoController类"><a href="#9-编写RedisInfoController类" class="headerlink" title="9.编写RedisInfoController类"></a>9.编写RedisInfoController类</h5><pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import com.yxm.web.entity.RedisInfo;
import com.yxm.web.service.RedisInfoService;
@Controller
public class RedisInfoController {
@Autowired
private RedisInfoService redisInfoService;
@RequestMapping(&quot;/find&quot;)
@ResponseBody
public String find(){
    RedisInfo loaded = redisInfoService.findById(1);
    System.out.println(&quot;loaded[&quot;+loaded+&quot;]&quot;);
    RedisInfo cached = redisInfoService.findById(1);
    System.out.println(&quot;cached[&quot;+cached+&quot;]&quot;);
    loaded = redisInfoService.findById(2);
    System.out.println(&quot;loaded[&quot;+loaded+&quot;]&quot;);
    return &quot;findById&quot;;
}
@RequestMapping(&quot;/delete&quot;)
@ResponseBody
public String delete(long id){
    redisInfoService.deleteCache(id);
    return &quot;delete&quot;;
}
@RequestMapping(&quot;/test&quot;)
@ResponseBody
public String test(){
    redisInfoService.test();
    System.out.println(&quot;--test--&quot;);
    return &quot;test&quot;;
}
}
</code></pre><h5 id="10-测试代码是否正常运行了"><a href="#10-测试代码是否正常运行了" class="headerlink" title="10.测试代码是否正常运行了"></a>10.测试代码是否正常运行了</h5><p>第一次访问:<br>启动应用程序,访问地址：<a href="http://localhost:8080/find" target="_blank" rel="external">http://localhost:8080/find</a>  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/21.png" alt=""><br>访问地址：<a href="http://127.0.0.1:8080/test" target="_blank" rel="external">http://127.0.0.1:8080/test</a>  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/22.png" alt=""><br>从以上知道:service里面只执行一次,说明第二次是从缓存中拿的  </p>
<p>二次缓存:<br>访问地址：<a href="http://localhost:8080/find" target="_blank" rel="external">http://localhost:8080/find</a><br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/23.png" alt=""></p>
<p>这时候所有的数据都是执行缓存的<br>这时候执行删除动作：<a href="http://127.0.0.1:8080/delete?id=1" target="_blank" rel="external">http://127.0.0.1:8080/delete?id=1</a><br>然后在访问：<a href="http://127.0.0.1:8080/find" target="_blank" rel="external">http://127.0.0.1:8080/find</a></p>
<h5 id="11-自定义缓存key"><a href="#11-自定义缓存key" class="headerlink" title="11.自定义缓存key"></a>11.自定义缓存key</h5><p>在com.yxm.config.RedisCacheConfig类中重写CachingConfigurerSupport中的keyGenerator ,具体实现代码如下： </p>
<pre><code> /** 
 * 自定义key. 
 * 此方法将会根据类名+方法名+所有参数的值生成唯一的一个 key,即使@Cacheable中的value属性一样，key也会不一样。 
 */  
 @Override  
 public KeyGenerator keyGenerator() {  
   System.out.println(&quot;RedisCacheConfig.keyGenerator()&quot;);  
   return new KeyGenerator() {  
       @Override  
       public Object generate(Object o, Method method, Object... objects) {  
          // This will generate a unique key of the class name, the method name  
          //and all method parameters appended.  
          StringBuilder sb = new StringBuilder();  
          sb.append(o.getClass().getName());  
          sb.append(method.getName());  
          for (Object obj : objects) {  
              sb.append(obj.toString());  
          }  
          System.out.println(&quot;keyGenerator=&quot; + sb.toString());  
          return sb.toString();  
       }  
   };  
}   
</code></pre><p>这时候在redis的客户端查看key的话还是序列化的肉眼看到就是乱码了，那么我改变key的序列方式，这个很简单，redis底层已经有具体的实现类了，我们只需要配置下：  </p>
<pre><code>//key序列化方式;（不然会出现乱码;）,但是如果方法上有Long等非String类型的话，会报类型转换错误；  
//所以在没有自己定义key生成策略的时候，以下这个代码建议不要这么写，可以不配置或者自己实现ObjectRedisSerializer  
//或者JdkSerializationRedisSerializer序列化方式;  
RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();//Long类型不可以会出现异常信息;  
redisTemplate.setKeySerializer(redisSerializer);  
redisTemplate.setHashKeySerializer(redisSerializer);   
</code></pre><p>RedisCacheConfig类的方法调整:  </p>
<pre><code>package com.yxm.config;
import java.lang.reflect.Method;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
/** 
* redis 缓存配置; 
* 
* 注意：RedisCacheConfig这里也可以不用继承：CachingConfigurerSupport，也就是直接一个普通的Class就好了； 
* 
* 这里主要我们之后要重新实现 key的生成策略，只要这里修改KeyGenerator，其它位置不用修改就生效了。 
* 
* 普通使用普通类的方式的话，那么在使用@Cacheable的时候还需要指定KeyGenerator的名称;这样编码的时候比较麻烦。 
* 
* @author 
* @version v.0.1 
*/  
@Configuration
@EnableCaching//启用缓存，这个注解很重要
public class RedisCacheConfig extends CachingConfigurerSupport{
/** 
 * 自定义key. 
 * 此方法将会根据类名+方法名+所有参数的值生成唯一的一个key,即使@Cacheable中的value属性一样，key也会不一样。 
 */  
@Override  
public KeyGenerator keyGenerator() {  
   System.out.println(&quot;RedisCacheConfig.keyGenerator()&quot;);  
   return new KeyGenerator() {
    public Object generate(Object o, Method method, Object... objects) {
        // This will generate a unique key of the class name, the method name  
        //and all method parameters appended.  
        StringBuilder sb = new StringBuilder();  
        sb.append(o.getClass().getName());  
        sb.append(method.getName());  
        for (Object obj : objects) {  
            sb.append(obj.toString());  
        }  
        System.out.println(&quot;keyGenerator=&quot; + sb.toString());  
        return sb.toString();  
    }  
   };  
}  
/**
 * 缓存管理器
 * @param redisTemplate
 * @return
 */
@Bean
public CacheManager cacheManager(RedisTemplate&lt;?, ?&gt; redisTemplate){
     CacheManager cacheManager = new RedisCacheManager(redisTemplate);
     return cacheManager;
}
/** 
 * redis模板操作类,类似于jdbcTemplate的一个类; 
 * 
 * 虽然CacheManager也能获取到Cache对象，但是操作起来没有那么灵活； 
 * 
 * 这里在扩展下：RedisTemplate这个类不见得很好操作，我们可以在进行扩展一个我们 
 * 
 * 自己的缓存类，比如：RedisStorage类; 
 * 
 * @param factory : 通过Spring进行注入，参数在application.properties进行配置； 
 * @return 
 */  
@Bean
public RedisTemplate&lt;String,String&gt; redisTemplate(RedisConnectionFactory factory){
     RedisTemplate&lt;String, String&gt; redisTemplate = new RedisTemplate&lt;String, String&gt;();  
     redisTemplate.setConnectionFactory(factory);  
     //key序列化方式;（不然会出现乱码;）,但是如果方法上有Long等非String类型的话，会报类型转换错误；  
     //所以在没有自己定义key生成策略的时候，以下这个代码建议不要这么写，可以不配置或者自己实现ObjectRedisSerializer  
     //或者JdkSerializationRedisSerializer序列化方式;  
     RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();//Long类型不可以会出现异常信息;  
     redisTemplate.setKeySerializer(redisSerializer);  
     redisTemplate.setHashKeySerializer(redisSerializer);
     return redisTemplate; 
 }    
}
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/16/SpringBoot-33-SpringBoot集成Redis实现缓存机制/" class="archive-article-date">
  	<time datetime="2017-09-16T10:28:58.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringBoot-32-SpringBoot的启动器Starter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/16/SpringBoot-32-SpringBoot的启动器Starter/">SpringBoot(32)-SpringBoot的启动器Starter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>SpringBoot功能是依赖于其启动器Starter</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>Spring Boot应用启动器基本的一共有44种:  </p>
<p>1）spring-boot-starter<br>这是Spring Boot的核心启动器，包含了自动配置、日志和YAML。</p>
<p>2）spring-boot-starter-actuator<br>帮助监控和管理应用。</p>
<p>3）spring-boot-starter-amqp<br>通过spring-rabbit来支持AMQP协议（Advanced Message Queuing Protocol）。</p>
<p>4）spring-boot-starter-aop<br>支持面向方面的编程即AOP，包括spring-aop和AspectJ。</p>
<p>5）spring-boot-starter-artemis<br>通过Apache Artemis支持JMS的API（Java Message Service API）。</p>
<p>6）spring-boot-starter-batch<br>支持Spring Batch，包括HSQLDB数据库。</p>
<p>7）spring-boot-starter-cache<br>支持Spring的Cache抽象。</p>
<p>8）spring-boot-starter-cloud-connectors<br>支持Spring Cloud Connectors，简化了在像Cloud Foundry或Heroku这样的云平台上连接服务。</p>
<p>9）spring-boot-starter-data-elasticsearch<br>支持ElasticSearch搜索和分析引擎，包括spring-data-elasticsearch。</p>
<p>10）spring-boot-starter-data-gemfire<br>支持GemFire分布式数据存储，包括spring-data-gemfire。</p>
<p>11）spring-boot-starter-data-jpa<br>支持JPA（Java Persistence API），包括spring-data-jpa、spring-orm、Hibernate。</p>
<p>12）spring-boot-starter-data-mongodb<br>支持MongoDB数据，包括spring-data-mongodb。</p>
<p>13）spring-boot-starter-data-rest<br>通过spring-data-rest-webmvc，支持通过REST暴露Spring Data数据仓库。</p>
<p>14）spring-boot-starter-data-solr<br>支持Apache Solr搜索平台，包括spring-data-solr。</p>
<p>15）spring-boot-starter-freemarker<br>支持FreeMarker模板引擎。</p>
<p>16）spring-boot-starter-groovy-templates<br>支持Groovy模板引擎。</p>
<p>17）spring-boot-starter-hateoas<br>通过spring-hateoas支持基于HATEOAS的RESTful Web服务。</p>
<p>18）spring-boot-starter-hornetq<br>通过HornetQ支持JMS。</p>
<p>19）spring-boot-starter-integration<br>支持通用的spring-integration模块。</p>
<p>20）spring-boot-starter-jdbc<br>支持JDBC数据库。</p>
<p>21）spring-boot-starter-jersey<br>支持Jersey RESTful Web服务框架。</p>
<p>22）spring-boot-starter-jta-atomikos<br>通过Atomikos支持JTA分布式事务处理。</p>
<p>23）spring-boot-starter-jta-bitronix<br>通过Bitronix支持JTA分布式事务处理。</p>
<p>24）spring-boot-starter-mail<br>支持javax.mail模块。</p>
<p>25）spring-boot-starter-mobile<br>支持spring-mobile。</p>
<p>26）spring-boot-starter-mustache<br>支持Mustache模板引擎。</p>
<p>27）spring-boot-starter-redis<br>支持Redis键值存储数据库，包括spring-redis。</p>
<p>28）spring-boot-starter-security<br>支持spring-security。</p>
<p>29）spring-boot-starter-social-facebook<br>支持spring-social-facebook</p>
<p>30）spring-boot-starter-social-linkedin<br>支持pring-social-linkedin</p>
<p>31）spring-boot-starter-social-twitter<br>支持pring-social-twitter</p>
<p>32）spring-boot-starter-test<br>支持常规的测试依赖，包括JUnit、Hamcrest、Mockito以及spring-test模块。</p>
<p>33）spring-boot-starter-thymeleaf<br>支持Thymeleaf模板引擎，包括与Spring的集成。</p>
<p>34）spring-boot-starter-velocity<br>支持Velocity模板引擎。</p>
<p>35）spring-boot-starter-web<br>S支持全栈式Web开发，包括Tomcat和spring-webmvc。</p>
<p>36）spring-boot-starter-websocket<br>支持WebSocket开发。</p>
<p>37）spring-boot-starter-ws<br>支持Spring Web Services。</p>
<p>Spring Boot应用启动器面向生产环境的还有2种，具体如下：</p>
<p>1）spring-boot-starter-actuator<br>增加了面向产品上线相关的功能，比如测量和监控。</p>
<p>2）spring-boot-starter-remote-shell<br>增加了远程ssh shell的支持。</p>
<p>最后，Spring Boot应用启动器还有一些替换技术的启动器，具体如下：</p>
<p>1）spring-boot-starter-jetty<br>引入了Jetty HTTP引擎（用于替换Tomcat）。</p>
<p>2）spring-boot-starter-log4j<br>支持Log4J日志框架。</p>
<p>3）spring-boot-starter-logging<br>引入了Spring Boot默认的日志框架Logback。</p>
<p>4）spring-boot-starter-tomcat<br>引入了Spring Boot默认的HTTP引擎Tomcat。</p>
<p>5）spring-boot-starter-undertow<br>引入了Undertow HTTP引擎（用于替换Tomcat）。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/16/SpringBoot-32-SpringBoot的启动器Starter/" class="archive-article-date">
  	<time datetime="2017-09-16T10:01:59.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringBoot-31-SpringBoot监控和管理生产环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/16/SpringBoot-31-SpringBoot监控和管理生产环境/">SpringBoot(31)-SpringBoot监控和管理生产环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>spring-boot-actuator模块提供了一个监控和管理生产环境的模块，可以使用http、jmx、ssh、telnet等拉管理和监控应用。审计（Auditing）、<br>健康（health）、数据采集（metrics gathering）会自动加入到应用里面。</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-加入依赖"><a href="#1-加入依赖" class="headerlink" title="1.加入依赖"></a>1.加入依赖</h5><pre><code>&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><h5 id="2-监控描述"><a href="#2-监控描述" class="headerlink" title="2.监控描述"></a>2.监控描述</h5><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/9/20.png" alt="">  </p>
<h5 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h5><p>1.health<br>url:<a href="http://localhost:8080/health" target="_blank" rel="external">http://localhost:8080/health</a><br>结果:{“status”:”UP”,”diskSpace”:{“status”:”UP”,”total”:147882274816,”free”:8067350528,”threshold”:10485760}}  </p>
<p>2.trace<br>访问<a href="http://localhost:8080/trace" target="_blank" rel="external">http://localhost:8080/trace</a> 可以看到结果，默认为最新的一些HTTP请求  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/16/SpringBoot-31-SpringBoot监控和管理生产环境/" class="archive-article-date">
  	<time datetime="2017-09-16T09:21:43.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-SpringBoot-30-SpringBootApplication注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/16/SpringBoot-30-SpringBootApplication注解/">SpringBoot(30)-SpringBootApplication注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很多Spring Boot开发者总是使用 @Configuration ， @EnableAutoConfiguration 和 @ComponentScan 注解他们的main类。由于这些注解被如此频繁地一块使用（特别是你遵循以上最佳实践时），Spring Boot提供一个方便的 @SpringBootApplication 选择。该 @SpringBootApplication 注解等价于以默认属性使用 @Configuration ， @EnableAutoConfiguration 和 @ComponentScan 。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/16/SpringBoot-30-SpringBootApplication注解/" class="archive-article-date">
  	<time datetime="2017-09-16T03:35:53.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/40/">40</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/CTI/" style="font-size: 11.18px;">CTI</a> <a href="/tags/Cookie/" style="font-size: 10.59px;">Cookie</a> <a href="/tags/DevelopmentSkills/" style="font-size: 10px;">DevelopmentSkills</a> <a href="/tags/Easyui/" style="font-size: 10px;">Easyui</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IE问题/" style="font-size: 10px;">IE问题</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 12.35px;">JVM</a> <a href="/tags/JavaSE/" style="font-size: 15.88px;">JavaSE</a> <a href="/tags/Jeecg/" style="font-size: 11.76px;">Jeecg</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Myeclipse/" style="font-size: 14.71px;">Myeclipse</a> <a href="/tags/Netty/" style="font-size: 15.29px;">Netty</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 17.65px;">Oracle</a> <a href="/tags/Redis/" style="font-size: 12.35px;">Redis</a> <a href="/tags/Servlet/" style="font-size: 11.76px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 10.59px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/SpringBoot/" style="font-size: 19.41px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 11.18px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Vue/" style="font-size: 18.82px;">Vue</a> <a href="/tags/Vue-js-前端开发-快速入门与专业应用/" style="font-size: 18.24px;">Vue.js+前端开发+快速入门与专业应用</a> <a href="/tags/Weblogic/" style="font-size: 12.35px;">Weblogic</a> <a href="/tags/Websocket/" style="font-size: 10.59px;">Websocket</a> <a href="/tags/Work-Problem/" style="font-size: 10px;">Work-Problem</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/easyui/" style="font-size: 10px;">easyui</a> <a href="/tags/hibernate/" style="font-size: 10.59px;">hibernate</a> <a href="/tags/html-css/" style="font-size: 10.59px;">html+css</a> <a href="/tags/html-css/" style="font-size: 15.88px;">html-css</a> <a href="/tags/html-ss/" style="font-size: 10px;">html-ss</a> <a href="/tags/im/" style="font-size: 14.12px;">im</a> <a href="/tags/jQuery/" style="font-size: 12.35px;">jQuery</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/java-String/" style="font-size: 10px;">java String</a> <a href="/tags/javaSE/" style="font-size: 10.59px;">javaSE</a> <a href="/tags/javaWeb/" style="font-size: 10px;">javaWeb</a> <a href="/tags/javascript/" style="font-size: 11.18px;">javascript</a> <a href="/tags/java并发编程/" style="font-size: 11.76px;">java并发编程</a> <a href="/tags/java集合/" style="font-size: 10.59px;">java集合</a> <a href="/tags/junit测试/" style="font-size: 10px;">junit测试</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 17.06px;">linux</a> <a href="/tags/log4j/" style="font-size: 11.76px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/netty/" style="font-size: 11.76px;">netty</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodeJs/" style="font-size: 10px;">nodeJs</a> <a href="/tags/redis/" style="font-size: 12.94px;">redis</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/sockJs/" style="font-size: 10px;">sockJs</a> <a href="/tags/socket网络编程/" style="font-size: 10.59px;">socket网络编程</a> <a href="/tags/struts1/" style="font-size: 11.18px;">struts1</a> <a href="/tags/vue/" style="font-size: 10.59px;">vue</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weblogic/" style="font-size: 11.18px;">weblogic</a> <a href="/tags/websocket/" style="font-size: 14.71px;">websocket</a> <a href="/tags/work/" style="font-size: 10px;">work</a> <a href="/tags/代理/" style="font-size: 11.76px;">代理</a> <a href="/tags/前端/" style="font-size: 10.59px;">前端</a> <a href="/tags/动手写一个MVC/" style="font-size: 12.35px;">动手写一个MVC</a> <a href="/tags/反射/" style="font-size: 16.47px;">反射</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/微博/" style="font-size: 10px;">微博</a> <a href="/tags/文件读取/" style="font-size: 10px;">文件读取</a> <a href="/tags/泛型/" style="font-size: 13.53px;">泛型</a> <a href="/tags/注解/" style="font-size: 11.18px;">注解</a> <a href="/tags/类加载器/" style="font-size: 13.53px;">类加载器</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/自己写一个apache服务器/" style="font-size: 17.65px;">自己写一个apache服务器</a> <a href="/tags/转载/" style="font-size: 12.35px;">转载</a> <a href="/tags/集合/" style="font-size: 12.35px;">集合</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>