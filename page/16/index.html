<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Startshineye的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Startshineye的博客">
<meta property="og:url" content="https://github.com/startshineye/page/16/index.html">
<meta property="og:site_name" content="Startshineye的博客">
<meta property="og:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startshineye的博客">
<meta name="twitter:description" content="毕业于石大，相信技术可以改变人与人之间的生活，码农一枚">
  
    <link rel="alternative" href="/atom.xml" title="Startshineye的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			 <img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startshineye</a></h1>
		</hgroup>

		
		<p class="header-subtitle">淡泊明志，宁静致远</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="#" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Startshineye</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/king.jpg" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Startshineye</h1>
			</hgroup>
			
			<p class="header-subtitle">淡泊明志，宁静致远</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/startshineye" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-vue-23-vue工程实例-准备" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/10/vue-23-vue工程实例-准备/">vue(23)-vue工程实例-准备</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-webpack"><a href="#1-webpack" class="headerlink" title="1.webpack"></a>1.webpack</h5><ol>
<li>webpack 是一款模块加载及处理工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理</li>
<li>webpack 可以把ES6 语法的js 文件，sass 样式等无法直接在浏览器中使用的语言编译成浏览器支持的形式，也可以把需要的文件进行合并、压缩混淆。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/5.png" alt=""></li>
</ol>
<h6 id="1-1-安装webpack"><a href="#1-1-安装webpack" class="headerlink" title="1.1 安装webpack"></a>1.1 安装webpack</h6><p>在安装 Webpack 前，你本地环境需要支持 node.js。<br>由于 npm 安装速度慢,使用淘宝的镜像及其命令 cnpm</p>
<pre><code>cnpm install webpack -g
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/6.png" alt="">  </p>
<h6 id="1-2-创建项目"><a href="#1-2-创建项目" class="headerlink" title="1.2 创建项目"></a>1.2 创建项目</h6><p>1.创建一个目录 app<br>2.app下创建app.js文件,内容为:  </p>
<pre><code>document.write(&quot;It works.&quot;);
</code></pre><p>3.app下创建index.html文件,内容如下:</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
 &lt;meta charset = &quot;utf-8&quot;&gt;
 &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
 &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>4.接下来我们使用 webpack 命令来打包<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/7.png" alt=""></p>
<p>5.浏览器中访问<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/8.png" alt=""></p>
<h6 id="1-3-创建第二个JS文件"><a href="#1-3-创建第二个JS文件" class="headerlink" title="1.3 创建第二个JS文件"></a>1.3 创建第二个JS文件</h6><p>接下来我们创建另外一个js文件app2.js，代码如下：  </p>
<pre><code>module.exports=&quot;It works from app2.js&quot;
</code></pre><p>更新app.js文件，代码如下：  </p>
<pre><code>document.write(require(&quot;./app2.js&quot;));  
</code></pre><p>接下来我们使用 webpack 命令来打包：</p>
<pre><code>webpack app.js bundle..js  
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/9.png" alt="">  </p>
<p>exports和module.exports指向同一块内存，但require()返回的是module.exports而不是exports。</p>
<p>在浏览器访问，输出结果如下所示：  </p>
<p> It works from app2.js</p>
<p>webpack 根据模块的依赖关系进行静态分析，这些文件(模块)会被包含到 bundle.js 文件中。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。 在页面启动时，会先执行app.js 中的代码，其它模块会在运行 require 的时候再执行。</p>
<h6 id="1-4-loader"><a href="#1-4-loader" class="headerlink" title="1.4 loader"></a>1.4 loader</h6><p>1.Webpack本身只能处理JavaScript模块，如果要处理其他类型的文件，就需要使用loader进行转换。<br>2.如果我们需要在应用中添加 css 文件，就需要使用到 css-loader 和 style-loader，他们做两件不同的事情，css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。  </p>
<p>使用以下命令来安装 css-loader 和 style-loader(全局安装需要参数 -g):  </p>
<p>执行以上命令后，会再当前目录生成 node_modules 目录，它就是 css-loader 和 style-loader 的安装目录。<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/10.png" alt="">    </p>
<p>接下来创建一个 style.css 文件，代码如下：  </p>
<pre><code>body{
  background:yellow;
}
</code></pre><p>修改app.js文件,代码如下:  </p>
<pre><code>require(&quot;!style-loader!css-loader!./style.css&quot;);
document.write(require(&quot;./app2.js&quot;));
</code></pre><p>接下来我们使用 webpack 命令来打包：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/11.png" alt=""></p>
<p>在浏览器访问，输出结果如下所示：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/12.png" alt=""></p>
<p>require CSS 文件的时候都要写 loader 前缀 !style-loader!css-loader!，当然我们可以根据模块类型（扩展名）来自动绑定需要的 loader。 将app.js 中的 require(“!style-loader!css-loader!./style.css”) 修改为 require(“./style.css”)，效果一样</p>
<h6 id="1-5-配置文件"><a href="#1-5-配置文件" class="headerlink" title="1.5 配置文件"></a>1.5 配置文件</h6><p>我们可以将一些编译选项放在配置文件中，以便于统一管理：<br>创建webpack.config.js文件,代码如下:  </p>
<pre><code>module.exports={
entry:&quot;./app.js&quot;,
output:{
    path:__dirname,//注意此处是两个下划线
    filename:&quot;bundle.js&quot;
},
module:{
    loaders:[
    { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; }
    ]
}
}
</code></pre><p>接下来我们只需要执行 webpack 命令即可生成 bundle.js 文件：  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/13.png" alt=""><br>webpack 命令执行后，会默认载入当前目录的 webpack.config.js 文件。</p>
<h6 id="1-6-插件"><a href="#1-6-插件" class="headerlink" title="1.6 插件"></a>1.6 插件</h6><p>插件在 webpack 的配置信息 plugins 选项中指定，用于完成一些 loader 不能完成的工。webpack 自带一些插件，你可以通过 cnpm 安装一些插件。使用内置插件需要通过以下命令来安装：</p>
<p>使用内置插件需要通过以下命令来安装：</p>
<pre><code>cnpm install webpack --save-dev
</code></pre><p>比如我们可以安装内置的 BannerPlugin 插件，用于在文件头部输出一些注释信息。  </p>
<p>修改 webpack.config.js，代码如下：</p>
<pre><code>var webpack=require(&apos;webpack&apos;);
module.exports = {
entry: &quot;./runoob1.js&quot;,
output: {
    path: __dirname,
    filename: &quot;bundle.js&quot;
},
module: {
    loaders: [
        { test: /\.css$/, loader: &quot;style-loader!css-loader&quot; }
    ]
},
plugins:[
new webpack.BannerPlugin(&apos;菜鸟教程 webpack 实例&apos;)
]
};
</code></pre><p>然后运行:  </p>
<p>webpack  </p>
<p>当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。  </p>
<pre><code>webpack --progress --colors
</code></pre><p>如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。</p>
<pre><code>webpack --progress --colors --watch
</code></pre><p>当然，我们可以使用 webpack-dev-server 开发服务，这样我们就能通过 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开 <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> 或 <a href="http://localhost:8080/webpack-dev-server/" target="_blank" rel="external">http://localhost:8080/webpack-dev-server/</a> 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。</p>
<p>1、安装<br>cnpm install webpack-dev-server -g</p>
<p>2、运行<br>webpack-dev-server –progress –colors</p>
<p>在浏览器打开 <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/11/10/vue-23-vue工程实例-准备/" class="archive-article-date">
  	<time datetime="2017-11-10T09:17:35.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-11-10</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js-前端开发-快速入门与专业应用/">Vue.js+前端开发+快速入门与专业应用</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-22-组件-动态组件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/10/vue-22-组件-动态组件/">vue(22)-组件-动态组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Vue.js 支持动态组件，即多个组件可以使用同一挂载点，根据条件来切换不同的组件。<br>使用保留标签<component>，通过绑定到is 属性的值来判断挂载哪个组件。这种场景往往运<br>用在路由控制或者tab 切换中</component></p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1.基础用法"></a>1.基础用法</h5><p>页面切换说明动态组件基础用法。  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;!--js--&gt;</div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">   &lt;ul&gt;</div><div class="line">       &lt;li @click=&quot;currentView=&apos;home&apos;&quot;&gt;home&lt;/li&gt;</div><div class="line">       &lt;li @click=&quot;currentView=&apos;list&apos;&quot;&gt;list&lt;/li&gt;</div><div class="line">       &lt;li @click=&quot;currentView=&apos;detail&apos;&quot;&gt;detail&lt;/li&gt;</div><div class="line">   &lt;/ul&gt;</div><div class="line">   &lt;component :is=&quot;currentView&quot;&gt;&lt;/component&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!--js--&gt;</div><div class="line">var vm = new Vue(&#123;</div><div class="line"> el:&quot;#app&quot;,</div><div class="line"> data:&#123;</div><div class="line">     currentView:&apos;home&apos;</div><div class="line"> &#125;,</div><div class="line"> components:&#123;</div><div class="line">     home:&#123;</div><div class="line">         template:&apos;&lt;div&gt;Home&lt;/div&gt;&apos;</div><div class="line">     &#125;,</div><div class="line">     list:&#123;</div><div class="line">         template:&apos;&lt;div&gt;List&lt;/div&gt;&apos;</div><div class="line">     &#125;,</div><div class="line">     detail:&#123;</div><div class="line">         template:&apos;&lt;div&gt;Detail&lt;/div&gt;&apos;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>component 标签上is 属性决定了当前采用的子组件，:is 是v-bind:is 的缩写，绑定了父<br>组件中data 的currentView 属性。顶部的ul 则起到导航的作用，点击即可修改currentView<br>值，也就修改component 标签中使用的子组件类型。</p>
</li>
<li><p>需要注意的事，currentView 的值需要和父组件实例中的components属性的key相对应。</p>
</li>
</ol>
<h5 id="2-keep-alive"><a href="#2-keep-alive" class="headerlink" title="2.keep-alive"></a>2.keep-alive</h5><p>component 标签接受keep-alive 属性，可以将切换出去的组件保留在内存中，避免重新<br>渲染。我们将上述例子中的component 标签修改为：  </p>
<pre><code>&lt;component :is=&quot;currentView&quot; keep-alive&gt;&lt;/component&gt;

 home:{
         template:&apos;&lt;div&gt;&lt;p&gt;Home&lt;/p&gt;&lt;ul&gt;&lt;li v-for=&quot;item in items&quot;&gt;{{item}}&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&apos;,
         data:function(){
             return{
                 items:[]
             }
         },
         ready:function(){
             console.log(&quot;ready&quot;);
             this.items=[1,2,3,4,5,6,7,8];
         }
     }
</code></pre><p>在keep-alive属性下可以在home和list之间切换currentView，home组件的ready 函数只运行一次，可以看到控制台只输出了一次“fetch data”。而将keep-alive 属性去除后，再次在home 和list 组件间切换，会发现每点击到home，控制台都会输出一次“ready”。我们可以根据该特性适当地进行页面的性能优化，如果每个组件在激活时并不要求每次都实时请求数据，那使用keep-alive 可以避免一些不必要的重复渲染，导致用户看到停留时间过长的空白页面。但如果每次激活组件都需要向后端请求数据的话，就不太适合使用keepalive属性了。</p>
<p>Vue.js 2.0 中keep-alive 属性被修改为标签，例如：</p>
<pre><code>&lt;keep-alive&gt;
　 &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre><h5 id="3-activate钩子函数"><a href="#3-activate钩子函数" class="headerlink" title="3.activate钩子函数"></a>3.activate钩子函数</h5><p>1.Vue.js 给组件提供了activate 钩子函数，作用于动态组件切换或者静态组件初始化的过<br>程中<br>2.activate 接受一个回调函数做为参数，使用函数后组件才进行之后的渲染过程。<br>3.如下:  </p>
<pre><code>home:{
         template:&apos;&lt;div&gt;&lt;p&gt;Home&lt;/p&gt;&lt;ul&gt;&lt;li v-for=&quot;item in items&quot;&gt;{{item}}&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&apos;,
         data:function(){
             return{
                 items:[]
             }
         },
        activate:function(done){
            var that = this;
            // 此处的setTimeout 用于模拟正式业务中的ajax 异步请求数据
            setTimeout(function() {
                that.items = [1, 2, 3, 4, 5];
                done();
            }, 1000);

        }
     }
</code></pre><p>此时也可以定义两个component 作为对比，并设定其中一个属性为keep-alive ：</p>
<pre><code>&lt;component :is=&quot;currentView&quot;&gt;&lt;/component&gt;
&lt;component :is=&quot;currentView&quot; keep-alive&gt;&lt;/component&gt;
</code></pre><p>可以对比出，再次激活home 后，未使用keep-alive 的component 会延迟1s 的时间才<br>渲染出列表。  </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/11/10/vue-22-组件-动态组件/" class="archive-article-date">
  	<time datetime="2017-11-10T08:11:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-11-10</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js-前端开发-快速入门与专业应用/">Vue.js+前端开发+快速入门与专业应用</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-21-组件-内容分发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/10/vue-21-组件-内容分发/">vue(21)-组件-内容分发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/11/10/vue-21-组件-内容分发/" class="archive-article-date">
  	<time datetime="2017-11-10T08:09:14.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-11-10</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-20-组件-组件之间通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/05/vue-20-组件-组件之间通信/">vue(20)-组件-组件之间通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol>
<li>组件间通信是组件开发时非常重要的一环，我们既希望组件的独立性，数据能互不干涉,又不可避免组件间会有联系和交互。</li>
<li>Vue.js 在组件间通信这一部分既提供了:直接访问，自定义事件机制，通过广播、派发、监听等形式进行跨组件的函数调用。</li>
</ol>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-直接访问"><a href="#1-直接访问" class="headerlink" title="1.直接访问"></a>1.直接访问</h5><h5 id="2-自定义时间监听"><a href="#2-自定义时间监听" class="headerlink" title="2.自定义时间监听"></a>2.自定义时间监听</h5><p>在Vue 实例中，系统提供了一套自定义事件接口，用于组件间通信，方便修改组件状态。类似于在jQuery，我们给DOM 元素绑定一个非原生的事件，例如：$(‘#ele’).on(‘custom’,fn)，然后通过手动调用$(‘#ele’).trigger(‘custom’) 方式来进行事件的触发。 </p>
<h6 id="2-1-events选项"><a href="#2-1-events选项" class="headerlink" title="2.1 events选项"></a>2.1 events选项</h6><ol>
<li><p>我们可以在初始化实例或注册子组件的时候，直接传给选项events 一个对象.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">   el:&quot;#app&quot;,</div><div class="line">   data:&#123;</div><div class="line">     todo:[]</div><div class="line">    &#125;,</div><div class="line">   events:&#123;</div><div class="line">     &apos;add&apos;:fucntion(msg)&#123;</div><div class="line">       this.todo.push(msg);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>2.$on方法<br>我们也可以在某些特定情况或方法内采用$on 方法来监听事件，例如：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   var vm = new Vue(&#123;</div><div class="line">　 el : &apos;#app&apos;,</div><div class="line">　 data : &#123;</div><div class="line">　　 todo : []</div><div class="line">　 &#125;,</div><div class="line">　 methods : &#123;</div><div class="line">　　begin : function() &#123;</div><div class="line">　　　 this.$on(&apos;add&apos;, function(msg) &#123;</div><div class="line">　　　　　this.todo.push(msg);</div><div class="line">　　　 &#125;);</div><div class="line">　　&#125;</div><div class="line">　 &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><h5 id="3-自定义事件触发机制"><a href="#3-自定义事件触发机制" class="headerlink" title="3.自定义事件触发机制"></a>3.自定义事件触发机制</h5><p>设置完成事件监听后，下面来看下Vue.js 的触发机制。  </p>
<h6 id="3-1．-emit"><a href="#3-1．-emit" class="headerlink" title="3.1．$emit"></a>3.1．$emit</h6><p>在实例本身上触发事件。例如：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    events : &#123;</div><div class="line">　&apos;add&apos; : function(msg) &#123;</div><div class="line">　　 this.todo.push(msg);</div><div class="line">　 &#125;</div><div class="line">&#125;</div><div class="line">methods: &#123;</div><div class="line">　 onClick : function() &#123;</div><div class="line">　　 this.$emit(&apos;add&apos;, &apos;there is a message&apos;);// 即可触发events 中的add 函数</div><div class="line">　 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h6 id="3-2．-dispatch"><a href="#3-2．-dispatch" class="headerlink" title="3.2．$dispatch"></a>3.2．$dispatch</h6><p>派发事件，事件沿着父链冒泡，并且在第一次触发回调之后自动停止冒泡，除非触发函<br>数明确返回true，才会继续向上冒泡。  </p>
<p>父组件:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">events : &#123;</div><div class="line">      &apos;add&apos; : function(msg) &#123;</div><div class="line">       this.todo.push(msg);</div><div class="line">      //return true　明确返回true 后，事件会继续向上冒泡</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><p>子组件:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">methods: &#123;</div><div class="line">  toParent : function() &#123;</div><div class="line">  this.$dispatch(&apos;add&apos;, &apos;message from child&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>调用子组件中的toParent() 函数，即可向上冒泡，触发父组件中定义好的add 事件。</p>
<h6 id="3-3-broadcast"><a href="#3-3-broadcast" class="headerlink" title="3.3 $broadcast"></a>3.3 $broadcast</h6><p>广播事件，事件会向下传递给所有的后代。例如：</p>
<p>父组件:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">methods: &#123; </div><div class="line">  toChild : function() &#123; </div><div class="line">  this.$dispatch(&apos;msg&apos;, &apos;message from parent&apos;);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>子组件:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">events : &#123;</div><div class="line">  &apos;msg&apos; : function(msg) &#123;</div><div class="line">   alert(msg);</div><div class="line">   &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</code></pre><h6 id="3-4完整例子"><a href="#3-4完整例子" class="headerlink" title="3.4完整例子"></a>3.4完整例子</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">   &lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">   &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">   &lt;title&gt;Title&lt;/title&gt;</div><div class="line">   &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">   &lt;div id = &quot;app&quot;&gt;</div><div class="line">      &lt;button v-on:click=&quot;addTo&quot;&gt;添加&lt;/button&gt;</div><div class="line">       &lt;input v-model=&quot;msg&quot;&gt;</div><div class="line">       &lt;ul&gt;</div><div class="line">           &lt;li v-for=&quot;items in arr&quot; track-by=&quot;$index&quot;&gt;</div><div class="line">               &#123;&#123;items&#125;&#125;</div><div class="line">           &lt;/li&gt;</div><div class="line">       &lt;/ul&gt;</div><div class="line">   &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script&gt;</div></pre></td></tr></table></figure>
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/4.png" alt=""><br>在根实例的input 中输入内容“Hello”，点击“添加”， 即会在绑定v-for 指令的li 标签<br>中输出“Parent ：Hello”；或点击“广播”，则会输出“Child one: hello”和“Child two:<br>hello”两条数据，本质就是广播了事件to-child，两个子组件接受后触发了监听函数，将内<br>容和组件name 参数添加到父组件的todo 数组中。</p>
<h5 id="4-子组件索引"><a href="#4-子组件索引" class="headerlink" title="4.子组件索引"></a>4.子组件索引</h5><p>不建议组件间直接访问各自的实例，但有时也不可避免，Vue.js 也提供了直接<br>访问子组件的方式。除了之前的this.children 外，还可以给子组件绑定一个v-ref 指令，指<br>定一个索引ID，例如：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    　&lt;child-todo v-ref:first&gt;&lt;/child-todo&gt;</div></pre></td></tr></table></figure>
</code></pre><p>这样，在父组件中就可以通过this.$refs.first 的方式获取子组件实例。<br>如果v-ref 作用在v-for 绑定的元素上，例如：</p>
<pre><code>&lt;li v-for=&quot;item&quot; v-ref:items&gt;&lt;/li&gt;，
</code></pre><p>父组件获取的this.$refs.items 为一个数组，包含相应的子组件实例。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/11/05/vue-20-组件-组件之间通信/" class="archive-article-date">
  	<time datetime="2017-11-05T15:25:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-11-05</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js-前端开发-快速入门与专业应用/">Vue.js+前端开发+快速入门与专业应用</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-19-组件-组件选项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/04/vue-19-组件-组件选项/">vue(19)-组件-组件选项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>  组件接受的选项大部分与Vue 实例一样，相同的部分本章就不赘述了，要说明一下两<br>者的区别和组件选项中的props，用于接受父组件传递的参数。</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-组件选项中与Vue选项的区别"><a href="#1-组件选项中与Vue选项的区别" class="headerlink" title="1.组件选项中与Vue选项的区别"></a>1.组件选项中与Vue选项的区别</h5><p>组件选项中的el 和data 与Vue 构造器选项中这两个属性的赋值会稍微有些不同。在<br>Vue 构造器中是直接赋值：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">   el : &apos;#app&apos;,</div><div class="line">   data : &#123;name : &apos;Vue&apos;</div><div class="line">     &#125;</div><div class="line"> &#125;)</div></pre></td></tr></table></figure>
</code></pre><p>而在组件中需要这么定义:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var MyComponent = Vue.extend(&#123;</div><div class="line">   data:function()&#123;</div><div class="line">   return&#123;</div><div class="line">    name:&apos;component&apos;</div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><p>这是因为MyComponent可能会拥有多个实例，例如在某个组件模板中多次使用<mycomponent>&lt;/<br>my-component&gt;。如果将对象data 直接传递给了Vue.extend({})，那所有MyComponent 的实例会共享一个data 对象，所以需要通过函数来返回一个新对象。同样，el 也是这么处理，只不过在组件中通过el 来直接设定挂载元素的情况比较少见，自然避免了这种情况。</mycomponent></p>
<h5 id="2-组件Props"><a href="#2-组件Props" class="headerlink" title="2.组件Props"></a>2.组件Props</h5><p>选项props 是组件中非常重要的一个选项，起到了父子组件间桥梁的作用。<br>首先，需要明确的是，组件实例的作用域是孤立的，也就是说子组件的模板和模块中是<br>无法直接调用父组件的数据，所以通过props 将父组件的数据传递给子组件，子组件在接受数<br>据时需要显式声明props，例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div id = &quot;app&quot;&gt;</div><div class="line">   &lt;my-child parent = &quot;This data&quot;&gt;&lt;/my-child&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line"> Vue.component(&apos;my-child&apos;,&#123;</div><div class="line">    props:[&apos;parent&apos;],</div><div class="line">    template:&apos;&lt;p&gt;&#123;&#123;parent&#125;&#125; is from parent&lt;/p&gt;&apos;</div><div class="line">&#125;);</div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&apos;#app&apos;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>结果:<img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/1.png" alt=""></p>
<h6 id="2-1-驼峰命名"><a href="#2-1-驼峰命名" class="headerlink" title="2.1.驼峰命名"></a>2.1.驼峰命名</h6><p>同指令等情况相同，由于HTML 属性不区分大小写，如果我们在<my-child> 中的<br>属性使用驼峰式myParam 命名，即<my-child myparam="…">，那在props 中的命名即<br>为props: [‘myparam’]。所以如果需要使用驼峰式命名的话，我们需要在标签中使用myparam，<br>用“-”的方式隔开，这样在props 中就可以使用props: [‘myParam’] 的形式进行<br>声明。</my-child></my-child></p>
<h6 id="2-2动态Props"><a href="#2-2动态Props" class="headerlink" title="2.2动态Props"></a>2.2动态Props</h6><p>除了上述例子中传递静态数据的方式外，我们也可以通过v-bind 的方式将父组件的data 数据传递给子组件，例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;div id = &quot;app&quot;&gt;</div><div class="line">   &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</div><div class="line">    &lt;my-component v-bind:message=&quot;message&quot;&gt;&lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var myComponent =  Vue.extend(&#123;</div><div class="line">   props:[&apos;message&apos;],</div><div class="line">   template:&quot;&lt;p&gt;&#123;&#123;&apos;Message&apos;+message&#125;&#125;&lt;/p&gt;&quot;</div><div class="line">&#125;);</div><div class="line">Vue.component(&apos;my-component&apos;,myComponent);</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&apos;#app&apos;,</div><div class="line">    data:&#123;</div><div class="line">        message:&apos;Hello World&apos;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</code></pre><p>这样我们在更改根实例message 的值的时候，组件中的值也随之改动。除了v-bind 外，<br>也可以直接简写成<my-component :message="message"></my-component>。  </p>
<p>需要注意的是如果直接传递一个数值给子组件，就必须借助动态Props。如果通过</p>
<p><my-component :message="1"></my-component> 这种方式传递的话，则在子组件中获取<br>的message 其实是字符串“1”，只有通过如下的方式，才能准确传递数值：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;my-num :num=&quot;num&quot;&gt;&lt;/my-num&gt;</div><div class="line">Vue.component(&apos;my-num&apos;, &#123;</div><div class="line">    props : [&apos;num&apos;],</div><div class="line">    template : &quot;&lt;p&gt;&#123;&#123; num + &apos; is a &apos; + typeof num &#125;&#125;&lt;/p&gt;&quot;,</div><div class="line"> &#125;);</div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el : &apos;#app&apos;,</div><div class="line">   data : &#123;</div><div class="line">      num : 1</div><div class="line">   &#125;</div><div class="line"> &#125;);</div><div class="line">// 输出 &lt;p&gt;1 is a number&lt;/p&gt;</div></pre></td></tr></table></figure>
</code></pre><h6 id="2-3绑定类型"><a href="#2-3绑定类型" class="headerlink" title="2.3绑定类型"></a>2.3绑定类型</h6><p>在动态绑定中，v-bind 指令也提供了几种修饰符来进行不同方式的绑定。Props 绑定默<br>认是单向绑定，即当父组件的数据发生变化时，子组件的数据随之变化，但在子组件中修改数<br>据并不影响父组件。修饰符.sync 和.once 显示的声明绑定为双向或单次绑定，例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;div id = &quot;app&quot;&gt;</div><div class="line">   Parent component:&lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;</div><div class="line">    &lt;my-bind :msg=&quot;msg&quot;&gt;&lt;/my-bind&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">Vue.component(&apos;my-bind&apos;,&#123;</div><div class="line">    props:[&apos;msg&apos;],</div><div class="line">    template:&apos;&lt;div&gt;Child component:&lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;&lt;/div&gt;&apos;</div><div class="line">&#125;);</div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&apos;#app&apos;,</div><div class="line">    data:&#123;</div><div class="line">        msg:&apos;&apos;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</code></pre><p>结果:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/2.png" alt=""><br>此时父子组件中的即是单向绑定，可以通过input 修改子组件中的值并不影响父组件中<br>的值。</p>
<p>而如果将上述例子中<my-bind :msg="msg"></my-bind> 替换成<my-bind :msg.="" sync="msg"></my-bind>，则在子组件的input 中修改值即会影响父组件的值。  </p>
<p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/11/3.png" alt=""><br>once 修饰符意味着单次绑定，子组件接受一次父组件传递的数据后，单独维护这份数据，<br>既不影响父组件数据也不受其影响而更新。  </p>
<p>需要注意的是，由于Vue.js 处理的方式是引用传递，所以如果prop 传递的是一个对象<br>或数组，那在子组件内进行修改就会影响父组件的状态，即使是单向绑定也一样。  </p>
<h6 id="2-4-Props验证"><a href="#2-4-Props验证" class="headerlink" title="2.4 Props验证"></a>2.4 Props验证</h6><p>组件可以指定props 验证要求，这对开发第三方组件来说，可以让使用者更加准确地使<br>用组件。使用验证的时候，props 接受的参数为json 对象，而不是上述例子中的数组，例如：<br>props : { a : Number }，即为验证参数a 需为Number 类型，如果调用该组件传入的a 参数<br>为字符串，则会抛出异常。Vue.js 提供的Props 验证方式有很多种，下面逐一进行说明：  </p>
<p>1） 基础类型检测：prop: Number， 接受的参数为原生构造器，String、Number、<br>Boolean、Function、Object、Array。也可接受null，意味任意类型均可。  </p>
<p>2）多种类型：prop:[Number, String]， 允许参数为多种类型之一，例如类型可以为数值<br>或字符串。  </p>
<p>3）参数必需：prop: { type : Number, required: true}，参数必须有值且为Number<br>类型。  </p>
<p>4）参数默认：prop: { type : Number, default : 10 }，参数具有默认值10。需要注意<br>的是，如果默认值设置为数组或对象，需要像组件中data 属性那样，通过函数返回值的形式<br>赋值，如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">prop : &#123;</div><div class="line">type : Object,</div><div class="line">default : function() &#123;</div><div class="line">  return &#123; a : &apos;a&apos; &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</code></pre><p>5）绑定类型：prop: { twoWay : true}，校验绑定类型，如果非双向绑定会抛出一条警告。</p>
<p>6）自定义验证函数：prop : { validator : function(value) { return value &gt; 0; } }，验<br>证值必须大于0。</p>
<p>7）转换值：prop: { coerce : function(val) { return parseInt(val) }}，将字符串转化成<br>数值。<br>在开发环境中，如果验证失败了，Vue 将抛出一条警告，组件上也无法设置此值。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/11/04/vue-19-组件-组件选项/" class="archive-article-date">
  	<time datetime="2017-11-04T15:24:58.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-11-04</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js-前端开发-快速入门与专业应用/">Vue.js+前端开发+快速入门与专业应用</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-18-组件-注册组件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/31/vue-18-组件-注册组件/">vue(18)-组件-注册组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol>
<li>代码复用一直是软件开发中长期存在的一个问题，每个开发者都想再次使用之前写好的<br>代码，又担心引入这段代码后对现有的程序产生影响。</li>
<li>从jQuery 开始，我们就开始通过插件的形式复用代码，到Requirejs 开始将js 文件模块化，按需加载。</li>
<li>两种方式都提供了比较方便的复用方式，但往往还需要自己手动加入所需的CSS 文件和HTML模块。</li>
<li>现在，WebComponents 的出现提供了一种新的思路，可以自定义tag 标签，并拥有自身的模板、样式和交互。</li>
<li>Angularjs 的指令，Reactjs 的组件化都在往这方面做尝试。同样，Vue.js 也提供了自己的组件系统，支持自定义tag和原生HTML元素的扩展。</li>
</ol>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>Vue.js 创建组件构造器的方式非常简单：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var MyComponent = Vue.extend(&#123; … &#125;);</div></pre></td></tr></table></figure>
</code></pre><p>这样，我们就获得了一个组件构造器，但现在还无法直接使用这个组件,需要将组件注<br>册到应用中。Vue.js 提供了两种注册方式,分别是全局注册和局部注册。</p>
<h5 id="1-全局注册"><a href="#1-全局注册" class="headerlink" title="1.全局注册"></a>1.全局注册</h5><p>全局注册需要确保在根实例初始化之前注册，这样才能使组件在任意实例中被使用，注<br>册方式如下：  </p>
<pre><code>Vue.component(&apos;my-component&apos;, MyComponent);
</code></pre><p>这条语句需要写在</p>
<pre><code>var vm = new Vue({…})
</code></pre><p>之前，注册成功之后，就可以在模块中以自定义元素<my-component> 的形式使用组件。对于组件的命名，W3C 规范是字母小写且包<br>含一个短横杠“-”，Vue.js 暂不强制要求，但官方建议遵循这个规则比较好。<br>整个使用方法代码如下：</my-component></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> &lt;div id = &quot;app&quot;&gt;</div><div class="line">       &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line"> var MyComponent = Vue.extend(&#123;</div><div class="line">    template:&quot;&lt;p&gt;Hello Vue.js&lt;/p&gt;&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Vue.component(&apos;my-component&apos;,MyComponent);</div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&quot;#app&quot;,</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>输出结果:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">  &lt;p&gt;Hello Vue.js&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><h5 id="2-局部注册"><a href="#2-局部注册" class="headerlink" title="2.局部注册"></a>2.局部注册</h5><p>局部注册则限定了组件只能在被注册的组件中使用，而无法在其他组件中使用，注册方式如下：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> &lt;div id = &quot;app&quot;&gt;</div><div class="line">       &lt;my-parent&gt;&lt;/my-parent&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line"> var Child = Vue.extend(&#123;</div><div class="line">    template:&quot;&lt;p&gt;Child Hello Vue.js&lt;/p&gt;&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var Parent = Vue.extend(&#123;</div><div class="line">   template:&apos;&lt;div&gt;&lt;p&gt;parent component&lt;/p&gt;&lt;my-child&gt;&lt;/my-child&gt;&lt;/div&gt;&apos;,</div><div class="line">  components:&#123;</div><div class="line">       &apos;my-child&apos;:Child</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">Vue.component(&apos;my-parent&apos;,Parent);</div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&quot;#app&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>输出为:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;　　　　</div><div class="line">  &lt;p&gt;This is a parent component&lt;/p&gt;</div><div class="line">  &lt;p&gt;This is a child component&lt;/p&gt;　　　　</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</code></pre><p>而如果在根实例中调用</p>
<pre><code>&lt;my-child&gt;&lt;/my-child&gt;
</code></pre><p>会出现:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/53.png" alt=""></p>
<h5 id="3-注册组件"><a href="#3-注册组件" class="headerlink" title="3.注册组件"></a>3.注册组件</h5><p>Vue.js 对于上述两种注册方式也提供了简化的方法，我们可以直接在注册的时候定义组件构造器选项  </p>
<p>1.全局注册  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    Vue.component(&apos;my-component&apos;, &#123;</div><div class="line">       template : &apos;&lt;p&gt;This is a component&lt;/p&gt;&apos;</div><div class="line">    &#125;)</div><div class="line">    ```  </div><div class="line"></div><div class="line">2.局部注册</div></pre></td></tr></table></figure>

var Parent = Vue.extend({
     template: &apos;&lt;div&gt;
     &lt;p&gt;This is a parent component&lt;/p&gt;
      &lt;my-child&gt;&lt;/my-child&gt;
     &lt;/div&gt;&apos;,
   components: {
     &apos;my-child&apos;: {
      template : &apos;&lt;p&gt;This is a child component&lt;/p&gt;&apos;
    }
   }
 })
```
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/10/31/vue-18-组件-注册组件/" class="archive-article-date">
  	<time datetime="2017-10-31T13:50:35.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-10-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js-前端开发-快速入门与专业应用/">Vue.js+前端开发+快速入门与专业应用</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-17-过渡-过滤系统在Vue-js2-0中变化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/31/vue-17-过渡-过滤系统在Vue-js2-0中变化/">vue(17)-过渡-过滤系统在Vue.js2.0中变化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/10/31/vue-17-过渡-过滤系统在Vue-js2-0中变化/" class="archive-article-date">
  	<time datetime="2017-10-31T13:19:08.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-10-31</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-16-过渡-JavaScript过渡" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/31/vue-16-过渡-JavaScript过渡/">vue(16)-过渡-JavaScript过渡</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol>
<li>Vue.js可以和一些JavaScript动画库配合使用,只需要调用JavaScript钩子函数,不需要定义CSS样式。  </li>
<li>transition接受选项css:false,将直接跳过CSS检测,避免CSS规则干扰过渡,而且需要在enter和leave钩子函数中调用done函数,明确过渡结束时间。</li>
<li>引入Velocity.js来配合使用JavaScript过渡。</li>
</ol>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-Velocity-js"><a href="#1-Velocity-js" class="headerlink" title="1.Velocity.js"></a>1.Velocity.js</h5><p>Velocity.js是一款高效的动画引擎,可以单独使用也可以配合jQuery使用。它拥有和<br>jQuery的animate一样的api接口,但比jQuery在动画处理方面更强大、更流畅，以及模拟了一些现实世界的运动,例如弹性动画等。  </p>
<p>Velocity.js 可以当做jQuery 的插件使用，例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$element.velocity(&#123; left: &quot;100px&quot;&#125;, 500, &quot;swing&quot;, function()&#123;</div><div class="line">  console.log(&quot;done&quot;)&#125;);</div><div class="line">  $element.velocity(&#123; left: &quot;100px&quot;&#125;, &#123;</div><div class="line">    duration: 500,　</div><div class="line">    easing: &quot;swing&quot;,</div><div class="line">    complete : function()&#123;console.log(&quot;done&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>也可以单独使用，例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var el = document.getElementById(id);</div><div class="line">Velocity(el, &#123; left : &apos;100px&apos; &#125;, 500, &apos;swing&apos;, done);</div></pre></td></tr></table></figure>
</code></pre><h5 id="2-JavaScript过渡使用"><a href="#2-JavaScript过渡使用" class="headerlink" title="2.JavaScript过渡使用"></a>2.JavaScript过渡使用</h5><p>我们可以通过以下方式注册一个自定义的JavaScript过渡：  </p>
<pre><code>```
&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;../js/velocity.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/animate.css&quot; media=&quot;all&quot;&gt;
&lt;style&gt;
    .my-velocity-transition{
        position:absolute;
        top:0px;
        width:100px;
        height: 100px;
        background: chartreuse;
    }
&lt;/style&gt;

 &lt;div id=&quot;app&quot;&gt;
 &lt;div v-if=&quot;velocity&quot; transition=&quot;my-velocity&quot;&gt;&lt;/div&gt;
 &lt;/div&gt;

Vue.transition(&apos;my-velocity&apos;,{
    css:false,
    enter:function(el,done){
      Velocity(el,{left:&apos;100px&apos;},500,&apos;swing&apos;,done);
      console.log(&apos;enter&apos;,el.className);
    },
    enterCancelled:function(el){
      Velocity(el,&apos;stop&apos;);
      console.log(&apos;enterCancelled&apos;,el.className);
    },
    leave:function(el,done){
        Velocity(el,{left:&apos;0px&apos;},500,&apos;swing&apos;,done);
        console.log(&apos;leave&apos;,el.className);
    },
    leaveCancelled:function(el){
        Velocity(el,&apos;stop&apos;);
    }
});
var vm = new Vue({
    el:&quot;#app&quot;,
    data:{
        velocity:false
    }
});
``` 
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/52.gif" alt="">  </p>
<p>运行上述代码，在设置vm.velocity = true 后，过渡系统即会调用enter 钩子函数，通<br>过Velocity 对DOM 操作展现动画效果，然后强制调用done 函数，明确结束过渡效果。 </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/10/31/vue-16-过渡-JavaScript过渡/" class="archive-article-date">
  	<time datetime="2017-10-31T11:30:46.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-10-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js-前端开发-快速入门与专业应用/">Vue.js+前端开发+快速入门与专业应用</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-15-过渡-CSS过渡" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/30/vue-15-过渡-CSS过渡/">vue(15)-过渡-CSS过渡</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol>
<li>过渡系统是Vue.js 为DOM 动画效果提供的一个特性，它能在元素从DOM 中插入或移除时触发你的CSS 过渡（transition）和动画（animation），也就是说在DOM 元素发生变化时为其添加特定的class 类名，从而产生过渡效果。  </li>
<li>除了CSS 过渡外，Vue.js 的过渡系统也支持javascript 的过渡，通过暴露过渡系统的钩子函数，我们可以在DOM 变化的特定时机对其进行属性的操作，产生动画效果。  </li>
</ol>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="css过渡"><a href="#css过渡" class="headerlink" title="css过渡"></a>css过渡</h5><h6 id="1-css过渡用法"><a href="#1-css过渡用法" class="headerlink" title="1.css过渡用法"></a>1.css过渡用法</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">   &lt;div v-if=&quot;show&quot; transition=&quot;my-startup&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&quot;#app&quot;,</div><div class="line">    data:&#123;</div><div class="line">        show:false</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>首先在模板中用transition 绑定一个DOM 元素，并且使用v-if 指令使元素先处于未被<br>编译状态。然后在控制台内手动调用vm.show = true, 就可以看到DOM 元素最后输出为：  </p>
<pre><code>&lt;div class=&quot;my-startup-transition&quot;&gt;&lt;/div&gt;  
</code></pre><p>我们可以看到在DOM 元素完成编译后，过渡系统自动给元素添加了一个my-startuptransition<br>的class 类名。那么为了让这个效果更明显一点，还可以提前给这个类名添加一点<br>CSS 样式：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> &lt;style&gt;</div><div class="line">    .my-startup-transition&#123;</div><div class="line">        transition: all 1s ease;</div><div class="line">        width:100px;</div><div class="line">        height: 100px;</div><div class="line">        background: rosybrown;</div><div class="line">        opacity: 1;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">   &lt;div v-if=&quot;show&quot; transition=&quot;my-startup&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&quot;#app&quot;,</div><div class="line">    data:&#123;</div><div class="line">        show:false</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/44.png" alt=""></p>
<ol>
<li>此时再重新刷新并手动运行vm.show = true，发现最终样式效果是加载上去了，但并没有出现transition 的效果。  </li>
<li>这是由于在编译v-if 后，div 直接挂载到body 并添加mystartup-<br>transition 类名这两个过程中浏览器仅进行了一次重绘，这对于div 来说并没有产生属性的更新，所以没有执行css transition 的效果。</li>
<li>为了解决这个问题，Vue.js 的过渡系统给<br>元素插入及移除时分别添加了2 个类名：<em>-enter 和</em>-leave，* 即为transition 绑定的字符串，本例中即为my-startup  </li>
</ol>
<p>所以，在上述例子中，我们还需要添加两个类名样式，即my-startup-<br>enter, my-startup-leave:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.my-startup-transition&#123;</div><div class="line">       transition: all 1s ease;</div><div class="line">       width:100px;</div><div class="line">       height: 100px;</div><div class="line">       background: rosybrown;</div><div class="line">       opacity: 1;</div><div class="line"> &#125;</div><div class="line">  .my-startup-enter,.my-startup-leave&#123;</div><div class="line">      height: 0px;</div><div class="line">      opacity: 0;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</code></pre><p>整体代码:  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!--css--&gt;</div><div class="line">.my-startup-transition&#123;</div><div class="line">       transition: all 1s ease;</div><div class="line">       width:100px;</div><div class="line">       height: 100px;</div><div class="line">       background: rosybrown;</div><div class="line">       opacity: 1;</div><div class="line">   &#125;</div><div class="line">   .my-startup-enter,.my-startup-leave&#123;</div><div class="line">       height: 0px;</div><div class="line">       opacity: 0;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> &lt;!--html--&gt;</div><div class="line">  &lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;div v-if=&quot;show&quot; transition=&quot;my-startup&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line"></div><div class="line"> &lt;!--js--&gt;</div><div class="line"> var vm = new Vue(&#123;</div><div class="line">   el:&quot;#app&quot;,</div><div class="line">   data:&#123;</div><div class="line">       show:false</div><div class="line">   &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
</code></pre><p>效果:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/45.gif" alt=""></p>
<p>此时再重复之前的操作，就可以看到过渡效果了。需要注意的是，这两个类名的优先级需要高于.my-startup-transition，不然被my-startup-transition 覆盖后就失效了。</p>
<p>同样，我们也可以通过CSS 的animation 属性来实现过渡的效果，例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;!--css--&gt;</div><div class="line">.my-animation-transition&#123;</div><div class="line">      animation: increase 1s ease 0s 1;</div><div class="line">      width:100px;</div><div class="line">      height:100px;</div><div class="line">      background: bisque;</div><div class="line">  &#125;</div><div class="line">   .my-animation-enter,.my-animation-leave&#123;</div><div class="line">       height: 0px;</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">  @keyframes increase &#123;</div><div class="line">        from&#123;height: 0px;&#125;</div><div class="line">        to&#123;height: 100px;&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&lt;!--html--&gt;</div><div class="line"> &lt;div id=&quot;app&quot;&gt;</div><div class="line">  &lt;div v-if=&quot;animation&quot; transition=&quot;my-animation&quot;&gt;animation&lt;/div&gt;</div><div class="line"> &lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!--js--&gt;</div><div class="line"> var vm = new Vue(&#123;</div><div class="line">    el:&quot;#app&quot;,</div><div class="line">    data:&#123;</div><div class="line">        animation:true</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/46.gif" alt="">  </p>
<p>除了直接在元素上添加transition=”name” 外,Vue.js也支持动态绑定CSS名称，可用于元素需要多个过渡效果的场景。例如：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">   &lt;div v-if=&quot;show&quot; v-bind:transition=&quot;transitionName&quot;&gt;&lt;/div&gt;</div><div class="line">   &lt;div v-if=&quot;show&quot; :transition=&quot;transitionName&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script&gt;</div><div class="line"> var vm = new Vue(&#123;</div><div class="line">    el:&quot;#app&quot;,</div><div class="line">    data:&#123;</div><div class="line">        show:false,</div><div class="line">        transitionName:&apos;fade&apos;</div><div class="line">     &#125;</div><div class="line">  &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</code></pre><p>Vue.js 本身并不提供内置的过渡CSS 样式，仅仅是提供了过渡需要使用的样式的加载或移除时机，这样更便于我们灵活地按需去设计过渡样式。  </p>
<h6 id="2-css过渡钩子函数"><a href="#2-css过渡钩子函数" class="headerlink" title="2.css过渡钩子函数"></a>2.css过渡钩子函数</h6><p>Vue.js提供了在插入或DOM元素时类名变化的钩子函数,可以通过</p>
<pre><code>Vue.transition(&apos;name&apos;,{}) 
</code></pre><p>的方式来执行具体的函数操作。例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;!--html--&gt;</div><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">   &lt;div v-if=&quot;show&quot; transition=&quot;my-startup&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!--js--&gt;</div><div class="line">Vue.transition(&apos;my-startup&apos;,&#123;</div><div class="line">    beforeEnter:function(el)&#123;</div><div class="line">        console.log(&apos;beforeEnter&apos;,el.className);</div><div class="line">    &#125;,</div><div class="line">    enter:function(el)&#123;</div><div class="line">        console.log(&apos;enter&apos;,el.className);</div><div class="line">    &#125;,</div><div class="line">    afterEnter:function(el)&#123;</div><div class="line">        console.log(&apos;afterEnter&apos;,el.className);</div><div class="line">    &#125;,</div><div class="line">    enterCancelled:function(el)&#123;</div><div class="line">       console.log(&apos;enterCancelled&apos;,el.className);</div><div class="line">    &#125;,</div><div class="line">    beforeLeave:function(el)&#123;</div><div class="line">        console.log(&apos;beforeLeave&apos;,el.className);</div><div class="line">    &#125;,</div><div class="line">    leave:function(el)&#123;</div><div class="line">        console.log(&apos;leave&apos;,el.className);</div><div class="line">    &#125;,</div><div class="line">    afterLeave: function (el) &#123;</div><div class="line">        console.log(&apos;afterLeave&apos;, el.className);</div><div class="line">    &#125;,</div><div class="line">    leaveCancelled: function (el) &#123;</div><div class="line">        console.log(&apos;leaveCancelled&apos;, el.className);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el:&quot;#app&quot;,</div><div class="line">    data:&#123;</div><div class="line">        show:false</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>效果:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/47.png" alt=""><br>这样，我们能很清楚地看到钩子函数执行的顺序以及元素类名的变化。同样的，还可以<br>再次更改vm.show 的值置为false，结果如下：<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/48.png" alt="">  </p>
<p>由于元素在使用CSS 的transition 和animation 时，系统的流程不完全一样。所以先以<br>transition 为例,总结下过渡系统的流程。  </p>
<p>当vm.show=true时:<br>1.调用beforeEnter函数。<br>2.添加enter类名到元素上。<br>3.将元素插入DOM中。<br>4.调用enter 函数。<br>5.强制reflow一次,然后移除enter类名，触发过渡效果。<br>6.如果此时元素被删除,则触发enterCancelled函数。<br>7.监听transitionend事件,过渡结束后调用afterEnter函数。  </p>
<p>当vm.show=false时<br>1.调用beforeLeave函数。<br>2.添加v-leave 类名，触发过渡效果。<br>3.调用leave 函数。<br>4.如果此时元素被删除，则触发leaveCancelled函数。<br>5.监听transitionend事件，删除元素及*-leave类名。<br>6.调用afterLeave函数。  </p>
<p>如果使用animation 作为过渡的话，在DOM 插入时，*-enter 类名不会立即被删除，而<br>是在animationend 事件触发式删除。  </p>
<p>另外，enter 和leave 函数都有第二个可选的回调参数，用于控制过渡何时结束，而不是<br>监听transitionend 和animationend 事件，例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    my-done-transition &#123;</div><div class="line">     transition: all 2s ease;</div><div class="line">     width: 100px; height: 100px;</div><div class="line">     background: black;</div><div class="line">     opacity: 1;</div><div class="line">    &#125;</div><div class="line">   .my-done-enter, .my-done-leave&#123;</div><div class="line">      height: 0px;</div><div class="line">      opacity: 0;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">Vue.transition(&apos;my-done&apos;, &#123;</div><div class="line">　 enter: function (el, done) &#123;</div><div class="line">　　　this.enterTime = new Date();</div><div class="line">　　　setTimeout(done, 500);</div><div class="line">　 &#125;,</div><div class="line">　 afterEnter: function (el) &#123;</div><div class="line">　　　console.log(&apos;afterEnter&apos;, new Date() - this.enterTime);</div><div class="line">　 &#125;</div><div class="line">&#125;)</div><div class="line">var vm = new Vue(&#123;</div><div class="line">　 el : &apos;#app&apos;,</div><div class="line">　 data: &#123;</div><div class="line">　　　done : false</div><div class="line">　 &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/49.png" alt="">  </p>
<h5 id="3-显示声明过渡类型"><a href="#3-显示声明过渡类型" class="headerlink" title="3.显示声明过渡类型"></a>3.显示声明过渡类型</h5><p>Vue.js 可以指定过渡元素监听的结束事件的类型， 例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.transition(&apos;done-type&apos;, &#123;</div><div class="line"> type: &apos;animation&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><p>此时Vue.js 就只监听元素的animationend 事件，避免元素上还存在transition 时导致<br>的结束事件触发不一致。  </p>
<h5 id="4-自定义过渡类名"><a href="#4-自定义过渡类名" class="headerlink" title="4.自定义过渡类名"></a>4.自定义过渡类名</h5><p>除了使用默认的类名<em>-enter, </em>-leave 外，Vue.js 也允许我们自定义过渡类名，例如：  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    Vue.transition(&apos;my-startup&apos;, &#123;</div><div class="line">      enterClass: &apos;fadeIn&apos;,</div><div class="line">      leaveClass: &apos;fadeOut&apos;</div><div class="line">    &#125;)</div><div class="line">    ```  </div><div class="line"></div><div class="line">我们可以通过上述钩子函数的例子，观测元素的类名变化：</div><div class="line"></div><div class="line">![](https://raw.githubusercontent.com/startshineye/img/master/2017/10/50.png)</div><div class="line"></div><div class="line"></div><div class="line">Vue.js官方推荐了一个CSS动画库,animate.css,配合自定义过渡类名使用,可以达</div><div class="line">到非常不错的效果。只需要引入一个CSS 文件，http://cdn.bootcss.com/animate.css/3.5.2/animate.min.css，就可以使用里面的预设动画。例如：</div></pre></td></tr></table></figure>

&lt;!--引入--&gt;
&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/animate.css&quot; media=&quot;all&quot;&gt;

&lt;!--html--&gt;
&lt;div id=&quot;app&quot;&gt;
   &lt;div v-if=&quot;animateShow&quot; class = &quot;animated&quot; transition=&quot;bounce&quot;&gt;bounce effect&lt;/div&gt;
&lt;/div&gt;

&lt;!--js--&gt;
 Vue.transition(&apos;bounce&apos;,{
    enterClass:&apos;bounceIn&apos;,
    leaveClass:&apos;bounceOut&apos;
});
var vm = new Vue({
    el:&quot;#app&quot;,
    data:{
        animateShow:false
    }
});
```
</code></pre><p>效果:<br><img src="https://raw.githubusercontent.com/startshineye/img/master/2017/10/51.gif" alt=""></p>
<p>在使用animate.css 时，需要先给元素附上animated 类名，然后再添加预设的动效类名，<br>例如上例中的bounceIn、bounceOut，这样就能看到动画效果。这个库提供了多种强调展示<br>（例如弹性、抖动）、渐入渐出、翻转、旋转、放大缩小等效果。所有的效果可以访问官方网<br>址<a href="https://daneden.github.io/animate.css/" target="_blank" rel="external">https://daneden.github.io/animate.css/</a> 在线观看。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/10/30/vue-15-过渡-CSS过渡/" class="archive-article-date">
  	<time datetime="2017-10-30T14:52:51.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-10-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js-前端开发-快速入门与专业应用/">Vue.js+前端开发+快速入门与专业应用</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vue-14-过滤器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/30/vue-14-过滤器/">vue(14)-过滤器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/10/30/vue-14-过滤器/" class="archive-article-date">
  	<time datetime="2017-10-30T14:24:06.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-10-30</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/15/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/49/">49</a><a class="extend next" rel="next" href="/page/17/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Startshineye
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/CTI/" style="font-size: 11.11px;">CTI</a> <a href="/tags/Cookie/" style="font-size: 10.56px;">Cookie</a> <a href="/tags/DevelopmentSkills/" style="font-size: 10px;">DevelopmentSkills</a> <a href="/tags/Easyui/" style="font-size: 10px;">Easyui</a> <a href="/tags/ElasticStack/" style="font-size: 10.56px;">ElasticStack</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IE问题/" style="font-size: 10px;">IE问题</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 12.22px;">JVM</a> <a href="/tags/JavaSE/" style="font-size: 15px;">JavaSE</a> <a href="/tags/Jeecg/" style="font-size: 11.67px;">Jeecg</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Myeclipse/" style="font-size: 14.44px;">Myeclipse</a> <a href="/tags/Netty/" style="font-size: 16.67px;">Netty</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 16.67px;">Oracle</a> <a href="/tags/Redis/" style="font-size: 12.22px;">Redis</a> <a href="/tags/Servlet/" style="font-size: 11.67px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 10.56px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/SpringBoot/" style="font-size: 19.44px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 11.67px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 11.11px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Vue/" style="font-size: 18.89px;">Vue</a> <a href="/tags/Vue-js-前端开发-快速入门与专业应用/" style="font-size: 17.22px;">Vue.js+前端开发+快速入门与专业应用</a> <a href="/tags/Weblogic/" style="font-size: 12.22px;">Weblogic</a> <a href="/tags/Websocket/" style="font-size: 10.56px;">Websocket</a> <a href="/tags/Work-Problem/" style="font-size: 10px;">Work-Problem</a> <a href="/tags/bg/" style="font-size: 10px;">bg</a> <a href="/tags/c/" style="font-size: 10.56px;">c</a> <a href="/tags/crawler/" style="font-size: 17.78px;">crawler</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/easyui/" style="font-size: 10px;">easyui</a> <a href="/tags/hibernate/" style="font-size: 10.56px;">hibernate</a> <a href="/tags/html-css/" style="font-size: 10.56px;">html+css</a> <a href="/tags/html-css/" style="font-size: 15px;">html-css</a> <a href="/tags/html-ss/" style="font-size: 10px;">html-ss</a> <a href="/tags/im/" style="font-size: 13.89px;">im</a> <a href="/tags/ipcc/" style="font-size: 10px;">ipcc</a> <a href="/tags/jQuery/" style="font-size: 12.22px;">jQuery</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/java-String/" style="font-size: 10px;">java String</a> <a href="/tags/javaSE/" style="font-size: 10.56px;">javaSE</a> <a href="/tags/javaWeb/" style="font-size: 10px;">javaWeb</a> <a href="/tags/javascript/" style="font-size: 11.11px;">javascript</a> <a href="/tags/java并发编程/" style="font-size: 11.67px;">java并发编程</a> <a href="/tags/java集合/" style="font-size: 10.56px;">java集合</a> <a href="/tags/junit测试/" style="font-size: 10px;">junit测试</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 16.11px;">linux</a> <a href="/tags/log4j/" style="font-size: 11.67px;">log4j</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/netty/" style="font-size: 11.67px;">netty</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodeJs/" style="font-size: 10px;">nodeJs</a> <a href="/tags/redis/" style="font-size: 12.78px;">redis</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/shiro/" style="font-size: 12.78px;">shiro</a> <a href="/tags/sockJs/" style="font-size: 10px;">sockJs</a> <a href="/tags/socket网络编程/" style="font-size: 10.56px;">socket网络编程</a> <a href="/tags/struts1/" style="font-size: 11.11px;">struts1</a> <a href="/tags/vue/" style="font-size: 10.56px;">vue</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weblogic/" style="font-size: 11.11px;">weblogic</a> <a href="/tags/websocket/" style="font-size: 15.56px;">websocket</a> <a href="/tags/work/" style="font-size: 14.44px;">work</a> <a href="/tags/zyzx/" style="font-size: 18.33px;">zyzx</a> <a href="/tags/代理/" style="font-size: 11.67px;">代理</a> <a href="/tags/前端/" style="font-size: 10.56px;">前端</a> <a href="/tags/动手写一个MVC/" style="font-size: 12.22px;">动手写一个MVC</a> <a href="/tags/反射/" style="font-size: 15.56px;">反射</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/微博/" style="font-size: 10px;">微博</a> <a href="/tags/文件读取/" style="font-size: 10px;">文件读取</a> <a href="/tags/泛型/" style="font-size: 13.33px;">泛型</a> <a href="/tags/注解/" style="font-size: 11.11px;">注解</a> <a href="/tags/类加载器/" style="font-size: 13.33px;">类加载器</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/自己写一个apache服务器/" style="font-size: 16.67px;">自己写一个apache服务器</a> <a href="/tags/转载/" style="font-size: 12.22px;">转载</a> <a href="/tags/集合/" style="font-size: 12.22px;">集合</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">baidu</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jd.com/">jd</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">毕业于&lt;br&gt;相信技术可以改变人与人之间的生活&lt;br&gt;码农一枚</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>